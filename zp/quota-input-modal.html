<!-- ==================== QUOTA INPUT MODAL V3.0 ==================== -->
<!-- Multi-Day Quota Support - MANAGEMENT API (BEW√ÑHRT!) -->
<script>
    console.log('üîÑ Quota Modal V3.0 loaded - Management API');
    console.log('üìç Using endpoint: /wci/hrs/hrs_write_quota_v3.php');
    console.log('üîß API: /api/v1/manage/hutQuota/{hutId} (BEW√ÑHRT wie hrs_del_quota_batch.php)');
</script>
<style>
    /* Custom Modal Breite: 30% schm√§ler als vorher */
    #quotaInputModal .modal-dialog {
        max-width: 66vw !important;
        width: 66vw !important;
    }

    #quotaInputModal .modal-body {
        max-height: 80vh;
        overflow-y: auto;
        padding: 15px !important;
        /* Reduziert von Standard 20px */
    }

    #quotaInputModal .modal-header {
        padding: 10px 15px !important;
        /* Reduziert von Standard 16px 20px */
    }

    #quotaInputModal .modal-footer {
        padding: 10px 15px !important;
        /* Reduziert von Standard 16px 20px */
    }

    #quotaInputModal .modal-title {
        font-size: 1.1rem !important;
        /* Kleinere Schrift f√ºr Titel */
    }

    /* Kompaktere Form-Elemente */
    #quotaInputModal .form-label {
        font-size: 0.9rem !important;
        margin-bottom: 0.3rem !important;
        /* Reduziert von 0.5rem */
    }

    #quotaInputModal .form-control {
        font-size: 0.85rem !important;
        padding: 0.25rem 0.5rem !important;
        /* Reduziert von 0.375rem 0.75rem */
    }

    #quotaInputModal .mb-3 {
        margin-bottom: 0.75rem !important;
        /* Reduziert von 1rem */
    }

    #quotaInputModal .mb-4 {
        margin-bottom: 1rem !important;
        /* Reduziert von 1.5rem */
    }

    #quotaInputModal .my-4 {
        margin-top: 1rem !important;
        margin-bottom: 1rem !important;
        /* Reduziert von 1.5rem */
    }

    #quotaInputModal .alert {
        padding: 0.5rem 0.75rem !important;
        /* Reduziert von 0.75rem 1.25rem */
        font-size: 0.85rem !important;
        margin-bottom: 0.75rem !important;
        /* Reduziert von 1rem */
    }

    #quotaInputModal h6 {
        font-size: 0.95rem !important;
        margin-bottom: 0.5rem !important;
        /* Reduziert von 0.75rem */
    }

    #quotaInputModal .row {
        margin-bottom: 0.5rem !important;
        /* Reduziert spacing zwischen rows */
    }

    #quotaInputModal hr {
        margin: 0.75rem 0 !important;
        /* Reduziert von 1rem */
    }

    /* Scrollbare Quota-Preview Liste */
    #quotaInputModal #quotaPreviewDays {
        max-height: 200px !important;
        overflow-y: auto !important;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.02);
    }

    /* Scrollbar Styling f√ºr bessere Optik */
    #quotaInputModal #quotaPreviewDays::-webkit-scrollbar {
        width: 6px;
    }

    #quotaInputModal #quotaPreviewDays::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
    }

    #quotaInputModal #quotaPreviewDays::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    #quotaInputModal #quotaPreviewDays::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    /* Tabelle responsiv */
    #quotaInputModal table {
        width: 100%;
        white-space: nowrap;
        font-size: 0.85rem !important;
        /* Kleinere Schrift in Tabellen */
    }

    #quotaStatusModal .modal-dialog {
        max-width: 600px !important;
    }

    #quotaStatusModal .modal-body {
        padding: 12px !important;
        max-height: 70vh;
        overflow-y: auto;
    }

    #quotaStatusModal .modal-header {
        padding: 8px 12px !important;
    }

    #quotaStatusModal .modal-footer {
        padding: 8px 12px !important;
    }

    #quotaStatusModal .modal-title {
        font-size: 1rem !important;
    }

    /* Scrollbare Status-Steps Liste */
    #quotaStatusModal [data-role="quota-status-steps"] {
        max-height: 250px !important;
        overflow-y: auto !important;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        padding: 4px;
        background: rgba(255, 255, 255, 0.02);
    }

    #quotaStatusModal [data-role="quota-status-steps"]::-webkit-scrollbar {
        width: 5px;
    }

    #quotaStatusModal [data-role="quota-status-steps"]::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
    }

    #quotaStatusModal [data-role="quota-status-steps"]::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    #quotaStatusModal .list-group-item {
        font-size: 0.8rem !important;
        padding: 0.4rem 0.6rem !important;
        margin-bottom: 2px;
    }

    #quotaStatusModal .progress {
        height: 12px !important;
        margin-bottom: 0.75rem !important;
    }

    #quotaStatusModal .quota-status-details {
        background: rgba(15, 23, 42, 0.35);
        border-radius: 8px;
        padding: 6px 8px;
        /* Noch kompakter */
        max-height: 300px;
        overflow-y: auto;
    }

    #quotaStatusModal .quota-status-details::-webkit-scrollbar {
        width: 5px;
    }

    #quotaStatusModal .quota-status-details::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
    }

    #quotaStatusModal .quota-status-details::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    #quotaStatusModal .quota-detail-segment+.quota-detail-segment {
        margin-top: 6px;
        /* Noch kompakter */
    }

    #quotaStatusModal .quota-detail-item {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 8px;
        /* Noch kompakter */
        padding: 4px 6px;
        /* Noch kompakter */
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.03);
        transition: all 0.2s ease;
        border-left: 3px solid transparent;
    }

    #quotaStatusModal .quota-detail-item:first-of-type {
        margin-top: 0;
    }

    #quotaStatusModal .quota-detail-item .quota-detail-date {
        font-weight: 600;
        color: #e5edff;
        font-size: 0.85rem !important;
        /* Kleinere Schrift */
    }

    #quotaStatusModal .quota-detail-item .quota-detail-message {
        font-size: 0.75rem !important;
        /* Reduziert von 12px */
        color: #94a3b8;
        margin-top: 1px;
        /* Reduziert von 2px */
    }

    #quotaStatusModal .quota-detail-item .quota-detail-badge {
        align-self: center;
        font-size: 0.75rem !important;
    }

    #quotaStatusModal .quota-detail-item.state-pending {
        background: rgba(148, 163, 184, 0.08);
        border-left-color: rgba(148, 163, 184, 0.4);
    }

    #quotaStatusModal .quota-detail-item.state-active {
        background: rgba(129, 140, 248, 0.08);
        border-left-color: rgba(129, 140, 248, 0.6);
        animation: pulse-blue 1.5s infinite;
    }

    @keyframes pulse-blue {

        0%,
        100% {
            background: rgba(129, 140, 248, 0.08);
        }

        50% {
            background: rgba(129, 140, 248, 0.15);
        }
    }

    #quotaStatusModal .quota-detail-item.state-success {
        background: rgba(34, 197, 94, 0.08);
        border-left-color: rgba(34, 197, 94, 0.6);
    }

    #quotaStatusModal .quota-detail-item.state-warn {
        background: rgba(234, 179, 8, 0.08);
        border-left-color: rgba(234, 179, 8, 0.6);
    }

    #quotaStatusModal .quota-detail-item.state-error {
        background: rgba(248, 113, 113, 0.08);
        border-left-color: rgba(248, 113, 113, 0.6);
    }
</style>

<div class="modal fade" id="quotaInputModal" tabindex="-1" aria-labelledby="quotaInputModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="quotaInputModalLabel">üìä Quota bearbeiten</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="quotaForm">
                    <!-- Zeitraum Anzeige -->
                    <div class="alert alert-info mb-4">
                        <strong>Selektierte Tage:</strong> <span id="quotaDateRange"></span><br>
                        <strong>Aktuelle Belegung:</strong> <span id="currentOccupancy">--</span> Pl√§tze
                    </div>

                    <!-- Zielkapazit√§t -->
                    <div class="mb-4">
                        <label for="targetCapacity" class="form-label">
                            <strong>Zielauslastung (Gesamt)</strong>
                        </label>
                        <div class="row align-items-center">
                            <div class="col-9">
                                <input type="range" class="form-range" id="targetCapacity" min="0" max="200" value="28"
                                    step="5">
                            </div>
                            <div class="col-3">
                                <input type="number" class="form-control" id="targetCapacityValue" min="0" max="200"
                                    value="28" step="5">
                            </div>
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Kategorie-Verteilung (fix, ohne Priorit√§ten) -->
                    <h6 class="mb-3">Kategorie-Verteilung</h6>

                    <!-- ML (Lager) - bekommt immer den REST -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>ML - Matratzenlager</strong>
                        </div>
                        <div class="col-6">
                            <input type="text" class="form-control" value="(bekommt REST)" disabled readonly
                                style="background-color: #d1ecf1; color: #0c5460; font-weight: bold;">
                        </div>
                    </div>

                    <!-- MBZ (Betten) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>MBZ - Mehrbettzimmer</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="betten" id="max-mbz">
                        </div>
                    </div>

                    <!-- 2BZ (DZ) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>2BZ - Zweibettzimmer</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="dz" id="max-2bz">
                        </div>
                    </div>

                    <!-- SK (Sonder) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>SK - Sonderkategorie</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="sonder" id="max-sk">
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Live-Preview berechneter Quotas -->
                    <div class="alert alert-success" id="quotaPreview">
                        <h6 class="mb-3">üìä Berechnete Quotas (pro Tag):</h6>
                        <div id="quotaPreviewDays">
                            <!-- Wird dynamisch gef√ºllt mit Quotas f√ºr jeden Tag -->
                        </div>
                    </div>

                    <!-- Warnung bei √úberbelegung -->
                    <div class="alert alert-warning d-none" id="overbookingWarning">
                        ‚ö†Ô∏è <strong>Warnung:</strong> Bei einigen Tagen √ºberschreitet die Belegung die Zielkapazit√§t!<br>
                        F√ºr diese Tage werden alle Quotas auf 0 gesetzt.
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="saveQuotaBtn">üíæ Speichern</button>
            </div>
        </div>
    </div>
</div>

<!-- Status Modal -->
<div class="modal fade" id="quotaStatusModal" tabindex="-1" aria-labelledby="quotaStatusModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="quotaStatusModalLabel">Quota Deploy</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="progress mb-3">
                    <div class="progress-bar" role="progressbar" style="width: 0%" aria-valuemin="0" aria-valuemax="100"
                        data-role="quota-status-progress"></div>
                </div>
                <ul class="list-group" data-role="quota-status-steps"></ul>
                <div class="quota-status-details mt-3 d-none" data-role="quota-status-detail">
                    <div class="text-muted text-uppercase small mb-1">Details</div>
                    <div data-role="quota-status-detail-body"></div>
                </div>
                <div class="alert mt-3 d-none" role="alert" data-role="quota-status-summary"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" data-role="quota-status-close"
                    disabled>Schlie√üen</button>
            </div>
        </div>
    </div>
</div>

<script>
    /**
     * Quota Input Modal Manager
     * =========================
     * Verwaltet das Quota-Eingabe-Modal mit Priorit√§ts-basierter Verteilung
     */
    class QuotaInputModal {
        constructor(renderer) {
            this.renderer = renderer;
            this.modal = new bootstrap.Modal(document.getElementById('quotaInputModal'));
            this.selectedDays = [];
            this.currentOccupancy = 0;
            this.lastTargetCapacityFineAdjust = false;
            this.statusModal = null;
            this.statusModalInstance = null;
            this.statusProgressBar = null;
            this.statusStepsContainer = null;
            this.statusSummary = null;
            this.statusCloseBtn = null;
            this.statusDetailContainer = null;
            this.statusDetailBody = null;
            this.statusSteps = [];
            this.currentSegments = [];
            this.statusDetailEntries = new Map();

            // SSE Support
            this.sseSessionId = null;
            this.eventSource = null;

            this.initializeEventListeners();
            this.initializeStatusModal();

            // WICHTIG: Verhindere Browser-Kontextmen√º im Modal
            const modalElement = document.getElementById('quotaInputModal');
            modalElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }, { capture: true });
        }

        initializeStatusModal() {
            this.statusModal = document.getElementById('quotaStatusModal');
            if (!this.statusModal) {
                console.warn('Quota status modal not found. Falling back to alerts.');
                return;
            }

            this.statusModalInstance = new bootstrap.Modal(this.statusModal, {
                backdrop: 'static',
                keyboard: false
            });
            this.statusProgressBar = this.statusModal.querySelector('[data-role="quota-status-progress"]');
            this.statusStepsContainer = this.statusModal.querySelector('[data-role="quota-status-steps"]');
            this.statusSummary = this.statusModal.querySelector('[data-role="quota-status-summary"]');
            this.statusCloseBtn = this.statusModal.querySelector('[data-role="quota-status-close"]');
            this.statusDetailContainer = this.statusModal.querySelector('[data-role="quota-status-detail"]');
            this.statusDetailBody = this.statusModal.querySelector('[data-role="quota-status-detail-body"]');

            this.statusModal.addEventListener('hidden.bs.modal', () => {
                this.resetStatusModal();
            });
        }

        resetStatusModal() {
            if (!this.statusModal) return;

            if (this.statusStepsContainer) {
                this.statusStepsContainer.innerHTML = '';
            }

            if (this.statusProgressBar) {
                this.statusProgressBar.style.width = '0%';
                this.statusProgressBar.classList.remove('bg-danger', 'bg-warning');
                this.statusProgressBar.classList.add('bg-success');
            }

            if (this.statusSummary) {
                this.statusSummary.textContent = '';
                this.statusSummary.classList.add('d-none');
                this.statusSummary.classList.remove('alert-success', 'alert-warning', 'alert-danger');
            }

            if (this.statusDetailBody) {
                this.statusDetailBody.innerHTML = '';
            }

            if (this.statusDetailContainer) {
                this.statusDetailContainer.classList.add('d-none');
            }

            this.statusDetailEntries.clear();

            if (this.statusCloseBtn) {
                this.statusCloseBtn.disabled = true;
            }

            this.statusSteps = [];
        }

        applyRealTimeQuotaUpdates(segmentId, createdQuotas, dailyQuotas) {
            console.log(`[${new Date().toISOString()}] üîÑ Applying real-time quota updates for ${createdQuotas.length} quotas`);

            // Create a map for quick lookup
            const quotaMap = new Map();
            createdQuotas.forEach(quota => {
                if (quota.date) {
                    quotaMap.set(quota.date, quota);
                }
            });

            // Apply updates with staggered delays for visual effect
            dailyQuotas.forEach((dailyQuota, index) => {
                const delay = index * 150; // 150ms between each update

                setTimeout(() => {
                    const createdQuota = quotaMap.get(dailyQuota.date);
                    if (createdQuota) {
                        const quantities = createdQuota.quantities || {
                            lager: dailyQuota.quota_lager,
                            betten: dailyQuota.quota_betten,
                            dz: dailyQuota.quota_dz,
                            sonder: dailyQuota.quota_sonder
                        };

                        const totalCapacity = Object.values(quantities).reduce((sum, q) => sum + (q || 0), 0);
                        const quotaDetails = this.formatQuotaQuantities(quantities);
                        const message = `‚úÖ Quota erstellt: ${quotaDetails} (Gesamt: ${totalCapacity})`;

                        console.log(`[${new Date().toISOString()}] ‚úÖ Real-time update for ${dailyQuota.date}: ${message}`);
                        this.updateStatusDetailEntry(segmentId, dailyQuota.date, 'success', message);
                    }
                }, delay);
            });
        }

        // SSE Methods
        generateSSESessionId() {
            return 'quota_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        startSSEConnection(sessionId) {
            this.sseSessionId = sessionId;
            console.log(`[${new Date().toISOString()}] üîó Starting SSE connection with session:`, sessionId);

            try {
                const sseUrl = `/wci/hrs/quota_sse.php?session_id=${sessionId}`;
                console.log(`[${new Date().toISOString()}] üåê SSE URL:`, sseUrl);

                this.eventSource = new EventSource(sseUrl);

                this.eventSource.addEventListener('connected', (event) => {
                    console.log(`[${new Date().toISOString()}] ‚úÖ SSE Connected:`, JSON.parse(event.data));
                });

                this.eventSource.addEventListener('quota_processing_started', (event) => {
                    const data = JSON.parse(event.data);
                    console.log(`[${new Date().toISOString()}] üöÄ Processing started:`, data);
                    this.setStatusStep(0, 'active', data.message);
                });

                this.eventSource.addEventListener('quota_created', (event) => {
                    const data = JSON.parse(event.data);
                    console.log(`[${new Date().toISOString()}] ‚úÖ Quota created:`, data);
                    this.handleSSEQuotaCreated(data);
                });

                this.eventSource.addEventListener('quota_deleted', (event) => {
                    const data = JSON.parse(event.data);
                    console.log(`[${new Date().toISOString()}] üóëÔ∏è Quota deleted:`, data);
                    this.handleSSEQuotaDeleted(data);
                });

                this.eventSource.addEventListener('progress_update', (event) => {
                    const data = JSON.parse(event.data);
                    console.log(`[${new Date().toISOString()}] üìä Progress update:`, data);
                    this.handleSSEProgressUpdate(data);
                });

                this.eventSource.addEventListener('processing_completed', (event) => {
                    const data = JSON.parse(event.data);
                    console.log(`[${new Date().toISOString()}] üéâ Processing completed:`, data);
                    this.handleSSEProcessingCompleted(data);
                });

                this.eventSource.addEventListener('quota_error', (event) => {
                    const data = JSON.parse(event.data);
                    console.error(`[${new Date().toISOString()}] ‚ùå Quota error:`, data);
                    this.handleSSEQuotaError(data);
                });

                this.eventSource.onerror = (event) => {
                    console.error(`[${new Date().toISOString()}] ‚ùå SSE Error:`, event);
                    console.error(`[${new Date().toISOString()}] üìä EventSource state:`, {
                        readyState: this.eventSource.readyState,
                        url: this.eventSource.url,
                        withCredentials: this.eventSource.withCredentials
                    });
                };

                return true;
            } catch (error) {
                console.error('‚ùå Failed to start SSE connection:', error);
                return false;
            }
        }

        stopSSEConnection() {
            if (this.eventSource) {
                console.log('üîå Stopping SSE connection');
                this.eventSource.close();
                this.eventSource = null;
            }
            this.sseSessionId = null;
        }

        handleSSEQuotaCreated(data) {
            console.log(`[${new Date().toISOString()}] üéØ SSE Quota Created - Real-time update:`, data);
            console.log(`[${new Date().toISOString()}] üìä Current status detail entries count:`, this.statusDetailEntries.size);

            // Real-time update of individual quotas in the detail view
            if (this.statusDetailEntries.size > 0) {
                let foundEntry = false;

                // Find the corresponding detail entry and update it immediately
                for (const [segmentId, segment] of this.statusDetailEntries) {
                    console.log(`üîç Checking segment ${segmentId} with ${segment.entries.size} entries`);
                    console.log(`üìÖ Available dates in segment:`, Array.from(segment.entries.keys()));

                    if (segment.entries.has(data.date)) {
                        foundEntry = true;
                        const totalCapacity = Object.values(data.quantities || {}).reduce((sum, q) => sum + (q || 0), 0);
                        const quotaDetails = this.formatQuotaQuantities(data.quantities || {});
                        const message = `‚úÖ Quota erstellt: ${quotaDetails} (Gesamt: ${totalCapacity})`;

                        console.log(`‚úÖ Found matching entry for ${data.date}, updating with: ${message}`);

                        // Immediate visual update
                        this.updateStatusDetailEntry(segmentId, data.date, 'success', message);

                        console.log(`‚úÖ Updated quota detail for ${data.date}: ${message}`);
                        break;
                    }
                }

                if (!foundEntry) {
                    console.warn(`‚ö†Ô∏è No matching detail entry found for date ${data.date}`);
                }
            } else {
                console.warn('‚ö†Ô∏è No status detail entries found for SSE update');
            }

            // Also update progress if available
            if (data.result && data.result.current && data.result.total) {
                console.log('üìà Updating progress:', data.result);
                this.handleSSEProgressUpdate({
                    current: data.result.current,
                    total: data.result.total,
                    percentage: Math.round((data.result.current / data.result.total) * 100),
                    message: `Quota ${data.result.current}/${data.result.total} erstellt`
                });
            } else if (data.current && data.total) {
                console.log('üìà Updating progress (direct):', data);
                this.handleSSEProgressUpdate({
                    current: data.current,
                    total: data.total,
                    percentage: Math.round((data.current / data.total) * 100),
                    message: `Quota ${data.current}/${data.total} erstellt`
                });
            }
        }

        handleSSEQuotaDeleted(data) {
            console.log('üìù Quota deleted via SSE:', data);
            // Could add visual feedback for deletions if needed
        }

        handleSSEProgressUpdate(data) {
            if (this.statusProgressBar) {
                this.statusProgressBar.style.width = `${data.percentage}%`;
            }

            // Update current step with progress
            if (this.statusSteps.length > 0 && data.message) {
                this.setStatusStep(0, 'active', data.message);
            }
        }

        handleSSEQuotaError(data) {
            if (this.statusDetailEntries.size > 0) {
                for (const [segmentId, segment] of this.statusDetailEntries) {
                    if (segment.entries.has(data.date)) {
                        this.updateStatusDetailEntry(segmentId, data.date, 'error', data.error);
                        break;
                    }
                }
            }
        }

        handleSSEProcessingCompleted(data) {
            this.completeStatusWorkflow(true, data.summary.message);
            this.stopSSEConnection();
        }

        startStatusWorkflow(stepLabels = []) {
            if (!this.statusModalInstance) {
                return false;
            }

            const steps = stepLabels.length ? stepLabels : [
                'Sende Daten an HRS',
                'Quotas schreiben',
                'Import aktualisieren'
            ];

            this.resetStatusModal();

            this.statusSteps = steps.map(label => ({
                label,
                state: 'pending',
                element: null
            }));

            const fragment = document.createDocumentFragment();
            this.statusSteps.forEach((step, index) => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.dataset.index = index;

                const labelSpan = document.createElement('span');
                labelSpan.className = 'status-label';
                labelSpan.textContent = step.label;

                const badge = document.createElement('span');
                badge.className = 'badge bg-secondary rounded-pill status-pill';
                badge.textContent = 'Wartet';

                li.appendChild(labelSpan);
                li.appendChild(badge);
                fragment.appendChild(li);
                step.element = li;
            });

            if (this.statusStepsContainer) {
                this.statusStepsContainer.appendChild(fragment);
            }

            this.statusModalInstance.show();
            this.setStatusStep(0, 'active');
            return true;
        }

        updateStatusProgress() {
            if (!this.statusProgressBar || !this.statusSteps.length) return;
            const completed = this.statusSteps.filter(step => step.state === 'success').length;
            const total = this.statusSteps.length;
            const percent = Math.max(5, Math.round((completed / total) * 100));
            this.statusProgressBar.style.width = `${percent}%`;
        }

        setStatusStep(index, state, detail = '') {
            if (!this.statusSteps[index]) return;
            const step = this.statusSteps[index];
            step.state = state;

            const li = step.element;
            if (!li) return;

            const badge = li.querySelector('.status-pill');

            li.classList.remove('list-group-item-warning', 'list-group-item-success', 'list-group-item-danger', 'list-group-item-info');
            if (badge) {
                badge.classList.remove('bg-secondary', 'bg-info', 'bg-success', 'bg-danger');
            }

            switch (state) {
                case 'active':
                    li.classList.add('list-group-item-info');
                    if (badge) {
                        badge.classList.add('bg-info');
                        badge.textContent = 'Aktiv';
                    }
                    break;
                case 'success':
                    li.classList.add('list-group-item-success');
                    if (badge) {
                        badge.classList.add('bg-success');
                        badge.textContent = 'Fertig';
                    }
                    break;
                case 'error':
                    li.classList.add('list-group-item-danger');
                    if (badge) {
                        badge.classList.add('bg-danger');
                        badge.textContent = 'Fehler';
                    }
                    break;
                default:
                    if (badge) {
                        badge.classList.add('bg-secondary');
                        badge.textContent = 'Wartet';
                    }
                    break;
            }

            if (detail && li.querySelector('.status-detail')) {
                li.querySelector('.status-detail').textContent = detail;
            } else if (detail) {
                const detailSpan = document.createElement('div');
                detailSpan.className = 'status-detail small mt-1 text-muted';
                detailSpan.textContent = detail;
                li.appendChild(detailSpan);
            }

            if (state === 'error' && this.statusProgressBar) {
                this.statusProgressBar.classList.remove('bg-success');
                this.statusProgressBar.classList.add('bg-danger');
            }

            this.updateStatusProgress();
        }

        createStatusDetailSegment(label, dailyQuotas) {
            if (!this.statusDetailContainer || !this.statusDetailBody) {
                return null;
            }

            this.statusDetailContainer.classList.remove('d-none');

            const segmentId = `segment-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
            const wrapper = document.createElement('div');
            wrapper.className = 'quota-detail-segment';

            const header = document.createElement('div');
            header.className = 'd-flex justify-content-between align-items-center mb-1';
            const titleSpan = document.createElement('span');
            titleSpan.style.color = '#e5edff';
            titleSpan.style.fontWeight = '600';
            titleSpan.textContent = label;
            const badgeSpan = document.createElement('span');
            badgeSpan.className = 'badge bg-secondary';
            badgeSpan.textContent = `${dailyQuotas.length} ${dailyQuotas.length === 1 ? 'Tag' : 'Tage'}`;
            header.appendChild(titleSpan);
            header.appendChild(badgeSpan);
            wrapper.appendChild(header);

            const list = document.createElement('div');
            list.setAttribute('data-role', 'quota-detail-list');
            wrapper.appendChild(list);

            const entries = new Map();

            dailyQuotas.forEach((quota) => {
                const item = document.createElement('div');
                item.className = 'quota-detail-item state-pending';
                item.dataset.date = quota.date;
                item.dataset.state = 'pending';
                item.dataset.final = '0';

                const leftCol = document.createElement('div');
                const dateEl = document.createElement('div');
                dateEl.className = 'quota-detail-date';
                dateEl.textContent = this.formatDateForDisplay(quota.date);
                const messageEl = document.createElement('div');
                messageEl.className = 'quota-detail-message';
                messageEl.textContent = 'Wird vorbereitet‚Ä¶';
                leftCol.appendChild(dateEl);
                leftCol.appendChild(messageEl);

                const badge = document.createElement('span');
                badge.className = 'badge quota-detail-badge bg-secondary';
                badge.textContent = 'Wartet';

                item.appendChild(leftCol);
                item.appendChild(badge);
                list.appendChild(item);

                entries.set(quota.date, {
                    element: item,
                    badge,
                    messageEl,
                    state: 'pending'
                });
            });

            this.statusDetailBody.appendChild(wrapper);
            this.statusDetailEntries.set(segmentId, {
                wrapper,
                entries
            });

            if (dailyQuotas.length > 0) {
                this.updateStatusDetailEntry(segmentId, dailyQuotas[0].date, 'active', '√úbertragung l√§uft‚Ä¶');
                for (let i = 1; i < dailyQuotas.length; i++) {
                    this.updateStatusDetailEntry(segmentId, dailyQuotas[i].date, 'pending', 'Wartet auf √úbertragung‚Ä¶');
                }
            }

            return segmentId;
        }

        updateStatusDetailEntry(segmentId, date, state = 'pending', message = '') {
            const segment = this.statusDetailEntries.get(segmentId);
            if (!segment) return;
            const entry = segment.entries.get(date);
            if (!entry) return;

            const item = entry.element;
            const badge = entry.badge;
            const messageEl = entry.messageEl;

            const stateClasses = ['state-pending', 'state-active', 'state-success', 'state-warn', 'state-error'];
            stateClasses.forEach(cls => item.classList.remove(cls));

            const configMap = {
                pending: { badgeClass: 'bg-secondary', badgeText: 'Wartet', messageColor: '#94a3b8' },
                active: { badgeClass: 'bg-info', badgeText: 'L√§uft', messageColor: '#a5b4fc' },
                success: { badgeClass: 'bg-success', badgeText: 'Fertig', messageColor: '#4ade80' },
                warn: { badgeClass: 'bg-warning text-dark', badgeText: 'Hinweis', messageColor: '#facc15' },
                error: { badgeClass: 'bg-danger', badgeText: 'Fehler', messageColor: '#f87171' }
            };

            const config = configMap[state] || configMap.pending;
            item.classList.add(`state-${state}`);
            badge.className = 'badge quota-detail-badge';
            config.badgeClass.split(' ').forEach(cls => badge.classList.add(cls));
            badge.textContent = config.badgeText;

            if (message) {
                messageEl.textContent = message;
            }
            messageEl.style.color = config.messageColor;

            entry.state = state;
            entry.element.dataset.state = state;
            const isFinal = state === 'success' || state === 'warn' || state === 'error';
            entry.element.dataset.final = isFinal ? '1' : '0';

            // Auto-scroll to show the updated entry
            this.scrollToDetailEntry(entry.element);
        }

        scrollToDetailEntry(entryElement) {
            if (!entryElement) {
                console.log('[Auto-Scroll] ‚ùå No entry element provided');
                return;
            }

            // Find the scrollable container (the detail body)
            const container = entryElement.closest('[data-role="quota-status-detail-body"]');
            if (!container) {
                console.log('[Auto-Scroll] ‚ùå No scrollable container found');
                console.log('[Auto-Scroll] Entry element:', entryElement);
                console.log('[Auto-Scroll] Searching for: [data-role="quota-status-detail-body"]');
                return;
            }

            // Calculate positions
            const containerRect = container.getBoundingClientRect();
            const entryRect = entryElement.getBoundingClientRect();

            console.log('[Auto-Scroll] üìè Container rect:', {
                top: containerRect.top,
                bottom: containerRect.bottom,
                height: containerRect.height
            });

            console.log('[Auto-Scroll] üìè Entry rect:', {
                top: entryRect.top,
                bottom: entryRect.bottom,
                height: entryRect.height
            });

            // Check if entry is visible within container
            const isVisible = (
                entryRect.top >= containerRect.top &&
                entryRect.bottom <= containerRect.bottom
            );

            console.log('[Auto-Scroll] üëÅÔ∏è Is visible:', isVisible);

            // Only scroll if entry is not fully visible
            if (!isVisible) {
                const containerScrollTop = container.scrollTop;
                const entryOffsetTop = entryElement.offsetTop;
                const containerHeight = container.clientHeight;
                const entryHeight = entryElement.offsetHeight;

                // Calculate scroll position to center the entry
                const targetScrollTop = entryOffsetTop - (containerHeight / 2) + (entryHeight / 2);

                console.log('[Auto-Scroll] üéØ Scroll calculation:', {
                    containerScrollTop,
                    entryOffsetTop,
                    containerHeight,
                    entryHeight,
                    targetScrollTop: Math.max(0, targetScrollTop)
                });

                // Smooth scroll to the entry
                container.scrollTo({
                    top: Math.max(0, targetScrollTop),
                    behavior: 'smooth'
                });

                console.log('[Auto-Scroll] ‚úÖ Scrolling to entry');
            } else {
                console.log('[Auto-Scroll] ‚ÑπÔ∏è Entry already visible, no scroll needed');
            }
        }

        formatDateForDisplay(dateStr) {
            if (!dateStr || typeof dateStr !== 'string') return dateStr || '';
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                const [year, month, day] = dateStr.split('-');
                return `${day}.${month}.${year}`;
            }
            return dateStr;
        }

        formatQuotaQuantities(quantities) {
            if (!quantities || typeof quantities !== 'object') {
                return '-';
            }

            const mapping = [
                ['lager', 'L'],
                ['betten', 'B'],
                ['dz', 'DZ'],
                ['sonder', 'S']
            ];

            const parts = [];
            mapping.forEach(([key, label]) => {
                const value = Number.isFinite(Number(quantities[key])) ? Number(quantities[key]) : 0;
                parts.push(`${label} ${value}`);
            });

            return parts.join(' ¬∑ ');
        }

        applySegmentResultToDetails(segmentId, dailyQuotas, result) {
            if (!segmentId || !this.statusDetailEntries.has(segmentId)) {
                return;
            }

            const createdMap = new Map();
            if (result && Array.isArray(result.createdQuotas)) {
                result.createdQuotas.forEach(entry => {
                    if (entry && typeof entry === 'object') {
                        const dateKey = entry.date || entry.day || null;
                        if (!dateKey) return;
                        const quantities = entry.quantities || {
                            lager: entry.lager ?? entry.quota_lager ?? 0,
                            betten: entry.betten ?? entry.quota_betten ?? 0,
                            dz: entry.dz ?? entry.quota_dz ?? 0,
                            sonder: entry.sonder ?? entry.quota_sonder ?? 0
                        };
                        createdMap.set(dateKey, quantities);
                    }
                });
            }

            const warnDates = new Set();
            if (result && Array.isArray(result.adjustedClosedQuotas)) {
                result.adjustedClosedQuotas.forEach(entry => {
                    if (!entry) return;
                    if (Array.isArray(entry.affectedDays)) {
                        entry.affectedDays.forEach(day => warnDates.add(day));
                    } else if (Array.isArray(entry.days)) {
                        entry.days.forEach(day => warnDates.add(day));
                    } else if (entry.date) {
                        warnDates.add(entry.date);
                    }
                });
            }

            if (result && Array.isArray(result.blockedDates)) {
                result.blockedDates.forEach(entry => {
                    if (!entry) return;
                    if (Array.isArray(entry.affectedDays)) {
                        entry.affectedDays.forEach(day => warnDates.add(day));
                    } else if (entry.date) {
                        warnDates.add(entry.date);
                    } else if (entry.selectedDate) {
                        warnDates.add(entry.selectedDate);
                    }
                });
            }

            dailyQuotas.forEach((quota, index) => {
                const dateKey = quota.date;

                // Zuerst zeigen wir "wird bearbeitet" f√ºr jede Quota
                const processDelay = Math.min(100, 25 * index);
                setTimeout(() => {
                    this.updateStatusDetailEntry(segmentId, dateKey, 'active', 'Quota wird angelegt...');
                }, processDelay);

                // Dann zeigen wir das Ergebnis f√ºr jede einzelne Quota
                const baseQuantities = createdMap.get(dateKey) || {
                    lager: quota.quota_lager,
                    betten: quota.quota_betten,
                    dz: quota.quota_dz,
                    sonder: quota.quota_sonder
                };

                const messageParts = [];

                // Detaillierte Quota-Info mit Kategorien
                const quotaDetails = this.formatQuotaQuantities(baseQuantities);
                messageParts.push(`‚úì Erstellt: ${quotaDetails}`);

                if (Number.isFinite(Number(quota.targetCapacity))) {
                    const actualTotal = (baseQuantities.lager || 0) + (baseQuantities.betten || 0) +
                        (baseQuantities.dz || 0) + (baseQuantities.sonder || 0);
                    messageParts.push(`Gesamt ${actualTotal}/${Number(quota.targetCapacity)}`);
                }

                const isWarn = warnDates.has(dateKey);
                if (isWarn) {
                    messageParts.push('‚ö†Ô∏è Sperre beachtet');
                }

                const state = isWarn ? 'warn' : 'success';
                const resultDelay = Math.min(300, 50 * index) + 200; // Etwas sp√§ter als "wird bearbeitet"
                setTimeout(() => {
                    this.updateStatusDetailEntry(segmentId, dateKey, state, messageParts.join(' ¬∑ '));
                }, resultDelay);
            });
        }

        markStatusDetailSegmentError(segmentId, dailyQuotas, message) {
            if (!segmentId || !this.statusDetailEntries.has(segmentId)) {
                return;
            }
            let errorText = (message || 'Fehler beim Schreiben').toString();
            if (errorText.length > 160) {
                errorText = `${errorText.slice(0, 157)}‚Ä¶`;
            }
            dailyQuotas.forEach((quota, index) => {
                const delay = Math.min(200, 40 * index);
                setTimeout(() => {
                    this.updateStatusDetailEntry(segmentId, quota.date, 'error', errorText);
                }, delay);
            });
        }

        completeStatusWorkflow(success, summaryText, autoClose = true) {
            if (!this.statusModalInstance) return;

            if (this.statusProgressBar) {
                this.statusProgressBar.style.width = '100%';
                this.statusProgressBar.classList.remove('bg-danger');
                this.statusProgressBar.classList.add(success ? 'bg-success' : 'bg-warning');
            }

            if (this.statusSummary) {
                this.statusSummary.textContent = summaryText || '';
                this.statusSummary.classList.remove('d-none', 'alert-warning', 'alert-danger', 'alert-success');
                this.statusSummary.classList.add(success ? 'alert-success' : 'alert-warning');
            }

            if (this.statusCloseBtn) {
                this.statusCloseBtn.disabled = false;
            }

            if (autoClose && success) {
                setTimeout(() => {
                    try {
                        this.statusModalInstance.hide();
                    } catch (err) {
                        console.warn('Status modal hide failed:', err);
                    }
                }, 1200);
            }
        }

        failStatusWorkflow(errorMessage) {
            if (!this.statusModalInstance) return;
            let targetIndex = this.statusSteps.findIndex(step => step.state === 'active');
            if (targetIndex === -1) {
                targetIndex = this.statusSteps.length ? this.statusSteps.length - 1 : 0;
            }
            this.setStatusStep(targetIndex, 'error', errorMessage);

            if (this.statusProgressBar) {
                this.statusProgressBar.classList.remove('bg-success');
                this.statusProgressBar.classList.add('bg-danger');
            }

            if (this.statusSummary) {
                this.statusSummary.textContent = errorMessage;
                this.statusSummary.classList.remove('d-none', 'alert-success', 'alert-warning');
                this.statusSummary.classList.add('alert-danger');
            }

            if (this.statusCloseBtn) {
                this.statusCloseBtn.disabled = false;
            }
        }

        initializeEventListeners() {
            // Slider <-> Input Sync
            const slider = document.getElementById('targetCapacity');
            const input = document.getElementById('targetCapacityValue');

            slider.addEventListener('input', () => {
                this.lastTargetCapacityFineAdjust = false;
                input.value = slider.value;
                this.updatePreview();
            });

            input.addEventListener('input', () => {
                this.lastTargetCapacityFineAdjust = false;

                if (input.value === '') {
                    return;
                }

                let numericValue = parseInt(input.value, 10);
                if (isNaN(numericValue)) {
                    return;
                }

                const min = parseInt(slider.min, 10) || 0;
                const max = parseInt(slider.max, 10) || 0;
                numericValue = Math.max(min, Math.min(max, numericValue));

                slider.value = numericValue;
                if (numericValue !== parseInt(input.value, 10)) {
                    input.value = numericValue;
                }
                this.updatePreview();
            });

            input.addEventListener('change', () => {
                let numericValue = parseInt(input.value, 10);
                const min = parseInt(slider.min, 10) || 0;
                const max = parseInt(slider.max, 10) || 0;

                if (isNaN(numericValue)) {
                    numericValue = min;
                }

                numericValue = Math.max(min, Math.min(max, numericValue));

                if (!this.lastTargetCapacityFineAdjust && numericValue % 5 !== 0) {
                    numericValue = Math.round(numericValue / 5) * 5;
                }

                numericValue = Math.max(min, Math.min(max, numericValue));

                slider.value = numericValue;
                input.value = numericValue;
                this.lastTargetCapacityFineAdjust = false;
                this.updatePreview();
            });

            const handleTargetCapacityKey = (event) => {
                const increaseKeys = ['ArrowUp', 'ArrowRight'];
                const decreaseKeys = ['ArrowDown', 'ArrowLeft'];
                if (!increaseKeys.includes(event.key) && !decreaseKeys.includes(event.key)) {
                    return;
                }

                if (event.ctrlKey) {
                    event.preventDefault();
                    const delta = increaseKeys.includes(event.key) ? 1 : -1;
                    this.adjustTargetCapacity(delta, true);
                }
            };

            slider.addEventListener('keydown', handleTargetCapacityKey);
            input.addEventListener('keydown', handleTargetCapacityKey);

            // Event-Delegation f√ºr Priorit√§ten (funktioniert auch nach DOM-Updates)
            document.getElementById('quotaForm').addEventListener('change', (e) => {
                if (e.target.classList.contains('category-select') ||
                    e.target.classList.contains('max-value-input')) {
                    console.log('üîÑ Priorit√§t ge√§ndert (change):', e.target.className, e.target.value);
                    this.updatePreview();
                }
            });

            document.getElementById('quotaForm').addEventListener('input', (e) => {
                if (e.target.classList.contains('max-value-input')) {
                    console.log('üîÑ Priorit√§t Input:', e.target.className, e.target.value);
                    this.updatePreview();
                }
            });

            // Save Button
            document.getElementById('saveQuotaBtn').addEventListener('click', () => this.save());
        }

        adjustTargetCapacity(delta, fineAdjust = false) {
            const slider = document.getElementById('targetCapacity');
            const input = document.getElementById('targetCapacityValue');
            if (!slider || !input) {
                return;
            }

            const min = parseInt(slider.min, 10) || 0;
            const max = parseInt(slider.max, 10) || 0;
            let current = parseInt(slider.value, 10);
            if (isNaN(current)) {
                current = min;
            }

            let nextValue;
            if (fineAdjust) {
                nextValue = current + delta;
            } else {
                const baseStep = 5;
                const direction = delta === 0 ? 0 : (delta > 0 ? 1 : -1);
                if (direction > 0) {
                    nextValue = Math.floor(current / baseStep) * baseStep + baseStep;
                } else if (direction < 0) {
                    nextValue = Math.ceil(current / baseStep) * baseStep - baseStep;
                } else {
                    nextValue = Math.round(current / baseStep) * baseStep;
                }
            }

            nextValue = Math.max(min, Math.min(max, nextValue));

            if (nextValue === current) {
                this.lastTargetCapacityFineAdjust = fineAdjust;
                return;
            }

            slider.value = nextValue;
            input.value = nextValue;
            this.lastTargetCapacityFineAdjust = fineAdjust;
            this.updatePreview();
        }

        /**
         * √ñffne Modal f√ºr selektierte Tage
         */
        show(selectedDays) {
            console.log('üéØ Modal.show() aufgerufen mit selectedDays:', selectedDays);
            this.selectedDays = this.sanitizeSelectedDays(selectedDays);
            this.lastTargetCapacityFineAdjust = false;

            if (!this.selectedDays.length) {
                console.warn('‚ö†Ô∏è Keine bearbeitbaren Tage nach Sanitizing vorhanden (alle geschlossen oder ung√ºltig).');
                alert('‚ö†Ô∏è Die Auswahl enth√§lt nur geschlossene Tage. Bitte w√§hlen Sie andere Tage aus.');
                return;
            }

            this.currentSegments = this.getContiguousSegmentsFromDays(this.selectedDays);
            console.log('üß≠ Erkannte Segmente:', this.currentSegments);

            // Datum-Bereich anzeigen (YYYY-MM-DD Strings zu lokalen Dates)
            const parseDateString = (dateStr) => {
                console.log('   üìÖ Parse:', dateStr);
                const [year, month, day] = dateStr.split('-').map(Number);
                const parsed = new Date(year, month - 1, day);
                console.log('   ‚Üí Parsed Date:', parsed, 'Display:', parsed.toLocaleDateString('de-DE'));
                return parsed;
            };

            const dates = this.selectedDays.map(parseDateString);
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            console.log('üìÜ Min:', minDate.toLocaleDateString('de-DE'), 'Max:', maxDate.toLocaleDateString('de-DE'));

            const dateRange = this.selectedDays.length === 1
                ? minDate.toLocaleDateString('de-DE')
                : `${minDate.toLocaleDateString('de-DE')} - ${maxDate.toLocaleDateString('de-DE')}`;

            console.log('üìã Final dateRange:', dateRange);
            document.getElementById('quotaDateRange').textContent = dateRange + ` (${this.selectedDays.length} Tage)`;

            // Hole aktuellen Histogram-Target-Wert vom Renderer
            if (this.renderer && this.renderer.histogramTargetValue) {
                const histogramTarget = this.renderer.histogramTargetValue;
                console.log('üéØ √úbernehme Histogram Target:', histogramTarget);
                document.getElementById('targetCapacity').value = histogramTarget;
                document.getElementById('targetCapacityValue').value = histogramTarget;
                this.lastTargetCapacityFineAdjust = histogramTarget % 5 !== 0;
            }

            // Aktuelle Belegung laden (TODO: Von API holen)
            this.currentOccupancy = 0; // Placeholder
            document.getElementById('currentOccupancy').textContent = this.currentOccupancy;

            // Preview aktualisieren
            this.updatePreview();

            // Modal anzeigen
            this.modal.show();
        }

        sanitizeSelectedDays(days) {
            if (!Array.isArray(days)) return [];

            const uniqueSorted = Array.from(new Set(days.filter(Boolean))).sort();
            const valid = [];
            const skipped = [];

            uniqueSorted.forEach(dateStr => {
                if (this.isDayClosed(dateStr)) {
                    skipped.push(dateStr);
                    return;
                }
                valid.push(dateStr);
            });

            if (skipped.length) {
                console.warn('‚õî Geschlossene Tage aus Auswahl entfernt:', skipped);
            }

            return valid;
        }

        isDayClosed(dateStr) {
            if (!this.renderer || !dateStr) return false;

            try {
                const { startDate, endDate } = this.renderer.getTimelineDateRange();
                const histogramData = this.renderer.getHistogramData(startDate, endDate);
                if (!histogramData || !Array.isArray(histogramData.dailyDetails)) return false;

                const date = new Date(dateStr);
                if (Number.isNaN(date.getTime())) return false;

                const MS_IN_DAY = 24 * 60 * 60 * 1000;
                const normalizedDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0, 0);
                const normalizedStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 12, 0, 0, 0);
                const dayIndex = Math.floor((normalizedDate - normalizedStart) / MS_IN_DAY);

                const detail = histogramData.dailyDetails[dayIndex];
                if (!detail) return false;
                const status = typeof detail.hut_status === 'string'
                    ? detail.hut_status.trim().toUpperCase()
                    : 'SERVICED';

                return status && status !== 'SERVICED' && status !== 'OPEN';
            } catch (error) {
                console.warn('‚ö†Ô∏è isDayClosed Fehler f√ºr', dateStr, error);
                return false;
            }
        }

        getContiguousSegmentsFromDays(days) {
            if (!Array.isArray(days) || days.length === 0) return [];

            const sortedDays = Array.from(new Set(days)).sort();
            const MS_IN_DAY = 24 * 60 * 60 * 1000;
            const parseToUTC = (dateStr) => {
                const [year, month, day] = dateStr.split('-').map(Number);
                return Date.UTC(year, month - 1, day);
            };

            const segments = [];
            let currentSegment = [];
            let lastValue = null;

            for (const dateStr of sortedDays) {
                const currentValue = parseToUTC(dateStr);
                if (!currentSegment.length) {
                    currentSegment.push(dateStr);
                } else if (currentValue === lastValue + MS_IN_DAY) {
                    currentSegment.push(dateStr);
                } else {
                    segments.push({
                        dates: [...currentSegment],
                        dateFrom: currentSegment[0],
                        dateTo: currentSegment[currentSegment.length - 1],
                        dayCount: currentSegment.length
                    });
                    currentSegment = [dateStr];
                }
                lastValue = currentValue;
            }

            if (currentSegment.length) {
                segments.push({
                    dates: [...currentSegment],
                    dateFrom: currentSegment[0],
                    dateTo: currentSegment[currentSegment.length - 1],
                    dayCount: currentSegment.length
                });
            }

            return segments;
        }

        async triggerAutomaticHRSImportAfterDeploy(segments = null) {
            const segmentsToProcess = Array.isArray(segments) && segments.length
                ? segments
                : this.getContiguousSegmentsFromDays(this.selectedDays).map(segment => ({
                    dateFrom: segment.dateFrom,
                    dateTo: segment.dateTo,
                    dayCount: segment.dayCount
                }));

            if (!segmentsToProcess.length) {
                console.log('‚è≠Ô∏è Automatischer HRS Import ausgelassen ‚Äì keine verarbeitbaren Segmente.');
                return false;
            }

            if (typeof window.enqueueHRSImport === 'function') {
                for (const segment of segmentsToProcess) {
                    console.log('üöÄ Automatischer HRS Import Segment:', segment);
                    try {
                        await window.enqueueHRSImport(segment);
                    } catch (error) {
                        console.error('‚ùå Fehler beim HRS Import Segment:', segment, error);
                        return false;
                    }
                }
                return true;
            }

            console.warn('‚ö†Ô∏è enqueueHRSImport nicht verf√ºgbar ‚Äì fallback via Events (ohne Garantien).');
            segmentsToProcess.forEach((segment, index) => {
                setTimeout(() => {
                    try {
                        const event = new CustomEvent('hrs-import-requested', { detail: segment });
                        window.dispatchEvent(event);
                    } catch (error) {
                        console.error('‚ùå Fallback-Dispatch fehlgeschlagen:', error);
                    }
                }, index * 600);
            });
            return false;
        }

        /**
         * Selektiver HRS Import f√ºr Quota-Daten + AV Capacity (verwendet EventSource wie der manuelle Import)
         * 
         * Importiert:
         * 1. HRS Quotas (hrs_imp_quota_stream.php)
         * 2. AV Capacity (get_av_cap_range_stream.php)
         * 
         * @param {Array} segments - Zu importierende Segmente
         * @returns {boolean} Erfolg des Imports
         */
        async triggerSelectiveQuotaImport(segments = null) {
            const segmentsToProcess = Array.isArray(segments) && segments.length
                ? segments
                : this.getContiguousSegmentsFromDays(this.selectedDays).map(segment => ({
                    dateFrom: segment.dateFrom,
                    dateTo: segment.dateTo,
                    dayCount: segment.dayCount
                }));

            if (!segmentsToProcess.length) {
                console.log('‚è≠Ô∏è Selektiver Quota-Import ausgelassen ‚Äì keine verarbeitbaren Segmente.');
                return false;
            }

            try {
                console.log('üéØ Starte EventSource-basierten Quota+AV Import f√ºr Segmente:', segmentsToProcess);

                for (const segment of segmentsToProcess) {
                    console.log(`üîÑ Importiere Quota+AV-Daten f√ºr ${segment.dateFrom} bis ${segment.dateTo}...`);

                    // EventSource-basierter Import (wie im manuellen HRS-Import)
                    await new Promise((resolve, reject) => {
                        const hrsPath = (typeof WCIConfig !== 'undefined' && WCIConfig.get)
                            ? WCIConfig.get('paths.hrs', '/wci/hrs')
                            : '/wci/hrs';

                        const cacheBuster = Date.now();
                        const eventSource = new EventSource(`${hrsPath}/hrs_imp_quota_stream.php?from=${segment.dateFrom}&to=${segment.dateTo}&cb=${cacheBuster}`);

                        let hasCompleted = false;
                        let hasError = false;

                        eventSource.onmessage = function (event) {
                            try {
                                const data = JSON.parse(event.data);
                                console.log(`üìä Quota-Import Update:`, data);

                                switch (data.type) {
                                    case 'start':
                                        console.log(`üì° Start Quota-Import: ${data.message}`);
                                        break;
                                    case 'progress':
                                        console.log(`‚è≥ Quota-Import Progress: ${data.message}`);
                                        break;
                                    case 'complete':
                                        console.log(`‚úÖ Quota-Import Complete: ${data.message}`);
                                        hasCompleted = true;
                                        eventSource.close();
                                        // Kurze Verz√∂gerung f√ºr DB-Commit
                                        setTimeout(() => resolve(true), 500);
                                        break;
                                    case 'error':
                                        console.error(`‚ùå Quota-Import Error: ${data.message}`);
                                        hasError = true;
                                        eventSource.close();
                                        reject(new Error(data.message || 'Quota-Import fehlgeschlagen'));
                                        break;
                                }
                            } catch (parseError) {
                                console.error('‚ùå EventSource Parse Error:', parseError);
                            }
                        };

                        eventSource.onerror = function (event) {
                            console.error('‚ùå EventSource Error:', event);
                            if (!hasCompleted && !hasError) {
                                eventSource.close();
                                reject(new Error('EventSource-Verbindung fehlgeschlagen'));
                            }
                        };

                        // Timeout nach 2 Minuten
                        setTimeout(() => {
                            if (!hasCompleted && !hasError) {
                                eventSource.close();
                                reject(new Error('Quota-Import Timeout nach 2 Minuten'));
                            }
                        }, 120000);
                    });

                    console.log(`‚úÖ Quota-Import erfolgreich f√ºr ${segment.dateFrom} bis ${segment.dateTo}`);

                    // **NEU: AV Capacity Import f√ºr das gleiche Segment**
                    console.log(`üîÑ Starte AV Capacity Import f√ºr ${segment.dateFrom} bis ${segment.dateTo}...`);

                    await new Promise((resolve, reject) => {
                        const apiPath = (typeof WCIConfig !== 'undefined' && WCIConfig.get)
                            ? WCIConfig.get('paths.api', '/wci/api')
                            : '/wci/api';

                        const hutId = (typeof WCIConfig !== 'undefined' && WCIConfig.get)
                            ? WCIConfig.get('hut.id', 675)
                            : 675;

                        const cacheBuster = Date.now();
                        const eventSource = new EventSource(`${apiPath}/imps/get_av_cap_range_stream.php?hutID=${hutId}&von=${segment.dateFrom}&bis=${segment.dateTo}&cb=${cacheBuster}`);

                        let hasCompleted = false;
                        let hasError = false;

                        eventSource.onmessage = function (event) {
                            try {
                                const data = JSON.parse(event.data);
                                console.log(`üìä AV Capacity-Import Update:`, data);

                                switch (data.type) {
                                    case 'start':
                                        console.log(`üì° Start AV Capacity-Import: ${data.message}`);
                                        break;
                                    case 'progress':
                                        console.log(`‚è≥ AV Capacity-Import Progress: ${data.message}`);
                                        break;
                                    case 'complete':
                                        console.log(`‚úÖ AV Capacity-Import Complete: ${data.message}`);
                                        hasCompleted = true;
                                        eventSource.close();
                                        setTimeout(() => resolve(true), 200);
                                        break;
                                    case 'finish':
                                        console.log(`üéâ AV Capacity-Import Finished: ${data.message}`);
                                        hasCompleted = true;
                                        eventSource.close();
                                        setTimeout(() => resolve(true), 200);
                                        break;
                                    case 'error':
                                        console.error(`‚ùå AV Capacity-Import Error: ${data.message}`);
                                        hasError = true;
                                        eventSource.close();
                                        reject(new Error(data.message || 'AV Capacity-Import fehlgeschlagen'));
                                        break;
                                }
                            } catch (parseError) {
                                console.error('‚ùå AV Capacity EventSource Parse Error:', parseError);
                            }
                        };

                        eventSource.onerror = function (event) {
                            console.error('‚ùå AV Capacity EventSource Error:', event);
                            if (!hasCompleted && !hasError) {
                                eventSource.close();
                                reject(new Error('AV Capacity EventSource-Verbindung fehlgeschlagen'));
                            }
                        };

                        // Timeout nach 2 Minuten
                        setTimeout(() => {
                            if (!hasCompleted && !hasError) {
                                eventSource.close();
                                reject(new Error('AV Capacity-Import Timeout nach 2 Minuten'));
                            }
                        }, 120000);
                    });

                    console.log(`‚úÖ AV Capacity-Import erfolgreich f√ºr ${segment.dateFrom} bis ${segment.dateTo}`);
                }

                console.log('‚úÖ Selektiver Quota-Import (mit AV Capacity) abgeschlossen');
                return true;

            } catch (error) {
                console.error('‚ùå Fehler beim EventSource Quota-Import:', error);
                return false;
            }
        }

        /**
         * Helper-Funktion: Liest Max-Wert aus Input-Feld
         * @returns {number} Infinity wenn leer, sonst geparster Wert (auch 0!)
         */
        getMaxValue(elementId) {
            const input = document.getElementById(elementId);
            if (!input || !input.value || input.value === '') return Infinity;
            const val = parseInt(input.value);
            return isNaN(val) ? Infinity : val;
        }


        /**
         * Berechnet Quota-Verteilung nach Priorit√§ten
         * 
         * STRATEGIE:
         * 1. Sammle alle Eingangsvariablen √ºbersichtlich
         * 2. Berechne zu erstellende Quotas pro Kategorie
         * 
         * @param {number} targetCapacity - Ziel-Gesamtkapazit√§t
         * @param {object} occupancy - { av, internal, total }
         * @param {string} dateStr - Datum (YYYY-MM-DD) f√ºr Detail-Analysen
         */
        async calculateQuotaDistribution(targetCapacity, occupancy, dateStr = null) {
            console.log(`\n${'='.repeat(80)}`);
            console.log(`üßÆ QUOTA-BERECHNUNG${dateStr ? ' f√ºr ' + dateStr : ''}`);
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 1: EINGANGSVARIABLEN VORBEREITEN
            // ========================================================================

            // 1.1 Belegung von AV-Reservierungen (av_id > 0, storno = false)
            const avOccupancy = await this.getBookedCategoriesForDate(dateStr, true); // nur AV
            console.log('üì• AV-Belegung (av_id > 0):');
            console.log(`   Sonder: ${avOccupancy.sonder}`);
            console.log(`   Lager:  ${avOccupancy.lager}`);
            console.log(`   Betten: ${avOccupancy.betten}`);
            console.log(`   DZ:     ${avOccupancy.dz}`);
            console.log(`   TOTAL:  ${avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz}\n`);

            // 1.2 Belegung von internen Reservierungen (av_id = 0, storno = false)
            const internalOccupancy = await this.getBookedCategoriesForDate(dateStr, false); // nur Intern
            console.log('üì• Interne Belegung (av_id = 0):');
            console.log(`   Sonder: ${internalOccupancy.sonder}`);
            console.log(`   Lager:  ${internalOccupancy.lager}`);
            console.log(`   Betten: ${internalOccupancy.betten}`);
            console.log(`   DZ:     ${internalOccupancy.dz}`);
            console.log(`   TOTAL:  ${internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz}\n`);

            // 1.3 Aktuelle Quota des Tages (falls vorhanden)
            const currentQuota = await this.getCurrentQuotaForDate(dateStr);
            console.log('üìä Aktuelle Quota des Tages:');
            console.log(`   Free Places: ${currentQuota.freePlaces || 0}`);
            console.log(`   Sonder:      ${currentQuota.sonder}`);
            console.log(`   Lager:       ${currentQuota.lager}`);
            console.log(`   Betten:      ${currentQuota.betten}`);
            console.log(`   DZ:          ${currentQuota.dz}`);
            console.log(`   TOTAL:       ${currentQuota.sonder + currentQuota.lager + currentQuota.betten + currentQuota.dz}\n`);

            // 1.4 HRS Daily Summary Daten werden NICHT mehr geladen (zu viele API-Calls)
            // Die Berechnung basiert nur auf AV + Intern Belegung

            // 1.5 Zielauslastung gesamt
            console.log('üéØ Zielauslastung gesamt: ' + targetCapacity + ' Betten\n');

            // 1.6 Max-Werte f√ºr Kategorien auslesen (fixe Reihenfolge, keine Priorit√§ten!)
            const maxMBZ = this.getMaxValue('max-mbz');
            const max2BZ = this.getMaxValue('max-2bz');
            const maxSK = this.getMaxValue('max-sk');

            console.log('üìã Max-Werte f√ºr Kategorien:');
            console.log(`   MBZ (Betten): ${maxMBZ === Infinity ? '‚àû' : maxMBZ}`);
            console.log(`   2BZ (DZ):     ${max2BZ === Infinity ? '‚àû' : max2BZ}`);
            console.log(`   SK (Sonder):  ${maxSK === Infinity ? '‚àû' : maxSK}`);
            console.log(`   ML (Lager):   REST\n`);

            console.log(`\n${'='.repeat(80)}`);
            console.log('üìê BERECHNUNGSVORBEREITUNG ABGESCHLOSSEN');
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 2: QUOTA-BERECHNUNG - VEREINFACHTE LOGIK
            // ========================================================================

            console.log('üí° QUOTA-FORMEL:\n');

            // 2.1 Berechne Gesamtg√§ste im Haus (AV + Intern)
            const totalGuestsInHouse =
                avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz +
                internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz;

            console.log(`üë• Gesamtg√§ste im Haus: ${totalGuestsInHouse}`);
            console.log(`   (AV: ${avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz} + Intern: ${internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz})\n`);

            // 2.2 Erforderliche Gesamtquota (Qerf)
            // Formel: Qerf = Zielauslastung - Anzahl ALLER G√§ste im Haus
            let Qerf = targetCapacity - totalGuestsInHouse;
            if (Qerf < 0) Qerf = 0;

            console.log(`üìä Erforderliche Gesamtquota (Qerf):`);
            console.log(`   Qerf = ${targetCapacity} (Zielauslastung) - ${totalGuestsInHouse} (G√§ste) = ${Qerf}\n`);

            // 2.3 Quota-Verteilung (EINFACH)
            const result = { lager: 0, betten: 0, dz: 0, sonder: 0 };

            console.log('üéØ Quota-Verteilung:\n');

            // Verteile zuerst MBZ, 2BZ, SK mit ihren Max-Werten
            result.betten = Math.min(maxMBZ, Qerf);
            result.dz = Math.min(max2BZ, Qerf);
            result.sonder = Math.min(maxSK, Qerf);

            console.log(`   MBZ (Betten): ${result.betten} (max ${maxMBZ === Infinity ? '‚àû' : maxMBZ})`);
            console.log(`   2BZ (DZ):     ${result.dz} (max ${max2BZ === Infinity ? '‚àû' : max2BZ})`);
            console.log(`   SK (Sonder):  ${result.sonder} (max ${maxSK === Infinity ? '‚àû' : maxSK})`);

            // ML bekommt den REST
            const usedByOthers = result.betten + result.dz + result.sonder;
            result.lager = Math.max(0, Qerf - usedByOthers);

            console.log(`   ML (Lager):   ${result.lager} (REST: ${Qerf} - ${usedByOthers} = ${result.lager})`);

            const totalQuota = result.sonder + result.lager + result.betten + result.dz;
            console.log(`   TOTAL:        ${totalQuota} (sollte ${Qerf} sein)`);
            console.log(`${'='.repeat(80)}\n`);

            return result;
        }

        /**
         * Aktualisiert Live-Preview - berechnet f√ºr JEDEN TAG individuell
         */
        async updatePreview() {
            console.log('üîÑ updatePreview() START');
            const targetCapacity = parseInt(document.getElementById('targetCapacity').value);
            const previewContainer = document.getElementById('quotaPreviewDays');
            console.log('üì¶ previewContainer:', previewContainer);
            console.log('üéØ targetCapacity:', targetCapacity);
            console.log('üìÖ selectedDays:', this.selectedDays);

            let hasOverbooking = false;
            const tableData = [];

            const skippedClosedDays = [];

            // Sammle Daten f√ºr alle Tage
            console.log('üîÑ Starte Datensammlung f√ºr', this.selectedDays.length, 'Tage...');
            for (const dateStr of this.selectedDays) {
                if (this.isDayClosed(dateStr)) {
                    console.log(`‚õî ${dateStr} ist geschlossen ‚Äì wird √ºbersprungen.`);
                    skippedClosedDays.push(dateStr);
                    continue;
                }
                console.log('  üìÖ Verarbeite Tag:', dateStr);
                // Berechne Quota-Verteilung (diese Funktion holt sich intern die Belegungen)
                const quotas = await this.calculateQuotaDistribution(targetCapacity, null, dateStr);
                console.log('  ‚úÖ Quotas berechnet:', quotas);

                // Hole Belegungsdaten f√ºr die Anzeige
                const occupancy = await this.getOccupancyForDate(dateStr);

                // Parse Datum
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dateDisplay = date.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit', month: '2-digit', year: 'numeric' });

                // Berechne Gesamtg√§ste
                const totalGuests = occupancy.av + occupancy.internal;
                const availableQuota = Math.max(0, targetCapacity - totalGuests);

                if (availableQuota <= 0) {
                    hasOverbooking = true;
                }

                tableData.push({
                    date: dateDisplay,
                    av: occupancy.av,
                    internal: occupancy.internal,
                    total: totalGuests,
                    quota: availableQuota,
                    ml: quotas.lager,
                    mbz: quotas.betten,
                    bz2: quotas.dz,
                    sk: quotas.sonder,
                    totalQuota: quotas.lager + quotas.betten + quotas.dz + quotas.sonder,
                    isOverbooked: availableQuota <= 0
                });
            }

            const warning = document.getElementById('overbookingWarning');

            if (tableData.length === 0) {
                previewContainer.innerHTML = `
                    <div class="alert alert-info py-2 px-3 mb-0" role="alert">
                        Keine bearbeitbaren Tage in der Auswahl (alle geschlossen oder ausgefiltert).
                    </div>
                `;
                warning.classList.add('d-none');
                return;
            }

            // Erstelle Excel-Style Tabelle
            let html = `
                <div style="overflow-x: auto;">
                    <table class="table table-sm table-bordered table-hover" style="font-size: 0.85em; margin: 0;">
                        <thead class="table-dark" style="position: sticky; top: 0; z-index: 10;">
                            <tr>
                                <th style="min-width: 130px;">Datum</th>
                                <th class="text-center" style="min-width: 50px;" title="AV-Reservierungen">AV</th>
                                <th class="text-center" style="min-width: 50px;" title="Interne Reservierungen">Int</th>
                                <th class="text-center" style="min-width: 60px;" title="Gesamt G√§ste">Total</th>
                                <th class="text-center" style="min-width: 60px; background-color: #2d5a3f;" title="Erforderliche Gesamtquota">Qerf</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">ML</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">MBZ</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">2BZ</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">SK</th>
                                <th class="text-center" style="min-width: 60px; background-color: #2d5a3f;" title="Summe Quotas">Œ£</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            for (const row of tableData) {
                const rowClass = row.isOverbooked ? 'table-danger' : '';
                const quotaClass = row.quota > 0 ? 'text-success fw-bold' : 'text-danger';

                html += `
                    <tr class="${rowClass}">
                        <td><strong>${row.date}</strong></td>
                        <td class="text-center">${row.av}</td>
                        <td class="text-center">${row.internal}</td>
                        <td class="text-center"><strong>${row.total}</strong></td>
                        <td class="text-center ${quotaClass}"><strong>${row.quota}</strong></td>
                        <td class="text-center ${row.ml > 0 ? 'bg-success bg-opacity-25' : ''}">${row.ml}</td>
                        <td class="text-center ${row.mbz > 0 ? 'bg-success bg-opacity-25' : ''}">${row.mbz}</td>
                        <td class="text-center ${row.bz2 > 0 ? 'bg-success bg-opacity-25' : ''}">${row.bz2}</td>
                        <td class="text-center ${row.sk > 0 ? 'bg-success bg-opacity-25' : ''}">${row.sk}</td>
                        <td class="text-center"><strong>${row.totalQuota}</strong></td>
                    </tr>
                `;
            }

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            if (skippedClosedDays.length) {
                const formattedSkipped = skippedClosedDays
                    .map(dateStr => {
                        const [year, month, day] = dateStr.split('-').map(Number);
                        const display = new Date(year, month - 1, day).toLocaleDateString('de-DE');
                        return display;
                    })
                    .join(', ');
                html = `
                    <div class="alert alert-warning py-2 px-3 mb-2" role="alert">
                        ‚ö†Ô∏è Geschlossene Tage (keine Anpassung m√∂glich): ${formattedSkipped}
                    </div>
                ` + html;
            }

            console.log('üìä TableData:', tableData);
            console.log('üìù HTML Length:', html.length);
            console.log('üéØ Setting innerHTML...');
            previewContainer.innerHTML = html;
            console.log('‚úÖ innerHTML gesetzt! previewContainer.children:', previewContainer.children.length);

            // Overbooking Warning
            if (hasOverbooking) {
                warning.classList.remove('d-none');
            } else {
                warning.classList.add('d-none');
            }
        }


        /**
         * Hole aktuelle Belegung f√ºr ein bestimmtes Datum
         * Unterscheidet zwischen AV-Reservierungen (av_id > 0) und internen (av_id = 0)
         * WICHTIG: Z√§hlt ALLE Betten (lager + betten + dz + sonder)!
         */
        async getOccupancyForDate(dateStr) {
            let avReservations = 0;      // Reservierungen VOM AV-System (av_id > 0)
            let internalReservations = 0; // Interne Reservierungen (av_id = 0)

            if (!this.renderer) {
                console.error('‚ùå renderer nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            const { startDate, endDate } = this.renderer.getTimelineDateRange();
            const histogramData = this.renderer.getHistogramData(startDate, endDate);

            if (!histogramData || !histogramData.dailyDetails) {
                console.error('‚ùå histogramData nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            // Berechne Day-Index aus dateStr
            const date = new Date(dateStr);
            const dayIndex = Math.floor((date - startDate) / (1000 * 60 * 60 * 24));

            const detail = histogramData.dailyDetails[dayIndex];

            if (detail) {
                // Hole Reservierungen aus histogramSource f√ºr dieses Datum
                if (window.histogramSource) {
                    const reservationsForDate = window.histogramSource.filter(res => {
                        const resStart = res.anreise || res.start_date || res.start;
                        const resEnd = res.abreise || res.end_date || res.end;
                        return resStart && resEnd && resStart <= dateStr && dateStr < resEnd;
                    });

                    reservationsForDate.forEach(res => {
                        // Z√§hle ALLE Betten (nicht nur Personen!)
                        const details = res.capacity_details || {};
                        const totalBeds = parseInt(details.lager || 0) +
                            parseInt(details.betten || 0) +
                            parseInt(details.dz || 0) +
                            parseInt(details.sonder || 0);

                        if (res.av_id && res.av_id > 0) {
                            avReservations += totalBeds;
                        } else {
                            internalReservations += totalBeds;
                        }
                    });
                }

                const total = avReservations + internalReservations;
                console.log(`üìä ${dateStr} (dayIndex ${dayIndex}): AV=${avReservations} Betten, Intern=${internalReservations} Betten, Total=${total}`);
            } else {
                console.warn(`‚ö†Ô∏è Kein dailyDetail f√ºr ${dateStr} (dayIndex ${dayIndex})`);
            }

            return { av: avReservations, internal: internalReservations, total: avReservations + internalReservations };
        }

        /**
         * Hole bereits gebuchte AV-Kategorien f√ºr ein bestimmtes Datum
         * WICHTIG: Nur Reservierungen mit av_id > 0 z√§hlen!
```        /**
         * Hole bereits gebuchte Kategorien f√ºr ein bestimmtes Datum
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @param {boolean} onlyAV - true = nur AV-Reservierungen (av_id > 0), false = nur Intern (av_id = 0)
         * @returns {object} - { sonder, lager, betten, dz }
         */
        async getBookedCategoriesForDate(dateStr, onlyAV = true) {
            const booked = { sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !window.histogramSource) {
                return booked;
            }

            // Filtere Reservierungen f√ºr dieses Datum
            const reservationsForDate = window.histogramSource.filter(res => {
                // Filter nach AV oder Intern
                if (onlyAV) {
                    if (!res.av_id || res.av_id <= 0) return false; // Nur AV-Reservierungen
                } else {
                    if (res.av_id && res.av_id > 0) return false; // Nur interne Reservierungen
                }

                // Pr√ºfe ob Datum im Reservierungs-Zeitraum liegt
                const resStart = res.anreise || res.start_date || res.start;
                const resEnd = res.abreise || res.end_date || res.end;

                return dateStr >= resStart && dateStr < resEnd;
            });

            // Z√§hle nach Kategorien (aus capacity_details)
            reservationsForDate.forEach(res => {
                const details = res.capacity_details || {};

                booked.sonder += parseInt(details.sonder || 0);
                booked.lager += parseInt(details.lager || 0);
                booked.betten += parseInt(details.betten || 0);
                booked.dz += parseInt(details.dz || 0);
            });

            return booked;
        }

        /**
         * Hole aktuelle Quota f√ºr ein bestimmtes Datum (falls bereits gesetzt)
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { freePlaces, sonder, lager, betten, dz }
         */
        async getCurrentQuotaForDate(dateStr) {
            const quota = { freePlaces: 0, sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !this.renderer) {
                return quota;
            }

            const MS_IN_DAY = 24 * 60 * 60 * 1000;
            const { startDate, endDate } = this.renderer.getTimelineDateRange();

            const normalizedStart = new Date(startDate);
            normalizedStart.setHours(12, 0, 0, 0);

            const normalizedDate = new Date(dateStr);
            normalizedDate.setHours(12, 0, 0, 0);

            const dayIndex = Math.floor((normalizedDate - normalizedStart) / MS_IN_DAY);

            // Hole Availability-Daten (enthaelt Quota-Informationen) - Backend ist schon inklusiv!
            const histogramData = this.renderer.getHistogramData(normalizedStart, endDate);

            if (histogramData && histogramData.dailyDetails && dayIndex >= 0 && dayIndex < histogramData.dailyDetails.length) {
                const details = histogramData.dailyDetails[dayIndex];
                const quotaDetails = details.quota || {};

                quota.freePlaces = details.free_capacity || 0;
                quota.sonder = quotaDetails.sonder || 0;
                quota.lager = quotaDetails.lager || 0;
                quota.betten = quotaDetails.betten || 0;
                quota.dz = quotaDetails.dz || 0;
            }

            return quota;
        }

        /**
         * Hole HRS Daily Summary Daten f√ºr ein bestimmtes Datum
         * Diese Daten sind ESSENTIELL f√ºr die korrekte Quota-Berechnung!
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { totalGuests, categories: { lager, betten, dz, sonder } }
         */
        async getDailySummaryForDate(dateStr) {
            const result = {
                totalGuests: 0,
                categories: {
                    lager: { freePlaces: 0, assigned: 0 },
                    betten: { freePlaces: 0, assigned: 0 },
                    dz: { freePlaces: 0, assigned: 0 },
                    sonder: { freePlaces: 0, assigned: 0 }
                }
            };

            if (!dateStr) {
                return result;
            }

            try {
                // Lade Daily Summary aus DB via API
                const response = await fetch(`/wci/zp/getDailySummary.php?date=${dateStr}`);
                if (!response.ok) {
                    console.warn(`‚ö†Ô∏è getDailySummary failed: ${response.status}`);
                    return result;
                }

                const data = await response.json();

                if (data.success && data.data) {
                    result.totalGuests = data.data.total_guests || 0;

                    // Mappe Kategorien
                    const categoryMap = {
                        'ML': 'lager',
                        'MBZ': 'betten',
                        '2BZ': 'dz',
                        'SK': 'sonder'
                    };

                    if (data.data.categories) {
                        data.data.categories.forEach(cat => {
                            const mappedName = categoryMap[cat.category_type];
                            if (mappedName) {
                                result.categories[mappedName] = {
                                    freePlaces: parseInt(cat.free_places || 0),
                                    assigned: parseInt(cat.assigned_guests || 0)
                                };
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('‚ùå Error loading daily summary:', error);
            }

            return result;
        }

        /**
         * Validierung
         */
        validate() {
            // Einfache Validierung: Pr√ºfe ob targetCapacity gesetzt ist
            const targetCapacity = parseInt(document.getElementById('targetCapacity').value);

            if (!targetCapacity || targetCapacity <= 0) {
                alert('‚ùå Fehler: Zielauslastung muss gr√∂√üer als 0 sein!');
                return false;
            }

            // Pr√ºfe ob Tage selektiert sind
            if (!this.selectedDays || this.selectedDays.length === 0) {
                alert('‚ùå Fehler: Keine Tage ausgew√§hlt!');
                return false;
            }

            return true;
        }

        /**
         * Speichert Quotas via API
         */
        async save() {
            if (!this.validate()) return;

            this.selectedDays = this.sanitizeSelectedDays(this.selectedDays);
            if (!this.selectedDays.length) {
                alert('‚ùå Keine bearbeitbaren Tage (alle geschlossen).');
                return;
            }

            const segments = this.getContiguousSegmentsFromDays(this.selectedDays);
            if (!segments.length) {
                alert('‚ùå Keine verarbeitbaren Zeitr√§ume gefunden.');
                return;
            }

            const saveBtn = document.getElementById('saveQuotaBtn');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '‚è≥ Speichern...';

            const statusEnabled = this.startStatusWorkflow([
                'Sende Daten an HRS',
                'Quotas schreiben',
                'Import aktualisieren'
            ]);

            // Enable real-time updates using direct callback system
            let realTimeEnabled = statusEnabled;
            if (realTimeEnabled) {
                console.log(`[${new Date().toISOString()}] üîó Real-time updates enabled via direct callbacks`);
                this.enableRealTimeUpdates = true;
            }

            try {
                const targetCapacity = parseInt(document.getElementById('targetCapacityValue').value) || 0;

                const aggregated = {
                    created: 0,
                    deleted: 0,
                    adjustedClosed: 0
                };
                const importSegments = [];
                let processedSegments = 0;

                if (statusEnabled) {
                    this.setStatusStep(1, 'active', `Verarbeite ${segments.length} Segment(e)`);
                }

                for (let index = 0; index < segments.length; index++) {
                    const segment = segments[index];
                    const segmentResult = await this.processQuotaSegment(segment, targetCapacity, statusEnabled, index, segments.length);
                    if (!segmentResult || segmentResult.skipped) {
                        continue;
                    }

                    processedSegments++;
                    aggregated.created += segmentResult.createdCount;
                    aggregated.deleted += segmentResult.deletedCount;
                    aggregated.adjustedClosed += segmentResult.adjustedClosedCount;

                    // Use affectedDateRange if available, otherwise fallback to original segment dates
                    const importDateRange = segmentResult.affectedDateRange || {
                        from: segment.dateFrom,
                        to: segment.dateTo
                    };

                    console.log(`üìÖ Import Range for Segment ${index + 1}:`, {
                        originalSegment: { from: segment.dateFrom, to: segment.dateTo },
                        affectedDateRange: segmentResult.affectedDateRange,
                        finalImportRange: importDateRange
                    });

                    importSegments.push({
                        dateFrom: importDateRange.from,
                        dateTo: importDateRange.to,
                        dayCount: segment.dayCount  // Keep original for reference, will be recalculated by HRS import
                    });

                    if (statusEnabled) {
                        const summary = `${aggregated.created} erstellt, ${aggregated.deleted} gel√∂scht${aggregated.adjustedClosed ? `, ${aggregated.adjustedClosed} geschlossen angepasst` : ''}`;
                        this.setStatusStep(1, 'success', summary);
                    }
                }

                if (processedSegments === 0) {
                    throw new Error('Keine bearbeitbaren Tage gefunden ‚Äì alle ausgew√§hlten Tage sind geschlossen.');
                }

                console.log('‚è≥ Waiting 2 seconds for HRS upload to complete...');
                await new Promise(resolve => setTimeout(resolve, 2000));

                const hasQuotaOnlyReload = typeof window.reloadQuotaDataOnly === 'function';
                const hasFullReloadFunction = typeof window.reloadTimelineData === 'function';
                const willAutoImport = importSegments.length > 0;

                // **WICHTIG: HRS Upload ist abgeschlossen - jetzt HRS-Import starten um die hochgeladenen Quotas zu importieren**
                if (willAutoImport && hasQuotaOnlyReload) {
                    // Bei Quota-Only: Erst HRS-Import (um die gerade hochgeladenen Quotas zu importieren), dann lokaler Reload
                    if (statusEnabled) {
                        this.setStatusStep(2, 'active', 'HRS Quota+AV-Import (nach Upload)...');
                    }
                    console.log('üéØ Starte HRS Quota+AV-Import f√ºr gerade hochgeladene Quotas...');

                    // **WICHTIG: Zus√§tzliche Wartezeit damit HRS die hochgeladenen Quotas verarbeitet hat**
                    console.log('‚è≥ Warte 3 Sekunden damit HRS die hochgeladenen Quotas verarbeitet...');
                    await new Promise(resolve => setTimeout(resolve, 3000));

                    const quotaImportSuccess = await this.triggerSelectiveQuotaImport(importSegments);

                    if (quotaImportSuccess) {
                        // **WICHTIG: Warten bis Import-DB-Commit abgeschlossen ist**
                        console.log('‚è≥ Warte 2 Sekunden bis Import-DB-Commits abgeschlossen sind...');
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        if (statusEnabled) {
                            this.setStatusStep(2, 'active', 'Quota-Daten lokal aktualisieren...');
                        }
                        console.log('üîÑ Nach HRS-Import + Wartezeit: Calling window.reloadQuotaDataOnly()...');
                        await window.reloadQuotaDataOnly();
                        console.log('‚úÖ Quota-Daten erfolgreich aktualisiert (nach HRS-Import + DB-Sync)');

                        if (window.renderer && typeof window.renderer.render === 'function') {
                            console.log('üé® Forcing histogram redraw...');
                            window.renderer.render();
                            console.log('‚úÖ Histogram redrawn');
                        }
                    } else {
                        console.warn('‚ö†Ô∏è HRS Quota-Import fehlgeschlagen, verwende lokale Daten');
                        await window.reloadQuotaDataOnly();
                    }
                } else if (hasQuotaOnlyReload && !willAutoImport) {
                    // Nur lokaler Reload ohne HRS-Import
                    if (statusEnabled) {
                        this.setStatusStep(2, 'active', 'Quota-Daten aktualisieren...');
                    }
                    console.log('üîÑ Calling window.reloadQuotaDataOnly() (ohne HRS-Import)...');
                    await window.reloadQuotaDataOnly();
                    console.log('‚úÖ Quota-Daten erfolgreich aktualisiert (ohne HRS-Import)');

                    if (window.renderer && typeof window.renderer.render === 'function') {
                        console.log('üé® Forcing histogram redraw...');
                        window.renderer.render();
                        console.log('‚úÖ Histogram redrawn');
                    }
                } else if (hasFullReloadFunction) {
                    if (statusEnabled) {
                        this.setStatusStep(2, 'active', 'Timeline aktualisieren (Fallback)...');
                    }
                    console.log('üîÑ Calling window.reloadTimelineData() (Fallback - Vollreload)...');
                    await window.reloadTimelineData();
                    console.log('‚úÖ Timeline data reloaded successfully');

                    if (window.renderer && typeof window.renderer.render === 'function') {
                        console.log('üé® Forcing histogram redraw...');
                        window.renderer.render();
                        console.log('‚úÖ Histogram redrawn');
                    }
                } else {
                    console.warn('‚ö†Ô∏è Weder window.reloadQuotaDataOnly() noch window.reloadTimelineData() verf√ºgbar, verwende Seitenreload...');
                    if (statusEnabled) {
                        this.setStatusStep(2, 'warn', 'Seitenreload wird durchgef√ºhrt‚Ä¶');
                    }
                    setTimeout(() => window.location.reload(), 500);
                }

                this.modal.hide();

                // **HRS Import (falls nicht bereits in der optimierten Variante oben gemacht)**
                if (willAutoImport && !hasQuotaOnlyReload && hasFullReloadFunction) {
                    // Nur bei Vollreload automatischen HRS Import starten (wenn nicht schon bei Quota-Only gemacht)
                    if (statusEnabled) {
                        this.setStatusStep(2, 'active', 'Automatischen HRS Import starten‚Ä¶');
                    }
                    const importSuccess = await this.triggerAutomaticHRSImportAfterDeploy(importSegments);
                    if (statusEnabled) {
                        this.setStatusStep(2, importSuccess ? 'success' : 'warn', importSuccess ? 'Automatischer HRS Import abgeschlossen' : 'HRS Import (Fallback) gestartet');
                    }
                } else if (willAutoImport && !hasQuotaOnlyReload) {
                    console.warn('‚ö†Ô∏è Automatischer HRS Import nicht gestartet: Reload-Funktionen fehlen.');
                    if (statusEnabled) {
                        this.setStatusStep(2, 'warn', 'HRS Import nicht gestartet (Reload nicht verf√ºgbar)');
                    }
                } else if (statusEnabled && (hasQuotaOnlyReload || hasFullReloadFunction) && !willAutoImport) {
                    this.setStatusStep(2, 'success', hasQuotaOnlyReload ? 'Quota-Daten aktualisiert' : 'Timeline aktualisiert');
                }

                if (statusEnabled) {
                    const finalSummary = `${aggregated.created} erstellt, ${aggregated.deleted} gel√∂scht${aggregated.adjustedClosed ? `, ${aggregated.adjustedClosed} geschlossen angepasst` : ''}`;
                    this.completeStatusWorkflow(true, finalSummary);
                } else {
                    alert(`‚úÖ Erfolg!\n\nErstellt: ${aggregated.created} Quotas\nGel√∂scht: ${aggregated.deleted} Quotas`);
                }

            } catch (error) {
                console.error('Quota save error:', error);
                if (statusEnabled) {
                    this.failStatusWorkflow(error.message || 'Unbekannter Fehler');
                } else {
                    alert(`‚ùå Netzwerkfehler:\n\n${error.message}`);
                }
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'üíæ Speichern';
            }
        }

        async processQuotaSegment(segment, targetCapacity, statusEnabled, segmentIndex, totalSegments) {
            const label = `Segment ${segmentIndex + 1}/${totalSegments}: ${segment.dateFrom} ‚Äì ${segment.dateTo}`;
            if (statusEnabled) {
                this.setStatusStep(0, 'active', label);
            }

            const dailyQuotas = [];
            for (const dateStr of segment.dates) {
                if (this.isDayClosed(dateStr)) {
                    console.warn(`‚õî ${dateStr} ist geschlossen ‚Äì Tag wird √ºbersprungen.`);
                    continue;
                }

                const calculatedQuotas = await this.calculateQuotaDistribution(targetCapacity, null, dateStr);
                const assignedGuestsAV = await this.getBookedCategoriesForDate(dateStr, true);

                const quotasToWrite = {
                    lager: assignedGuestsAV.lager + calculatedQuotas.lager,
                    betten: assignedGuestsAV.betten + calculatedQuotas.betten,
                    dz: assignedGuestsAV.dz + calculatedQuotas.dz,
                    sonder: assignedGuestsAV.sonder + calculatedQuotas.sonder
                };

                console.log(`üìä ${dateStr} (${label}):`, quotasToWrite);

                dailyQuotas.push({
                    date: dateStr,
                    quota_lager: quotasToWrite.lager,
                    quota_betten: quotasToWrite.betten,
                    quota_dz: quotasToWrite.dz,
                    quota_sonder: quotasToWrite.sonder,
                    targetCapacity: targetCapacity
                });
            }

            if (!dailyQuotas.length) {
                console.warn('‚ö†Ô∏è Segment enth√§lt keine bearbeitbaren Tage und wird √ºbersprungen:', segment);
                if (statusEnabled) {
                    this.setStatusStep(0, 'warn', `${label} (nur geschlossene Tage)`);
                }
                return { skipped: true };
            }

            console.log('üì§ Sende Segment an HRS API:', { label, dailyQuotas });

            let detailSegmentId = null;
            if (statusEnabled) {
                detailSegmentId = this.createStatusDetailSegment(label, dailyQuotas);
            }

            let response;
            try {
                // Prepare request data
                const requestData = {
                    quotas: dailyQuotas,
                    operation: 'update'
                };

                // Add SSE session ID if available
                if (this.sseSessionId) {
                    requestData.sse_session = this.sseSessionId;
                }

                response = await fetch((typeof WCIConfig !== 'undefined' ? WCIConfig.getEndpoint('hrsWriteQuota', { v: '20251011_v3' }) : null) || '/wci/hrs/hrs_write_quota_v3.php?v=20251011_v3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
            } catch (networkError) {
                if (statusEnabled) {
                    if (detailSegmentId) {
                        this.markStatusDetailSegmentError(detailSegmentId, dailyQuotas, networkError.message || 'Netzwerkfehler');
                    }
                    this.setStatusStep(0, 'error', `${label} ‚Äì Netzwerkfehler`);
                }
                throw networkError;
            }

            const responseText = await response.text();
            console.log(`üì• Response (${label}) status:`, response.status);

            let result;
            try {
                result = JSON.parse(responseText);
            } catch (parseError) {
                console.error('‚ùå JSON Parse Error:', parseError.message);
                console.error('üìÑ Full response:', responseText);
                if (statusEnabled) {
                    if (detailSegmentId) {
                        this.markStatusDetailSegmentError(detailSegmentId, dailyQuotas, 'Ung√ºltige Server-Antwort');
                    }
                    this.setStatusStep(0, 'error', `${label} ‚Äì Ung√ºltige Server-Antwort`);
                }
                throw new Error('Server returned invalid JSON. Response: ' + responseText.substring(0, 200));
            }

            if (!response.ok || !result.success) {
                const errorMessage = result?.error || result?.message || `HTTP ${response.status}`;
                console.error('‚ùå API Error Response:', result);
                if (statusEnabled) {
                    if (detailSegmentId) {
                        this.markStatusDetailSegmentError(detailSegmentId, dailyQuotas, errorMessage);
                    }
                    this.setStatusStep(0, 'error', `${label} ‚Äì ${errorMessage}`);
                }
                throw new Error(errorMessage);
            }

            // Apply real-time updates directly from API response
            if (statusEnabled && detailSegmentId) {
                if (result.createdQuotas && result.createdQuotas.length > 0) {
                    // Apply each created quota immediately for real-time effect
                    this.applyRealTimeQuotaUpdates(detailSegmentId, result.createdQuotas, dailyQuotas);
                } else {
                    // Fallback to batch update
                    this.applySegmentResultToDetails(detailSegmentId, dailyQuotas, result);
                }
            }

            if (statusEnabled) {
                this.setStatusStep(0, 'success', `${label} erfolgreich`);
            }

            const createdCount = Number.isFinite(result.createdCount)
                ? result.createdCount
                : (Array.isArray(result.createdQuotas) ? result.createdQuotas.length : 0);
            const deletedCount = Number.isFinite(result.deletedCount)
                ? result.deletedCount
                : (Array.isArray(result.deletedQuotas) ? result.deletedQuotas.length : 0);
            const adjustedClosedCount = Number.isFinite(result.adjustedClosedCount)
                ? result.adjustedClosedCount
                : (Array.isArray(result.adjustedClosedQuotas) ? result.adjustedClosedQuotas.length : 0);

            const importInfo = result.localRefresh || {};
            if (importInfo && Object.keys(importInfo).length > 0) {
                if (importInfo.success) {
                    console.log('‚úÖ Segment-Import erfolgreich aktualisiert');
                } else {
                    console.warn('‚ö†Ô∏è Segment-Import meldet Fehler:', importInfo.error || 'Unbekannter Fehler');
                }
            }

            if (result.affectedDateRange) {
                console.log('üìÖ Segment affected range:', result.affectedDateRange);
            }

            return {
                createdCount,
                deletedCount,
                adjustedClosedCount,
                affectedDateRange: result.affectedDateRange || null,
                importInfo
            };
        }
    }

    // Globale Instanz erstellen (wird von timeline-unified.js genutzt)
    window.quotaInputModal = null;

    // Initialisierungs-Funktion (wird nach dem Laden des HTML aufgerufen)
    window.initQuotaInputModal = function () {
        console.log('üìã initQuotaInputModal aufgerufen');

        // Warte auf renderer-Initialisierung
        const checkRenderer = setInterval(() => {
            if (typeof window.renderer !== 'undefined' && window.renderer) {
                window.quotaInputModal = new QuotaInputModal(window.renderer);
                console.log('‚úÖ Quota Input Modal initialized mit renderer:', window.renderer);
                clearInterval(checkRenderer);
            } else {
                console.log('‚è≥ Warte auf window.renderer...');
            }
        }, 100);

        // Timeout nach 10 Sekunden
        setTimeout(() => {
            if (!window.quotaInputModal) {
                console.warn('‚ö†Ô∏è Quota Modal konnte nicht initialisiert werden - renderer nicht gefunden');
                console.log('window.renderer ist:', window.renderer);
            }
        }, 10000);
    };

    // Wenn DOMContentLoaded schon vorbei ist (bei dynamischem Laden), sofort initialisieren
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.initQuotaInputModal);
    } else {
        // DOM ist bereits bereit, sofort initialisieren
        window.initQuotaInputModal();
    }
</script>