<!-- ==================== QUOTA INPUT MODAL ==================== -->
<div class="modal fade" id="quotaInputModal" tabindex="-1" aria-labelledby="quotaInputModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="quotaInputModalLabel">üìä Quota bearbeiten</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="quotaForm">
                    <!-- Zeitraum Anzeige -->
                    <div class="alert alert-info mb-4">
                        <strong>Selektierte Tage:</strong> <span id="quotaDateRange"></span><br>
                        <strong>Aktuelle Belegung:</strong> <span id="currentOccupancy">--</span> Pl√§tze
                    </div>

                    <!-- Zielkapazit√§t -->
                    <div class="mb-4">
                        <label for="targetCapacity" class="form-label">
                            <strong>Zielauslastung (Gesamt)</strong>
                        </label>
                        <div class="row align-items-center">
                            <div class="col-9">
                                <input type="range" class="form-range" id="targetCapacity" min="0" max="200" value="28"
                                    step="1">
                            </div>
                            <div class="col-3">
                                <input type="number" class="form-control" id="targetCapacityValue" min="0" max="200"
                                    value="28" step="1">
                            </div>
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Priorit√§ten -->
                    <h6 class="mb-3">Priorit√§ten (h√∂chste zuerst)</h6>

                    <!-- Priorit√§t 1 -->
                    <div class="row mb-3 priority-row" data-priority="1">
                        <div class="col-1 text-center">
                            <span class="badge bg-primary">1</span>
                        </div>
                        <div class="col-6">
                            <select class="form-select category-select" data-priority="1">
                                <option value="lager" selected>Matratzenlager (ML)</option>
                                <option value="betten">Mehrbettzimmer (MBZ)</option>
                                <option value="dz">Zweibettzimmer (2BZ)</option>
                                <option value="sonder">Sonderkategorie (SK)</option>
                            </select>
                        </div>
                        <div class="col-5">
                            <input type="text" class="form-control" value="(Rest)" disabled readonly
                                style="background-color: #e9ecef; color: #6c757d;">
                        </div>
                    </div>

                    <!-- Priorit√§t 2 -->
                    <div class="row mb-3 priority-row" data-priority="2">
                        <div class="col-1 text-center">
                            <span class="badge bg-secondary">2</span>
                        </div>
                        <div class="col-6">
                            <select class="form-select category-select" data-priority="2">
                                <option value="betten" selected>Mehrbettzimmer (MBZ)</option>
                                <option value="lager">Matratzenlager (ML)</option>
                                <option value="dz">Zweibettzimmer (2BZ)</option>
                                <option value="sonder">Sonderkategorie (SK)</option>
                            </select>
                        </div>
                        <div class="col-5">
                            <input type="number" class="form-control max-value-input" placeholder="Max (leer = ‚àû)"
                                min="0" data-priority="2">
                        </div>
                    </div>

                    <!-- Priorit√§t 3 -->
                    <div class="row mb-3 priority-row" data-priority="3">
                        <div class="col-1 text-center">
                            <span class="badge bg-secondary">3</span>
                        </div>
                        <div class="col-6">
                            <select class="form-select category-select" data-priority="3">
                                <option value="dz" selected>Zweibettzimmer (2BZ)</option>
                                <option value="lager">Matratzenlager (ML)</option>
                                <option value="betten">Mehrbettzimmer (MBZ)</option>
                                <option value="sonder">Sonderkategorie (SK)</option>
                            </select>
                        </div>
                        <div class="col-5">
                            <input type="number" class="form-control max-value-input" placeholder="Max (leer = ‚àû)"
                                min="0" data-priority="3">
                        </div>
                    </div>

                    <!-- Priorit√§t 4 -->
                    <div class="row mb-3 priority-row" data-priority="4">
                        <div class="col-1 text-center">
                            <span class="badge bg-secondary">4</span>
                        </div>
                        <div class="col-6">
                            <select class="form-select category-select" data-priority="4">
                                <option value="sonder" selected>Sonderkategorie (SK)</option>
                                <option value="lager">Matratzenlager (ML)</option>
                                <option value="betten">Mehrbettzimmer (MBZ)</option>
                                <option value="dz">Zweibettzimmer (2BZ)</option>
                            </select>
                        </div>
                        <div class="col-5">
                            <input type="number" class="form-control max-value-input" placeholder="Max (leer = ‚àû)"
                                min="0" data-priority="4">
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Live-Preview berechneter Quotas -->
                    <div class="alert alert-success" id="quotaPreview">
                        <h6 class="mb-3">üìä Berechnete Quotas (pro Tag):</h6>
                        <div id="quotaPreviewDays">
                            <!-- Wird dynamisch gef√ºllt mit Quotas f√ºr jeden Tag -->
                        </div>
                    </div>

                    <!-- Warnung bei √úberbelegung -->
                    <div class="alert alert-warning d-none" id="overbookingWarning">
                        ‚ö†Ô∏è <strong>Warnung:</strong> Bei einigen Tagen √ºberschreitet die Belegung die Zielkapazit√§t!<br>
                        F√ºr diese Tage werden alle Quotas auf 0 gesetzt.
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="saveQuotaBtn">üíæ Speichern</button>
            </div>
        </div>
    </div>
</div>

<script>
    /**
     * Quota Input Modal Manager
     * =========================
     * Verwaltet das Quota-Eingabe-Modal mit Priorit√§ts-basierter Verteilung
     */
    class QuotaInputModal {
        constructor(renderer) {
            this.renderer = renderer;
            this.modal = new bootstrap.Modal(document.getElementById('quotaInputModal'));
            this.selectedDays = [];
            this.currentOccupancy = 0;

            this.initializeEventListeners();
        }

        initializeEventListeners() {
            // Slider <-> Input Sync
            const slider = document.getElementById('targetCapacity');
            const input = document.getElementById('targetCapacityValue');

            slider.addEventListener('input', () => {
                input.value = slider.value;
                this.updatePreview();
            });

            input.addEventListener('input', () => {
                slider.value = input.value;
                this.updatePreview();
            });

            // Priorit√§t-√Ñnderungen
            document.querySelectorAll('.category-select, .max-value-input').forEach(el => {
                el.addEventListener('change', () => this.updatePreview());
                el.addEventListener('input', () => this.updatePreview());
                el.addEventListener('keyup', () => this.updatePreview()); // Auch bei Tastatur-Eingabe
            });

            // Save Button
            document.getElementById('saveQuotaBtn').addEventListener('click', () => this.save());
        }

        /**
         * √ñffne Modal f√ºr selektierte Tage
         */
        show(selectedDays) {
            console.log('üéØ Modal.show() aufgerufen mit selectedDays:', selectedDays);
            this.selectedDays = selectedDays;

            // Datum-Bereich anzeigen (YYYY-MM-DD Strings zu lokalen Dates)
            const parseDateString = (dateStr) => {
                console.log('   üìÖ Parse:', dateStr);
                const [year, month, day] = dateStr.split('-').map(Number);
                const parsed = new Date(year, month - 1, day);
                console.log('   ‚Üí Parsed Date:', parsed, 'Display:', parsed.toLocaleDateString('de-DE'));
                return parsed;
            };

            const dates = selectedDays.map(parseDateString);
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            console.log('üìÜ Min:', minDate.toLocaleDateString('de-DE'), 'Max:', maxDate.toLocaleDateString('de-DE'));

            const dateRange = selectedDays.length === 1
                ? minDate.toLocaleDateString('de-DE')
                : `${minDate.toLocaleDateString('de-DE')} - ${maxDate.toLocaleDateString('de-DE')}`;

            console.log('üìã Final dateRange:', dateRange);
            document.getElementById('quotaDateRange').textContent = dateRange + ` (${selectedDays.length} Tage)`;

            // Hole aktuellen Histogram-Target-Wert vom Renderer
            if (this.renderer && this.renderer.histogramTargetValue) {
                const histogramTarget = this.renderer.histogramTargetValue;
                console.log('üéØ √úbernehme Histogram Target:', histogramTarget);
                document.getElementById('targetCapacity').value = histogramTarget;
                document.getElementById('targetCapacityValue').value = histogramTarget;
            }

            // Aktuelle Belegung laden (TODO: Von API holen)
            this.currentOccupancy = 0; // Placeholder
            document.getElementById('currentOccupancy').textContent = this.currentOccupancy;

            // Preview aktualisieren
            this.updatePreview();

            // Modal anzeigen
            this.modal.show();
        }

        /**
         * Berechnet Quota-Verteilung nach Priorit√§ten
         * 
         * STRATEGIE:
         * 1. Sammle alle Eingangsvariablen √ºbersichtlich
         * 2. Berechne zu erstellende Quotas pro Kategorie
         * 
         * @param {number} targetCapacity - Ziel-Gesamtkapazit√§t
         * @param {object} occupancy - { av, internal, total }
         * @param {string} dateStr - Datum (YYYY-MM-DD) f√ºr Detail-Analysen
         */
        async calculateQuotaDistribution(targetCapacity, occupancy, dateStr = null) {
            console.log(`\n${'='.repeat(80)}`);
            console.log(`üßÆ QUOTA-BERECHNUNG${dateStr ? ' f√ºr ' + dateStr : ''}`);
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 1: EINGANGSVARIABLEN VORBEREITEN
            // ========================================================================

            // 1.1 Belegung von AV-Reservierungen (av_id > 0, storno = false)
            const avOccupancy = await this.getBookedCategoriesForDate(dateStr, true); // nur AV
            console.log('üì• AV-Belegung (av_id > 0):');
            console.log(`   Sonder: ${avOccupancy.sonder}`);
            console.log(`   Lager:  ${avOccupancy.lager}`);
            console.log(`   Betten: ${avOccupancy.betten}`);
            console.log(`   DZ:     ${avOccupancy.dz}`);
            console.log(`   TOTAL:  ${avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz}\n`);

            // 1.2 Belegung von internen Reservierungen (av_id = 0, storno = false)
            const internalOccupancy = await this.getBookedCategoriesForDate(dateStr, false); // nur Intern
            console.log('üì• Interne Belegung (av_id = 0):');
            console.log(`   Sonder: ${internalOccupancy.sonder}`);
            console.log(`   Lager:  ${internalOccupancy.lager}`);
            console.log(`   Betten: ${internalOccupancy.betten}`);
            console.log(`   DZ:     ${internalOccupancy.dz}`);
            console.log(`   TOTAL:  ${internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz}\n`);

            // 1.3 Aktuelle Quota des Tages (falls vorhanden)
            const currentQuota = await this.getCurrentQuotaForDate(dateStr);
            console.log('üìä Aktuelle Quota des Tages:');
            console.log(`   Free Places: ${currentQuota.freePlaces || 0}`);
            console.log(`   Sonder:      ${currentQuota.sonder}`);
            console.log(`   Lager:       ${currentQuota.lager}`);
            console.log(`   Betten:      ${currentQuota.betten}`);
            console.log(`   DZ:          ${currentQuota.dz}`);
            console.log(`   TOTAL:       ${currentQuota.sonder + currentQuota.lager + currentQuota.betten + currentQuota.dz}\n`);

            // 1.4 HRS Daily Summary Daten (WICHTIG f√ºr korrekte Berechnung!)
            const dailySummary = await this.getDailySummaryForDate(dateStr);
            console.log('üìÖ HRS Daily Summary (vom HRS):');
            console.log(`   Total G√§ste: ${dailySummary.totalGuests}`);
            console.log('   Freie Pl√§tze pro Kategorie (HRS):');
            console.log(`     ML (Lager):  ${dailySummary.categories.lager.freePlaces} frei, ${dailySummary.categories.lager.assigned} belegt`);
            console.log(`     MBZ (Betten): ${dailySummary.categories.betten.freePlaces} frei, ${dailySummary.categories.betten.assigned} belegt`);
            console.log(`     2BZ (DZ):     ${dailySummary.categories.dz.freePlaces} frei, ${dailySummary.categories.dz.assigned} belegt`);
            console.log(`     SK (Sonder):  ${dailySummary.categories.sonder.freePlaces} frei, ${dailySummary.categories.sonder.assigned} belegt\n`);

            // 1.5 Zielauslastung gesamt
            console.log('üéØ Zielauslastung gesamt: ' + targetCapacity + ' Betten\n');

            // 1.6 Priorit√§ten auslesen
            const priorities = [];
            console.log('üìã Priorit√§ten:');

            for (let i = 1; i <= 4; i++) {
                const categorySelect = document.querySelector(`.category-select[data-priority="${i}"]`);
                if (!categorySelect) {
                    console.error(`‚ùå Category-Select f√ºr Priorit√§t ${i} nicht gefunden!`);
                    continue;
                }

                const category = categorySelect.value;
                const categoryLabels = {
                    'sonder': 'SK (Sonder)',
                    'lager': 'ML (Lager)',
                    'betten': 'MBZ (Betten)',
                    'dz': '2BZ (DZ)'
                };

                let maxValue;
                if (i === 1) {
                    // Priorit√§t 1 hat keinen Max-Input, bekommt immer den Rest
                    maxValue = Infinity;
                    console.log(`   Priorit√§t ${i}: ${categoryLabels[category]} = REST (keine Begrenzung)`);
                } else {
                    const maxInput = document.querySelector(`.max-value-input[data-priority="${i}"]`);
                    if (!maxInput) {
                        console.error(`‚ùå Max-Input f√ºr Priorit√§t ${i} nicht gefunden!`);
                        maxValue = Infinity;
                    } else {
                        maxValue = (maxInput.value === '' || maxInput.value === '0') ? Infinity : parseInt(maxInput.value);
                        console.log(`   Priorit√§t ${i}: ${categoryLabels[category]} = max ${maxValue === Infinity ? '‚àû' : maxValue}`);
                    }
                }

                priorities.push({ priority: i, category, max: maxValue });
            }

            console.log(`\n${'='.repeat(80)}`);
            console.log('üìê BERECHNUNGSVORBEREITUNG ABGESCHLOSSEN');
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 2: QUOTA-BERECHNUNG (HIER KOMMT DIE FORMEL)
            // ========================================================================

            console.log('üîß TODO: Formel f√ºr Quota-Berechnung implementieren');
            console.log('   Input-Variablen sind bereit!\n');

            // PLACEHOLDER - Alte einfache Logik (wird ersetzt)
            const { av, internal, total } = occupancy;
            let availableQuota = targetCapacity - av - internal;
            if (availableQuota < 0) availableQuota = 0;

            const result = { lager: 0, betten: 0, dz: 0, sonder: 0 };
            let remaining = availableQuota;

            for (const p of priorities) {
                if (remaining <= 0) break;
                const allocated = Math.min(p.max, remaining);
                result[p.category] += allocated;
                remaining -= allocated;
            }

            if (remaining > 0 && priorities.length > 0) {
                result[priorities[0].category] += remaining;
            }

            console.log(`üì§ Berechnete Quota-Verteilung:`);
            console.log(`   Sonder: ${result.sonder}`);
            console.log(`   Lager:  ${result.lager}`);
            console.log(`   Betten: ${result.betten}`);
            console.log(`   DZ:     ${result.dz}`);
            console.log(`   TOTAL:  ${result.sonder + result.lager + result.betten + result.dz}\n`);

            return result;
        }

        /**
         * Aktualisiert Live-Preview - berechnet f√ºr JEDEN TAG individuell
         */
        async updatePreview() {
            const targetCapacity = parseInt(document.getElementById('targetCapacity').value);
            const previewContainer = document.getElementById('quotaPreviewDays');
            previewContainer.innerHTML = '';

            let hasOverbooking = false;

            // F√ºr jeden selektierten Tag
            for (const dateStr of this.selectedDays) {
                // Hole Belegung (AV + Intern getrennt)
                const occupancy = await this.getOccupancyForDate(dateStr);

                // ‚úÖ Berechne Quotas mit allen Detail-Informationen
                const quotas = await this.calculateQuotaDistribution(targetCapacity, occupancy, dateStr);

                console.log(`üí° ${dateStr}: AV=${occupancy.av}, Intern=${occupancy.internal}, Quotas=${JSON.stringify(quotas)}`);

                // Check Overbooking (wenn keine Quota mehr verf√ºgbar)
                const availableQuota = targetCapacity - occupancy.av - occupancy.internal;
                if (availableQuota <= 0) {
                    hasOverbooking = true;
                }

                // Parse Datum f√ºr Anzeige
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dateDisplay = date.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit', month: '2-digit' });

                // Erstelle Preview-Zeile
                const row = document.createElement('div');
                row.className = 'mb-2 pb-2 border-bottom';
                row.innerHTML = `
                <div class="row align-items-center" style="font-size: 0.9em;">
                    <div class="col-3">
                        <strong>${dateDisplay}</strong><br>
                        <small class="text-muted">
                            AV: ${occupancy.av} | Int: ${occupancy.internal}<br>
                            Quota: ${Math.max(0, targetCapacity + occupancy.av - occupancy.internal)}
                        </small>
                    </div>
                    <div class="col-9">
                        <div class="row">
                            <div class="col-3">
                                <strong>ML:</strong> <span class="${quotas.lager > 0 ? 'text-success' : 'text-muted'}">${quotas.lager}</span>
                            </div>
                            <div class="col-3">
                                <strong>MBZ:</strong> <span class="${quotas.betten > 0 ? 'text-success' : 'text-muted'}">${quotas.betten}</span>
                            </div>
                            <div class="col-3">
                                <strong>2BZ:</strong> <span class="${quotas.dz > 0 ? 'text-success' : 'text-muted'}">${quotas.dz}</span>
                            </div>
                            <div class="col-3">
                                <strong>SK:</strong> <span class="${quotas.sonder > 0 ? 'text-success' : 'text-muted'}">${quotas.sonder}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
                previewContainer.appendChild(row);
            }

            // Overbooking Warning
            const warning = document.getElementById('overbookingWarning');
            if (hasOverbooking) {
                warning.classList.remove('d-none');
                warning.innerHTML = `‚ö†Ô∏è <strong>Warnung:</strong> Bei einigen Tagen ist keine Quota mehr verf√ºgbar (Ziel + AV - Intern ‚â§ 0)!<br>F√ºr diese Tage werden alle Quotas auf 0 gesetzt.`;
            } else {
                warning.classList.add('d-none');
            }
        }


        /**
         * Hole aktuelle Belegung f√ºr ein bestimmtes Datum
         * Unterscheidet zwischen AV-Reservierungen (av_id > 0) und internen (av_id = 0)
         * WICHTIG: Z√§hlt ALLE Betten (lager + betten + dz + sonder)!
         */
        async getOccupancyForDate(dateStr) {
            let avReservations = 0;      // Reservierungen VOM AV-System (av_id > 0)
            let internalReservations = 0; // Interne Reservierungen (av_id = 0)

            if (!this.renderer) {
                console.error('‚ùå renderer nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            const { startDate, endDate } = this.renderer.getTimelineDateRange();
            const histogramData = this.renderer.getHistogramData(startDate, endDate);

            if (!histogramData || !histogramData.dailyDetails) {
                console.error('‚ùå histogramData nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            // Berechne Day-Index aus dateStr
            const date = new Date(dateStr);
            const dayIndex = Math.floor((date - startDate) / (1000 * 60 * 60 * 24));

            const detail = histogramData.dailyDetails[dayIndex];

            if (detail) {
                // Hole Reservierungen aus histogramSource f√ºr dieses Datum
                if (window.histogramSource) {
                    const reservationsForDate = window.histogramSource.filter(res => {
                        const resStart = res.anreise || res.start_date || res.start;
                        const resEnd = res.abreise || res.end_date || res.end;
                        return resStart && resEnd && resStart <= dateStr && dateStr < resEnd;
                    });

                    reservationsForDate.forEach(res => {
                        // Z√§hle ALLE Betten (nicht nur Personen!)
                        const details = res.capacity_details || {};
                        const totalBeds = parseInt(details.lager || 0) +
                            parseInt(details.betten || 0) +
                            parseInt(details.dz || 0) +
                            parseInt(details.sonder || 0);

                        if (res.av_id && res.av_id > 0) {
                            avReservations += totalBeds;
                        } else {
                            internalReservations += totalBeds;
                        }
                    });
                }

                const total = avReservations + internalReservations;
                console.log(`üìä ${dateStr} (dayIndex ${dayIndex}): AV=${avReservations} Betten, Intern=${internalReservations} Betten, Total=${total}`);
            } else {
                console.warn(`‚ö†Ô∏è Kein dailyDetail f√ºr ${dateStr} (dayIndex ${dayIndex})`);
            }

            return { av: avReservations, internal: internalReservations, total: avReservations + internalReservations };
        }

        /**
         * Hole bereits gebuchte AV-Kategorien f√ºr ein bestimmtes Datum
         * WICHTIG: Nur Reservierungen mit av_id > 0 z√§hlen!
```        /**
         * Hole bereits gebuchte Kategorien f√ºr ein bestimmtes Datum
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @param {boolean} onlyAV - true = nur AV-Reservierungen (av_id > 0), false = nur Intern (av_id = 0)
         * @returns {object} - { sonder, lager, betten, dz }
         */
        async getBookedCategoriesForDate(dateStr, onlyAV = true) {
            const booked = { sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !window.histogramSource) {
                return booked;
            }

            // Filtere Reservierungen f√ºr dieses Datum
            const reservationsForDate = window.histogramSource.filter(res => {
                // Filter nach AV oder Intern
                if (onlyAV) {
                    if (!res.av_id || res.av_id <= 0) return false; // Nur AV-Reservierungen
                } else {
                    if (res.av_id && res.av_id > 0) return false; // Nur interne Reservierungen
                }

                // Pr√ºfe ob Datum im Reservierungs-Zeitraum liegt
                const resStart = res.anreise || res.start_date || res.start;
                const resEnd = res.abreise || res.end_date || res.end;

                return dateStr >= resStart && dateStr < resEnd;
            });

            // Z√§hle nach Kategorien (aus capacity_details)
            reservationsForDate.forEach(res => {
                const details = res.capacity_details || {};

                booked.sonder += parseInt(details.sonder || 0);
                booked.lager += parseInt(details.lager || 0);
                booked.betten += parseInt(details.betten || 0);
                booked.dz += parseInt(details.dz || 0);
            });

            return booked;
        }

        /**
         * Hole aktuelle Quota f√ºr ein bestimmtes Datum (falls bereits gesetzt)
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { freePlaces, sonder, lager, betten, dz }
         */
        async getCurrentQuotaForDate(dateStr) {
            const quota = { freePlaces: 0, sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !this.renderer) {
                return quota;
            }

            const { startDate } = this.renderer.getTimelineDateRange();
            const date = new Date(dateStr);
            const dayIndex = Math.floor((date - startDate) / (1000 * 60 * 60 * 24));

            // Hole Availability-Daten (enth√§lt Quota-Informationen)
            const histogramData = this.renderer.getHistogramData(startDate, new Date(dateStr));

            if (histogramData && histogramData.availabilityData && histogramData.availabilityData[dayIndex]) {
                const avData = histogramData.availabilityData[dayIndex];

                quota.freePlaces = avData.free_places || 0;
                quota.sonder = avData.quota_sonder || 0;
                quota.lager = avData.quota_lager || 0;
                quota.betten = avData.quota_betten || 0;
                quota.dz = avData.quota_dz || 0;
            }

            return quota;
        }

        /**
         * Hole HRS Daily Summary Daten f√ºr ein bestimmtes Datum
         * Diese Daten sind ESSENTIELL f√ºr die korrekte Quota-Berechnung!
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { totalGuests, categories: { lager, betten, dz, sonder } }
         */
        async getDailySummaryForDate(dateStr) {
            const result = {
                totalGuests: 0,
                categories: {
                    lager: { freePlaces: 0, assigned: 0 },
                    betten: { freePlaces: 0, assigned: 0 },
                    dz: { freePlaces: 0, assigned: 0 },
                    sonder: { freePlaces: 0, assigned: 0 }
                }
            };

            if (!dateStr) {
                return result;
            }

            try {
                // Lade Daily Summary aus DB via API
                const response = await fetch(`/wci/zp/getDailySummary.php?date=${dateStr}`);
                if (!response.ok) {
                    console.warn(`‚ö†Ô∏è getDailySummary failed: ${response.status}`);
                    return result;
                }

                const data = await response.json();

                if (data.success && data.data) {
                    result.totalGuests = data.data.total_guests || 0;

                    // Mappe Kategorien
                    const categoryMap = {
                        'ML': 'lager',
                        'MBZ': 'betten',
                        '2BZ': 'dz',
                        'SK': 'sonder'
                    };

                    if (data.data.categories) {
                        data.data.categories.forEach(cat => {
                            const mappedName = categoryMap[cat.category_type];
                            if (mappedName) {
                                result.categories[mappedName] = {
                                    freePlaces: parseInt(cat.free_places || 0),
                                    assigned: parseInt(cat.assigned_guests || 0)
                                };
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('‚ùå Error loading daily summary:', error);
            }

            return result;
        }

        /**
         * Validierung
         */
        validate() {
            // Pr√ºfe auf Duplikate
            const categories = [];
            for (let i = 1; i <= 4; i++) {
                const categorySelect = document.querySelector(`.category-select[data-priority="${i}"]`);
                if (!categorySelect) {
                    alert(`‚ùå Fehler: Category-Select f√ºr Priorit√§t ${i} nicht gefunden!`);
                    return false;
                }
                categories.push(categorySelect.value);
            }

            const uniqueCategories = [...new Set(categories)];
            if (categories.length !== uniqueCategories.length) {
                alert('‚ùå Fehler: Kategorie-Duplikate nicht erlaubt!');
                return false;
            }

            return true;
        }

        /**
         * Speichert Quotas via API
         */
        async save() {
            if (!this.validate()) return;

            const saveBtn = document.getElementById('saveQuotaBtn');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '‚è≥ Speichern...';

            try {
                const targetCapacity = parseInt(document.getElementById('targetCapacityValue').value) || 0;

                // Sammle Priorit√§ten
                const priorities = [];
                for (let i = 1; i <= 4; i++) {
                    const categorySelect = document.querySelector(`.category-select[data-priority="${i}"]`);
                    const maxInputElement = document.querySelector(`.max-value-input[data-priority="${i}"]`);

                    if (!categorySelect || !maxInputElement) {
                        console.error(`‚ùå Elemente f√ºr Priorit√§t ${i} nicht gefunden!`);
                        continue;
                    }

                    const category = categorySelect.value;
                    const maxInputValue = maxInputElement.value;
                    const max = maxInputValue === '' ? null : parseInt(maxInputValue);

                    priorities.push({ category, max });
                }

                // ‚úÖ Berechne f√ºr jeden Tag individuell mit KORRIGIERTER FORMEL
                const dailyQuotas = [];
                for (const dateStr of this.selectedDays) {
                    const occupancy = await this.getOccupancyForDate(dateStr);
                    const quotas = await this.calculateQuotaDistribution(targetCapacity, occupancy, dateStr);

                    dailyQuotas.push({
                        date: dateStr,
                        quotas: quotas,
                        targetCapacity: targetCapacity,
                        avReservations: occupancy.av,
                        internalReservations: occupancy.internal,
                        calculatedQuota: Math.max(0, targetCapacity - occupancy.av - occupancy.internal)
                    });
                }

                // API Call
                const requestBody = {
                    selectedDays: this.selectedDays,
                    targetCapacity: targetCapacity,
                    priorities: priorities,
                    dailyQuotas: dailyQuotas,  // ‚úÖ Sende t√§gliche Quotas mit AV
                    operation: 'update'
                };

                console.log('üì§ Sending to API:', requestBody);

                const response = await fetch('/wci/hrs/hrs_update_quota_timeline.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('üì• Response status:', response.status);

                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('‚ùå Non-JSON response:', text);
                    throw new Error('Server returned non-JSON response: ' + text.substring(0, 200));
                }

                const result = await response.json();

                if (!response.ok) {
                    console.error('‚ùå API Error Response:', result);
                    throw new Error(result.error || result.message || 'Unknown server error');
                }

                if (result.success) {
                    alert(`‚úÖ Erfolg!\n\n${result.message}\n\nErstellt: ${result.createdQuotas.length} Quotas\nGel√∂scht: ${result.deletedQuotas.length} Quotas`);

                    // Timeline neu laden
                    if (this.renderer && typeof this.renderer.reloadHistogramData === 'function') {
                        await this.renderer.reloadHistogramData();
                    }

                    this.modal.hide();
                } else {
                    alert(`‚ùå Fehler beim Speichern:\n\n${result.error}`);
                }

            } catch (error) {
                console.error('Quota save error:', error);
                alert(`‚ùå Netzwerkfehler:\n\n${error.message}`);
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'üíæ Speichern';
            }
        }
    }

    // Globale Instanz erstellen (wird von timeline-unified.js genutzt)
    window.quotaInputModal = null;

    // Initialisierungs-Funktion (wird nach dem Laden des HTML aufgerufen)
    window.initQuotaInputModal = function () {
        console.log('üìã initQuotaInputModal aufgerufen');

        // Warte auf renderer-Initialisierung
        const checkRenderer = setInterval(() => {
            if (typeof window.renderer !== 'undefined' && window.renderer) {
                window.quotaInputModal = new QuotaInputModal(window.renderer);
                console.log('‚úÖ Quota Input Modal initialized mit renderer:', window.renderer);
                clearInterval(checkRenderer);
            } else {
                console.log('‚è≥ Warte auf window.renderer...');
            }
        }, 100);

        // Timeout nach 10 Sekunden
        setTimeout(() => {
            if (!window.quotaInputModal) {
                console.warn('‚ö†Ô∏è Quota Modal konnte nicht initialisiert werden - renderer nicht gefunden');
                console.log('window.renderer ist:', window.renderer);
            }
        }, 10000);
    };

    // Wenn DOMContentLoaded schon vorbei ist (bei dynamischem Laden), sofort initialisieren
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.initQuotaInputModal);
    } else {
        // DOM ist bereits bereit, sofort initialisieren
        window.initQuotaInputModal();
    }
</script>