<!-- ==================== QUOTA INPUT MODAL V3.0 ==================== -->
<!-- Multi-Day Quota Support - MANAGEMENT API (BEW√ÑHRT!) -->
<script>
    console.log('üîÑ Quota Modal V3.0 loaded - Management API');
    console.log('üìç Using endpoint: /wci/hrs/hrs_write_quota_v3.php');
    console.log('üîß API: /api/v1/manage/hutQuota/{hutId} (BEW√ÑHRT wie hrs_del_quota_batch.php)');
</script>
<style>
    /* Custom Modal Breite: 2,5x breiter als modal-xl */
    #quotaInputModal .modal-dialog {
        max-width: 95vw !important;
        width: 95vw !important;
    }

    #quotaInputModal .modal-body {
        max-height: 80vh;
        overflow-y: auto;
    }

    /* Tabelle responsiv */
    #quotaInputModal table {
        width: 100%;
        white-space: nowrap;
    }
</style>

<div class="modal fade" id="quotaInputModal" tabindex="-1" aria-labelledby="quotaInputModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="quotaInputModalLabel">üìä Quota bearbeiten</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="quotaForm">
                    <!-- Zeitraum Anzeige -->
                    <div class="alert alert-info mb-4">
                        <strong>Selektierte Tage:</strong> <span id="quotaDateRange"></span><br>
                        <strong>Aktuelle Belegung:</strong> <span id="currentOccupancy">--</span> Pl√§tze
                    </div>

                    <!-- Zielkapazit√§t -->
                    <div class="mb-4">
                        <label for="targetCapacity" class="form-label">
                            <strong>Zielauslastung (Gesamt)</strong>
                        </label>
                        <div class="row align-items-center">
                            <div class="col-9">
                                <input type="range" class="form-range" id="targetCapacity" min="0" max="200" value="28"
                                    step="1">
                            </div>
                            <div class="col-3">
                                <input type="number" class="form-control" id="targetCapacityValue" min="0" max="200"
                                    value="28" step="1">
                            </div>
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Kategorie-Verteilung (fix, ohne Priorit√§ten) -->
                    <h6 class="mb-3">Kategorie-Verteilung</h6>

                    <!-- ML (Lager) - bekommt immer den REST -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>ML - Matratzenlager</strong>
                        </div>
                        <div class="col-6">
                            <input type="text" class="form-control" value="(bekommt REST)" disabled readonly
                                style="background-color: #d1ecf1; color: #0c5460; font-weight: bold;">
                        </div>
                    </div>

                    <!-- MBZ (Betten) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>MBZ - Mehrbettzimmer</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="betten" id="max-mbz">
                        </div>
                    </div>

                    <!-- 2BZ (DZ) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>2BZ - Zweibettzimmer</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="dz" id="max-2bz">
                        </div>
                    </div>

                    <!-- SK (Sonder) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>SK - Sonderkategorie</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="sonder" id="max-sk">
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Live-Preview berechneter Quotas -->
                    <div class="alert alert-success" id="quotaPreview">
                        <h6 class="mb-3">üìä Berechnete Quotas (pro Tag):</h6>
                        <div id="quotaPreviewDays">
                            <!-- Wird dynamisch gef√ºllt mit Quotas f√ºr jeden Tag -->
                        </div>
                    </div>

                    <!-- Warnung bei √úberbelegung -->
                    <div class="alert alert-warning d-none" id="overbookingWarning">
                        ‚ö†Ô∏è <strong>Warnung:</strong> Bei einigen Tagen √ºberschreitet die Belegung die Zielkapazit√§t!<br>
                        F√ºr diese Tage werden alle Quotas auf 0 gesetzt.
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="saveQuotaBtn">üíæ Speichern</button>
            </div>
        </div>
    </div>
</div>

<script>
    /**
     * Quota Input Modal Manager
     * =========================
     * Verwaltet das Quota-Eingabe-Modal mit Priorit√§ts-basierter Verteilung
     */
    class QuotaInputModal {
        constructor(renderer) {
            this.renderer = renderer;
            this.modal = new bootstrap.Modal(document.getElementById('quotaInputModal'));
            this.selectedDays = [];
            this.currentOccupancy = 0;

            this.initializeEventListeners();

            // WICHTIG: Verhindere Browser-Kontextmen√º im Modal
            const modalElement = document.getElementById('quotaInputModal');
            modalElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }, { capture: true });
        }

        initializeEventListeners() {
            // Slider <-> Input Sync
            const slider = document.getElementById('targetCapacity');
            const input = document.getElementById('targetCapacityValue');

            slider.addEventListener('input', () => {
                input.value = slider.value;
                this.updatePreview();
            });

            input.addEventListener('input', () => {
                slider.value = input.value;
                this.updatePreview();
            });

            // Event-Delegation f√ºr Priorit√§ten (funktioniert auch nach DOM-Updates)
            document.getElementById('quotaForm').addEventListener('change', (e) => {
                if (e.target.classList.contains('category-select') ||
                    e.target.classList.contains('max-value-input')) {
                    console.log('üîÑ Priorit√§t ge√§ndert (change):', e.target.className, e.target.value);
                    this.updatePreview();
                }
            });

            document.getElementById('quotaForm').addEventListener('input', (e) => {
                if (e.target.classList.contains('max-value-input')) {
                    console.log('üîÑ Priorit√§t Input:', e.target.className, e.target.value);
                    this.updatePreview();
                }
            });

            // Save Button
            document.getElementById('saveQuotaBtn').addEventListener('click', () => this.save());
        }

        /**
         * √ñffne Modal f√ºr selektierte Tage
         */
        show(selectedDays) {
            console.log('üéØ Modal.show() aufgerufen mit selectedDays:', selectedDays);
            this.selectedDays = selectedDays;

            // Datum-Bereich anzeigen (YYYY-MM-DD Strings zu lokalen Dates)
            const parseDateString = (dateStr) => {
                console.log('   üìÖ Parse:', dateStr);
                const [year, month, day] = dateStr.split('-').map(Number);
                const parsed = new Date(year, month - 1, day);
                console.log('   ‚Üí Parsed Date:', parsed, 'Display:', parsed.toLocaleDateString('de-DE'));
                return parsed;
            };

            const dates = selectedDays.map(parseDateString);
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            console.log('üìÜ Min:', minDate.toLocaleDateString('de-DE'), 'Max:', maxDate.toLocaleDateString('de-DE'));

            const dateRange = selectedDays.length === 1
                ? minDate.toLocaleDateString('de-DE')
                : `${minDate.toLocaleDateString('de-DE')} - ${maxDate.toLocaleDateString('de-DE')}`;

            console.log('üìã Final dateRange:', dateRange);
            document.getElementById('quotaDateRange').textContent = dateRange + ` (${selectedDays.length} Tage)`;

            // Hole aktuellen Histogram-Target-Wert vom Renderer
            if (this.renderer && this.renderer.histogramTargetValue) {
                const histogramTarget = this.renderer.histogramTargetValue;
                console.log('üéØ √úbernehme Histogram Target:', histogramTarget);
                document.getElementById('targetCapacity').value = histogramTarget;
                document.getElementById('targetCapacityValue').value = histogramTarget;
            }

            // Aktuelle Belegung laden (TODO: Von API holen)
            this.currentOccupancy = 0; // Placeholder
            document.getElementById('currentOccupancy').textContent = this.currentOccupancy;

            // Preview aktualisieren
            this.updatePreview();

            // Modal anzeigen
            this.modal.show();
        }

        /**
         * Helper-Funktion: Liest Max-Wert aus Input-Feld
         * @returns {number} Infinity wenn leer, sonst geparster Wert (auch 0!)
         */
        getMaxValue(elementId) {
            const input = document.getElementById(elementId);
            if (!input || !input.value || input.value === '') return Infinity;
            const val = parseInt(input.value);
            return isNaN(val) ? Infinity : val;
        }


        /**
         * Berechnet Quota-Verteilung nach Priorit√§ten
         * 
         * STRATEGIE:
         * 1. Sammle alle Eingangsvariablen √ºbersichtlich
         * 2. Berechne zu erstellende Quotas pro Kategorie
         * 
         * @param {number} targetCapacity - Ziel-Gesamtkapazit√§t
         * @param {object} occupancy - { av, internal, total }
         * @param {string} dateStr - Datum (YYYY-MM-DD) f√ºr Detail-Analysen
         */
        async calculateQuotaDistribution(targetCapacity, occupancy, dateStr = null) {
            console.log(`\n${'='.repeat(80)}`);
            console.log(`üßÆ QUOTA-BERECHNUNG${dateStr ? ' f√ºr ' + dateStr : ''}`);
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 1: EINGANGSVARIABLEN VORBEREITEN
            // ========================================================================

            // 1.1 Belegung von AV-Reservierungen (av_id > 0, storno = false)
            const avOccupancy = await this.getBookedCategoriesForDate(dateStr, true); // nur AV
            console.log('üì• AV-Belegung (av_id > 0):');
            console.log(`   Sonder: ${avOccupancy.sonder}`);
            console.log(`   Lager:  ${avOccupancy.lager}`);
            console.log(`   Betten: ${avOccupancy.betten}`);
            console.log(`   DZ:     ${avOccupancy.dz}`);
            console.log(`   TOTAL:  ${avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz}\n`);

            // 1.2 Belegung von internen Reservierungen (av_id = 0, storno = false)
            const internalOccupancy = await this.getBookedCategoriesForDate(dateStr, false); // nur Intern
            console.log('üì• Interne Belegung (av_id = 0):');
            console.log(`   Sonder: ${internalOccupancy.sonder}`);
            console.log(`   Lager:  ${internalOccupancy.lager}`);
            console.log(`   Betten: ${internalOccupancy.betten}`);
            console.log(`   DZ:     ${internalOccupancy.dz}`);
            console.log(`   TOTAL:  ${internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz}\n`);

            // 1.3 Aktuelle Quota des Tages (falls vorhanden)
            const currentQuota = await this.getCurrentQuotaForDate(dateStr);
            console.log('üìä Aktuelle Quota des Tages:');
            console.log(`   Free Places: ${currentQuota.freePlaces || 0}`);
            console.log(`   Sonder:      ${currentQuota.sonder}`);
            console.log(`   Lager:       ${currentQuota.lager}`);
            console.log(`   Betten:      ${currentQuota.betten}`);
            console.log(`   DZ:          ${currentQuota.dz}`);
            console.log(`   TOTAL:       ${currentQuota.sonder + currentQuota.lager + currentQuota.betten + currentQuota.dz}\n`);

            // 1.4 HRS Daily Summary Daten werden NICHT mehr geladen (zu viele API-Calls)
            // Die Berechnung basiert nur auf AV + Intern Belegung

            // 1.5 Zielauslastung gesamt
            console.log('üéØ Zielauslastung gesamt: ' + targetCapacity + ' Betten\n');

            // 1.6 Max-Werte f√ºr Kategorien auslesen (fixe Reihenfolge, keine Priorit√§ten!)
            const maxMBZ = this.getMaxValue('max-mbz');
            const max2BZ = this.getMaxValue('max-2bz');
            const maxSK = this.getMaxValue('max-sk');

            console.log('üìã Max-Werte f√ºr Kategorien:');
            console.log(`   MBZ (Betten): ${maxMBZ === Infinity ? '‚àû' : maxMBZ}`);
            console.log(`   2BZ (DZ):     ${max2BZ === Infinity ? '‚àû' : max2BZ}`);
            console.log(`   SK (Sonder):  ${maxSK === Infinity ? '‚àû' : maxSK}`);
            console.log(`   ML (Lager):   REST\n`);

            console.log(`\n${'='.repeat(80)}`);
            console.log('üìê BERECHNUNGSVORBEREITUNG ABGESCHLOSSEN');
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 2: QUOTA-BERECHNUNG - VEREINFACHTE LOGIK
            // ========================================================================

            console.log('üí° QUOTA-FORMEL:\n');

            // 2.1 Berechne Gesamtg√§ste im Haus (AV + Intern)
            const totalGuestsInHouse =
                avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz +
                internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz;

            console.log(`üë• Gesamtg√§ste im Haus: ${totalGuestsInHouse}`);
            console.log(`   (AV: ${avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz} + Intern: ${internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz})\n`);

            // 2.2 Erforderliche Gesamtquota (Qerf)
            // Formel: Qerf = Zielauslastung - Anzahl ALLER G√§ste im Haus
            let Qerf = targetCapacity - totalGuestsInHouse;
            if (Qerf < 0) Qerf = 0;

            console.log(`üìä Erforderliche Gesamtquota (Qerf):`);
            console.log(`   Qerf = ${targetCapacity} (Zielauslastung) - ${totalGuestsInHouse} (G√§ste) = ${Qerf}\n`);

            // 2.3 Quota-Verteilung (EINFACH)
            const result = { lager: 0, betten: 0, dz: 0, sonder: 0 };

            console.log('üéØ Quota-Verteilung:\n');

            // Verteile zuerst MBZ, 2BZ, SK mit ihren Max-Werten
            result.betten = Math.min(maxMBZ, Qerf);
            result.dz = Math.min(max2BZ, Qerf);
            result.sonder = Math.min(maxSK, Qerf);

            console.log(`   MBZ (Betten): ${result.betten} (max ${maxMBZ === Infinity ? '‚àû' : maxMBZ})`);
            console.log(`   2BZ (DZ):     ${result.dz} (max ${max2BZ === Infinity ? '‚àû' : max2BZ})`);
            console.log(`   SK (Sonder):  ${result.sonder} (max ${maxSK === Infinity ? '‚àû' : maxSK})`);

            // ML bekommt den REST
            const usedByOthers = result.betten + result.dz + result.sonder;
            result.lager = Math.max(0, Qerf - usedByOthers);

            console.log(`   ML (Lager):   ${result.lager} (REST: ${Qerf} - ${usedByOthers} = ${result.lager})`);

            const totalQuota = result.sonder + result.lager + result.betten + result.dz;
            console.log(`   TOTAL:        ${totalQuota} (sollte ${Qerf} sein)`);
            console.log(`${'='.repeat(80)}\n`);

            return result;
        }

        /**
         * Aktualisiert Live-Preview - berechnet f√ºr JEDEN TAG individuell
         */
        async updatePreview() {
            console.log('üîÑ updatePreview() START');
            const targetCapacity = parseInt(document.getElementById('targetCapacity').value);
            const previewContainer = document.getElementById('quotaPreviewDays');
            console.log('üì¶ previewContainer:', previewContainer);
            console.log('üéØ targetCapacity:', targetCapacity);
            console.log('üìÖ selectedDays:', this.selectedDays);

            let hasOverbooking = false;
            const tableData = [];

            // Sammle Daten f√ºr alle Tage
            console.log('üîÑ Starte Datensammlung f√ºr', this.selectedDays.length, 'Tage...');
            for (const dateStr of this.selectedDays) {
                console.log('  üìÖ Verarbeite Tag:', dateStr);
                // Berechne Quota-Verteilung (diese Funktion holt sich intern die Belegungen)
                const quotas = await this.calculateQuotaDistribution(targetCapacity, null, dateStr);
                console.log('  ‚úÖ Quotas berechnet:', quotas);

                // Hole Belegungsdaten f√ºr die Anzeige
                const occupancy = await this.getOccupancyForDate(dateStr);

                // Parse Datum
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dateDisplay = date.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit', month: '2-digit', year: 'numeric' });

                // Berechne Gesamtg√§ste
                const totalGuests = occupancy.av + occupancy.internal;
                const availableQuota = Math.max(0, targetCapacity - totalGuests);

                if (availableQuota <= 0) {
                    hasOverbooking = true;
                }

                tableData.push({
                    date: dateDisplay,
                    av: occupancy.av,
                    internal: occupancy.internal,
                    total: totalGuests,
                    quota: availableQuota,
                    ml: quotas.lager,
                    mbz: quotas.betten,
                    bz2: quotas.dz,
                    sk: quotas.sonder,
                    totalQuota: quotas.lager + quotas.betten + quotas.dz + quotas.sonder,
                    isOverbooked: availableQuota <= 0
                });
            }

            // Erstelle Excel-Style Tabelle
            let html = `
                <div style="overflow-x: auto;">
                    <table class="table table-sm table-bordered table-hover" style="font-size: 0.85em; margin: 0;">
                        <thead class="table-dark" style="position: sticky; top: 0; z-index: 10;">
                            <tr>
                                <th style="min-width: 130px;">Datum</th>
                                <th class="text-center" style="min-width: 50px;" title="AV-Reservierungen">AV</th>
                                <th class="text-center" style="min-width: 50px;" title="Interne Reservierungen">Int</th>
                                <th class="text-center" style="min-width: 60px;" title="Gesamt G√§ste">Total</th>
                                <th class="text-center" style="min-width: 60px; background-color: #2d5a3f;" title="Erforderliche Gesamtquota">Qerf</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">ML</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">MBZ</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">2BZ</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">SK</th>
                                <th class="text-center" style="min-width: 60px; background-color: #2d5a3f;" title="Summe Quotas">Œ£</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            for (const row of tableData) {
                const rowClass = row.isOverbooked ? 'table-danger' : '';
                const quotaClass = row.quota > 0 ? 'text-success fw-bold' : 'text-danger';

                html += `
                    <tr class="${rowClass}">
                        <td><strong>${row.date}</strong></td>
                        <td class="text-center">${row.av}</td>
                        <td class="text-center">${row.internal}</td>
                        <td class="text-center"><strong>${row.total}</strong></td>
                        <td class="text-center ${quotaClass}"><strong>${row.quota}</strong></td>
                        <td class="text-center ${row.ml > 0 ? 'bg-success bg-opacity-25' : ''}">${row.ml}</td>
                        <td class="text-center ${row.mbz > 0 ? 'bg-success bg-opacity-25' : ''}">${row.mbz}</td>
                        <td class="text-center ${row.bz2 > 0 ? 'bg-success bg-opacity-25' : ''}">${row.bz2}</td>
                        <td class="text-center ${row.sk > 0 ? 'bg-success bg-opacity-25' : ''}">${row.sk}</td>
                        <td class="text-center"><strong>${row.totalQuota}</strong></td>
                    </tr>
                `;
            }

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            console.log('üìä TableData:', tableData);
            console.log('üìù HTML Length:', html.length);
            console.log('üéØ Setting innerHTML...');
            previewContainer.innerHTML = html;
            console.log('‚úÖ innerHTML gesetzt! previewContainer.children:', previewContainer.children.length);

            // Overbooking Warning
            const warning = document.getElementById('overbookingWarning');
            if (hasOverbooking) {
                warning.classList.remove('d-none');
            } else {
                warning.classList.add('d-none');
            }
        }


        /**
         * Hole aktuelle Belegung f√ºr ein bestimmtes Datum
         * Unterscheidet zwischen AV-Reservierungen (av_id > 0) und internen (av_id = 0)
         * WICHTIG: Z√§hlt ALLE Betten (lager + betten + dz + sonder)!
         */
        async getOccupancyForDate(dateStr) {
            let avReservations = 0;      // Reservierungen VOM AV-System (av_id > 0)
            let internalReservations = 0; // Interne Reservierungen (av_id = 0)

            if (!this.renderer) {
                console.error('‚ùå renderer nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            const { startDate, endDate } = this.renderer.getTimelineDateRange();
            const histogramData = this.renderer.getHistogramData(startDate, endDate);

            if (!histogramData || !histogramData.dailyDetails) {
                console.error('‚ùå histogramData nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            // Berechne Day-Index aus dateStr
            const date = new Date(dateStr);
            const dayIndex = Math.floor((date - startDate) / (1000 * 60 * 60 * 24));

            const detail = histogramData.dailyDetails[dayIndex];

            if (detail) {
                // Hole Reservierungen aus histogramSource f√ºr dieses Datum
                if (window.histogramSource) {
                    const reservationsForDate = window.histogramSource.filter(res => {
                        const resStart = res.anreise || res.start_date || res.start;
                        const resEnd = res.abreise || res.end_date || res.end;
                        return resStart && resEnd && resStart <= dateStr && dateStr < resEnd;
                    });

                    reservationsForDate.forEach(res => {
                        // Z√§hle ALLE Betten (nicht nur Personen!)
                        const details = res.capacity_details || {};
                        const totalBeds = parseInt(details.lager || 0) +
                            parseInt(details.betten || 0) +
                            parseInt(details.dz || 0) +
                            parseInt(details.sonder || 0);

                        if (res.av_id && res.av_id > 0) {
                            avReservations += totalBeds;
                        } else {
                            internalReservations += totalBeds;
                        }
                    });
                }

                const total = avReservations + internalReservations;
                console.log(`üìä ${dateStr} (dayIndex ${dayIndex}): AV=${avReservations} Betten, Intern=${internalReservations} Betten, Total=${total}`);
            } else {
                console.warn(`‚ö†Ô∏è Kein dailyDetail f√ºr ${dateStr} (dayIndex ${dayIndex})`);
            }

            return { av: avReservations, internal: internalReservations, total: avReservations + internalReservations };
        }

        /**
         * Hole bereits gebuchte AV-Kategorien f√ºr ein bestimmtes Datum
         * WICHTIG: Nur Reservierungen mit av_id > 0 z√§hlen!
```        /**
         * Hole bereits gebuchte Kategorien f√ºr ein bestimmtes Datum
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @param {boolean} onlyAV - true = nur AV-Reservierungen (av_id > 0), false = nur Intern (av_id = 0)
         * @returns {object} - { sonder, lager, betten, dz }
         */
        async getBookedCategoriesForDate(dateStr, onlyAV = true) {
            const booked = { sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !window.histogramSource) {
                return booked;
            }

            // Filtere Reservierungen f√ºr dieses Datum
            const reservationsForDate = window.histogramSource.filter(res => {
                // Filter nach AV oder Intern
                if (onlyAV) {
                    if (!res.av_id || res.av_id <= 0) return false; // Nur AV-Reservierungen
                } else {
                    if (res.av_id && res.av_id > 0) return false; // Nur interne Reservierungen
                }

                // Pr√ºfe ob Datum im Reservierungs-Zeitraum liegt
                const resStart = res.anreise || res.start_date || res.start;
                const resEnd = res.abreise || res.end_date || res.end;

                return dateStr >= resStart && dateStr < resEnd;
            });

            // Z√§hle nach Kategorien (aus capacity_details)
            reservationsForDate.forEach(res => {
                const details = res.capacity_details || {};

                booked.sonder += parseInt(details.sonder || 0);
                booked.lager += parseInt(details.lager || 0);
                booked.betten += parseInt(details.betten || 0);
                booked.dz += parseInt(details.dz || 0);
            });

            return booked;
        }

        /**
         * Hole aktuelle Quota f√ºr ein bestimmtes Datum (falls bereits gesetzt)
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { freePlaces, sonder, lager, betten, dz }
         */
        async getCurrentQuotaForDate(dateStr) {
            const quota = { freePlaces: 0, sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !this.renderer) {
                return quota;
            }

            const { startDate } = this.renderer.getTimelineDateRange();
            const date = new Date(dateStr);
            const dayIndex = Math.floor((date - startDate) / (1000 * 60 * 60 * 24));

            // Hole Availability-Daten (enth√§lt Quota-Informationen)
            const histogramData = this.renderer.getHistogramData(startDate, new Date(dateStr));

            if (histogramData && histogramData.availabilityData && histogramData.availabilityData[dayIndex]) {
                const avData = histogramData.availabilityData[dayIndex];

                quota.freePlaces = avData.free_places || 0;
                quota.sonder = avData.quota_sonder || 0;
                quota.lager = avData.quota_lager || 0;
                quota.betten = avData.quota_betten || 0;
                quota.dz = avData.quota_dz || 0;
            }

            return quota;
        }

        /**
         * Hole HRS Daily Summary Daten f√ºr ein bestimmtes Datum
         * Diese Daten sind ESSENTIELL f√ºr die korrekte Quota-Berechnung!
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { totalGuests, categories: { lager, betten, dz, sonder } }
         */
        async getDailySummaryForDate(dateStr) {
            const result = {
                totalGuests: 0,
                categories: {
                    lager: { freePlaces: 0, assigned: 0 },
                    betten: { freePlaces: 0, assigned: 0 },
                    dz: { freePlaces: 0, assigned: 0 },
                    sonder: { freePlaces: 0, assigned: 0 }
                }
            };

            if (!dateStr) {
                return result;
            }

            try {
                // Lade Daily Summary aus DB via API
                const response = await fetch(`/wci/zp/getDailySummary.php?date=${dateStr}`);
                if (!response.ok) {
                    console.warn(`‚ö†Ô∏è getDailySummary failed: ${response.status}`);
                    return result;
                }

                const data = await response.json();

                if (data.success && data.data) {
                    result.totalGuests = data.data.total_guests || 0;

                    // Mappe Kategorien
                    const categoryMap = {
                        'ML': 'lager',
                        'MBZ': 'betten',
                        '2BZ': 'dz',
                        'SK': 'sonder'
                    };

                    if (data.data.categories) {
                        data.data.categories.forEach(cat => {
                            const mappedName = categoryMap[cat.category_type];
                            if (mappedName) {
                                result.categories[mappedName] = {
                                    freePlaces: parseInt(cat.free_places || 0),
                                    assigned: parseInt(cat.assigned_guests || 0)
                                };
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('‚ùå Error loading daily summary:', error);
            }

            return result;
        }

        /**
         * Validierung
         */
        validate() {
            // Einfache Validierung: Pr√ºfe ob targetCapacity gesetzt ist
            const targetCapacity = parseInt(document.getElementById('targetCapacity').value);

            if (!targetCapacity || targetCapacity <= 0) {
                alert('‚ùå Fehler: Zielauslastung muss gr√∂√üer als 0 sein!');
                return false;
            }

            // Pr√ºfe ob Tage selektiert sind
            if (!this.selectedDays || this.selectedDays.length === 0) {
                alert('‚ùå Fehler: Keine Tage ausgew√§hlt!');
                return false;
            }

            return true;
        }

        /**
         * Speichert Quotas via API
         */
        async save() {
            if (!this.validate()) return;

            const saveBtn = document.getElementById('saveQuotaBtn');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '‚è≥ Speichern...';

            try {
                const targetCapacity = parseInt(document.getElementById('targetCapacityValue').value) || 0;

                // Berechne f√ºr jeden Tag individuell
                const dailyQuotas = [];
                for (const dateStr of this.selectedDays) {
                    // 1. Berechne die neuen Quota-Werte (Q_berechnet)
                    const calculatedQuotas = await this.calculateQuotaDistribution(targetCapacity, null, dateStr);

                    // 2. Hole bereits gebuchte AV-G√§ste pro Kategorie (assigned_guests)
                    const assignedGuestsAV = await this.getBookedCategoriesForDate(dateStr, true);

                    // 3. WICHTIG: Berechne die zu schreibenden Werte f√ºr HRS
                    // Formel: Q_write = assigned_guests + Q_berechnet
                    const quotasToWrite = {
                        lager: assignedGuestsAV.lager + calculatedQuotas.lager,
                        betten: assignedGuestsAV.betten + calculatedQuotas.betten,
                        dz: assignedGuestsAV.dz + calculatedQuotas.dz,
                        sonder: assignedGuestsAV.sonder + calculatedQuotas.sonder
                    };

                    console.log(`üìä ${dateStr}:`);
                    console.log(`   Assigned AV: L=${assignedGuestsAV.lager}, B=${assignedGuestsAV.betten}, DZ=${assignedGuestsAV.dz}, S=${assignedGuestsAV.sonder}`);
                    console.log(`   Calculated Q: L=${calculatedQuotas.lager}, B=${calculatedQuotas.betten}, DZ=${calculatedQuotas.dz}, S=${calculatedQuotas.sonder}`);
                    console.log(`   ‚Üí Write to HRS: L=${quotasToWrite.lager}, B=${quotasToWrite.betten}, DZ=${quotasToWrite.dz}, S=${quotasToWrite.sonder}`);

                    dailyQuotas.push({
                        date: dateStr,
                        quota_lager: quotasToWrite.lager,
                        quota_betten: quotasToWrite.betten,
                        quota_dz: quotasToWrite.dz,
                        quota_sonder: quotasToWrite.sonder,
                        targetCapacity: targetCapacity
                    });
                }

                // API Call
                const requestBody = {
                    quotas: dailyQuotas,
                    operation: 'update'
                };

                console.log('üì§ Sending to HRS API:', requestBody);

                const response = await fetch('/wci/hrs/hrs_write_quota_v3.php?v=20251011_v3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('üì• Response status:', response.status);

                // Read response as text first
                const responseText = await response.text();
                console.log('üìÑ Response body (first 500 chars):', responseText.substring(0, 500));

                // Check if response is JSON
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (e) {
                    console.error('‚ùå JSON Parse Error:', e.message);
                    console.error('üìÑ Full response:', responseText);
                    throw new Error('Server returned invalid JSON. Response: ' + responseText.substring(0, 200));
                }

                if (!response.ok) {
                    console.error('‚ùå API Error Response:', result);
                    throw new Error(result.error || result.message || 'Unknown server error');
                }

                if (result.success) {
                    const createdCount = Array.isArray(result.createdQuotas) ? result.createdQuotas.length : 0;
                    const deletedCount = Array.isArray(result.deletedQuotas) ? result.deletedQuotas.length : 0;

                    alert(`‚úÖ Erfolg!\n\n${result.message}\n\nErstellt: ${createdCount} Quotas\nGel√∂scht: ${deletedCount} Quotas`);

                    // Timeline neu laden
                    if (this.renderer && typeof this.renderer.reloadHistogramData === 'function') {
                        await this.renderer.reloadHistogramData();
                    }

                    this.modal.hide();
                } else {
                    alert(`‚ùå Fehler beim Speichern:\n\n${result.error}`);
                }

            } catch (error) {
                console.error('Quota save error:', error);
                alert(`‚ùå Netzwerkfehler:\n\n${error.message}`);
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'üíæ Speichern';
            }
        }
    }

    // Globale Instanz erstellen (wird von timeline-unified.js genutzt)
    window.quotaInputModal = null;

    // Initialisierungs-Funktion (wird nach dem Laden des HTML aufgerufen)
    window.initQuotaInputModal = function () {
        console.log('üìã initQuotaInputModal aufgerufen');

        // Warte auf renderer-Initialisierung
        const checkRenderer = setInterval(() => {
            if (typeof window.renderer !== 'undefined' && window.renderer) {
                window.quotaInputModal = new QuotaInputModal(window.renderer);
                console.log('‚úÖ Quota Input Modal initialized mit renderer:', window.renderer);
                clearInterval(checkRenderer);
            } else {
                console.log('‚è≥ Warte auf window.renderer...');
            }
        }, 100);

        // Timeout nach 10 Sekunden
        setTimeout(() => {
            if (!window.quotaInputModal) {
                console.warn('‚ö†Ô∏è Quota Modal konnte nicht initialisiert werden - renderer nicht gefunden');
                console.log('window.renderer ist:', window.renderer);
            }
        }, 10000);
    };

    // Wenn DOMContentLoaded schon vorbei ist (bei dynamischem Laden), sofort initialisieren
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.initQuotaInputModal);
    } else {
        // DOM ist bereits bereit, sofort initialisieren
        window.initQuotaInputModal();
    }
</script>