<!-- ==================== QUOTA INPUT MODAL V3.0 ==================== -->
<!-- Multi-Day Quota Support - MANAGEMENT API (BEW√ÑHRT!) -->
<script>
    console.log('üîÑ Quota Modal V3.0 loaded - Management API');
    console.log('üìç Using endpoint: /wci/hrs/hrs_write_quota_v3.php');
    console.log('üîß API: /api/v1/manage/hutQuota/{hutId} (BEW√ÑHRT wie hrs_del_quota_batch.php)');
</script>
<style>
    /* Custom Modal Breite: 2,5x breiter als modal-xl */
    #quotaInputModal .modal-dialog {
        max-width: 95vw !important;
        width: 95vw !important;
    }

    #quotaInputModal .modal-body {
        max-height: 80vh;
        overflow-y: auto;
    }

    /* Tabelle responsiv */
    #quotaInputModal table {
        width: 100%;
        white-space: nowrap;
    }
</style>

<div class="modal fade" id="quotaInputModal" tabindex="-1" aria-labelledby="quotaInputModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="quotaInputModalLabel">üìä Quota bearbeiten</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="quotaForm">
                    <!-- Zeitraum Anzeige -->
                    <div class="alert alert-info mb-4">
                        <strong>Selektierte Tage:</strong> <span id="quotaDateRange"></span><br>
                        <strong>Aktuelle Belegung:</strong> <span id="currentOccupancy">--</span> Pl√§tze
                    </div>

                    <!-- Zielkapazit√§t -->
                    <div class="mb-4">
                        <label for="targetCapacity" class="form-label">
                            <strong>Zielauslastung (Gesamt)</strong>
                        </label>
                        <div class="row align-items-center">
                            <div class="col-9">
                                <input type="range" class="form-range" id="targetCapacity" min="0" max="200" value="28"
                                    step="5">
                            </div>
                            <div class="col-3">
                                <input type="number" class="form-control" id="targetCapacityValue" min="0" max="200"
                                    value="28" step="5">
                            </div>
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Kategorie-Verteilung (fix, ohne Priorit√§ten) -->
                    <h6 class="mb-3">Kategorie-Verteilung</h6>

                    <!-- ML (Lager) - bekommt immer den REST -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>ML - Matratzenlager</strong>
                        </div>
                        <div class="col-6">
                            <input type="text" class="form-control" value="(bekommt REST)" disabled readonly
                                style="background-color: #d1ecf1; color: #0c5460; font-weight: bold;">
                        </div>
                    </div>

                    <!-- MBZ (Betten) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>MBZ - Mehrbettzimmer</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="betten" id="max-mbz">
                        </div>
                    </div>

                    <!-- 2BZ (DZ) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>2BZ - Zweibettzimmer</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="dz" id="max-2bz">
                        </div>
                    </div>

                    <!-- SK (Sonder) - Max-Wert -->
                    <div class="row mb-3 align-items-center">
                        <div class="col-6">
                            <strong>SK - Sonderkategorie</strong>
                        </div>
                        <div class="col-6">
                            <input type="number" class="form-control max-value-input" placeholder="0 = keine" value="0"
                                min="0" data-category="sonder" id="max-sk">
                        </div>
                    </div>

                    <hr class="my-4">

                    <!-- Live-Preview berechneter Quotas -->
                    <div class="alert alert-success" id="quotaPreview">
                        <h6 class="mb-3">üìä Berechnete Quotas (pro Tag):</h6>
                        <div id="quotaPreviewDays">
                            <!-- Wird dynamisch gef√ºllt mit Quotas f√ºr jeden Tag -->
                        </div>
                    </div>

                    <!-- Warnung bei √úberbelegung -->
                    <div class="alert alert-warning d-none" id="overbookingWarning">
                        ‚ö†Ô∏è <strong>Warnung:</strong> Bei einigen Tagen √ºberschreitet die Belegung die Zielkapazit√§t!<br>
                        F√ºr diese Tage werden alle Quotas auf 0 gesetzt.
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="saveQuotaBtn">üíæ Speichern</button>
            </div>
        </div>
    </div>
</div>

<!-- Status Modal -->
<div class="modal fade" id="quotaStatusModal" tabindex="-1" aria-labelledby="quotaStatusModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="quotaStatusModalLabel">Quota Deploy</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="progress mb-3">
                    <div class="progress-bar" role="progressbar" style="width: 0%" aria-valuemin="0" aria-valuemax="100"
                        data-role="quota-status-progress"></div>
                </div>
                <ul class="list-group" data-role="quota-status-steps"></ul>
                <div class="alert mt-3 d-none" role="alert" data-role="quota-status-summary"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" data-role="quota-status-close"
                    disabled>Schlie√üen</button>
            </div>
        </div>
    </div>
</div>

<script>
    /**
     * Quota Input Modal Manager
     * =========================
     * Verwaltet das Quota-Eingabe-Modal mit Priorit√§ts-basierter Verteilung
     */
    class QuotaInputModal {
        constructor(renderer) {
            this.renderer = renderer;
            this.modal = new bootstrap.Modal(document.getElementById('quotaInputModal'));
            this.selectedDays = [];
            this.currentOccupancy = 0;
            this.lastTargetCapacityFineAdjust = false;
            this.statusModal = null;
            this.statusModalInstance = null;
            this.statusProgressBar = null;
            this.statusStepsContainer = null;
            this.statusSummary = null;
            this.statusCloseBtn = null;
            this.statusSteps = [];

            this.initializeEventListeners();
            this.initializeStatusModal();

            // WICHTIG: Verhindere Browser-Kontextmen√º im Modal
            const modalElement = document.getElementById('quotaInputModal');
            modalElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }, { capture: true });
        }

        initializeStatusModal() {
            this.statusModal = document.getElementById('quotaStatusModal');
            if (!this.statusModal) {
                console.warn('Quota status modal not found. Falling back to alerts.');
                return;
            }

            this.statusModalInstance = new bootstrap.Modal(this.statusModal, {
                backdrop: 'static',
                keyboard: false
            });
            this.statusProgressBar = this.statusModal.querySelector('[data-role="quota-status-progress"]');
            this.statusStepsContainer = this.statusModal.querySelector('[data-role="quota-status-steps"]');
            this.statusSummary = this.statusModal.querySelector('[data-role="quota-status-summary"]');
            this.statusCloseBtn = this.statusModal.querySelector('[data-role="quota-status-close"]');

            this.statusModal.addEventListener('hidden.bs.modal', () => {
                this.resetStatusModal();
            });
        }

        resetStatusModal() {
            if (!this.statusModal) return;

            if (this.statusStepsContainer) {
                this.statusStepsContainer.innerHTML = '';
            }

            if (this.statusProgressBar) {
                this.statusProgressBar.style.width = '0%';
                this.statusProgressBar.classList.remove('bg-danger', 'bg-warning');
                this.statusProgressBar.classList.add('bg-success');
            }

            if (this.statusSummary) {
                this.statusSummary.textContent = '';
                this.statusSummary.classList.add('d-none');
                this.statusSummary.classList.remove('alert-success', 'alert-warning', 'alert-danger');
            }

            if (this.statusCloseBtn) {
                this.statusCloseBtn.disabled = true;
            }

            this.statusSteps = [];
        }

        startStatusWorkflow(stepLabels = []) {
            if (!this.statusModalInstance) {
                return false;
            }

            const steps = stepLabels.length ? stepLabels : [
                'Sende Daten an HRS',
                'Quotas schreiben',
                'Import aktualisieren'
            ];

            this.resetStatusModal();

            this.statusSteps = steps.map(label => ({
                label,
                state: 'pending',
                element: null
            }));

            const fragment = document.createDocumentFragment();
            this.statusSteps.forEach((step, index) => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.dataset.index = index;

                const labelSpan = document.createElement('span');
                labelSpan.className = 'status-label';
                labelSpan.textContent = step.label;

                const badge = document.createElement('span');
                badge.className = 'badge bg-secondary rounded-pill status-pill';
                badge.textContent = 'Wartet';

                li.appendChild(labelSpan);
                li.appendChild(badge);
                fragment.appendChild(li);
                step.element = li;
            });

            if (this.statusStepsContainer) {
                this.statusStepsContainer.appendChild(fragment);
            }

            this.statusModalInstance.show();
            this.setStatusStep(0, 'active');
            return true;
        }

        updateStatusProgress() {
            if (!this.statusProgressBar || !this.statusSteps.length) return;
            const completed = this.statusSteps.filter(step => step.state === 'success').length;
            const total = this.statusSteps.length;
            const percent = Math.max(5, Math.round((completed / total) * 100));
            this.statusProgressBar.style.width = `${percent}%`;
        }

        setStatusStep(index, state, detail = '') {
            if (!this.statusSteps[index]) return;
            const step = this.statusSteps[index];
            step.state = state;

            const li = step.element;
            if (!li) return;

            const badge = li.querySelector('.status-pill');

            li.classList.remove('list-group-item-warning', 'list-group-item-success', 'list-group-item-danger', 'list-group-item-info');
            if (badge) {
                badge.classList.remove('bg-secondary', 'bg-info', 'bg-success', 'bg-danger');
            }

            switch (state) {
                case 'active':
                    li.classList.add('list-group-item-info');
                    if (badge) {
                        badge.classList.add('bg-info');
                        badge.textContent = 'Aktiv';
                    }
                    break;
                case 'success':
                    li.classList.add('list-group-item-success');
                    if (badge) {
                        badge.classList.add('bg-success');
                        badge.textContent = 'Fertig';
                    }
                    break;
                case 'error':
                    li.classList.add('list-group-item-danger');
                    if (badge) {
                        badge.classList.add('bg-danger');
                        badge.textContent = 'Fehler';
                    }
                    break;
                default:
                    if (badge) {
                        badge.classList.add('bg-secondary');
                        badge.textContent = 'Wartet';
                    }
                    break;
            }

            if (detail && li.querySelector('.status-detail')) {
                li.querySelector('.status-detail').textContent = detail;
            } else if (detail) {
                const detailSpan = document.createElement('div');
                detailSpan.className = 'status-detail small mt-1 text-muted';
                detailSpan.textContent = detail;
                li.appendChild(detailSpan);
            }

            if (state === 'error' && this.statusProgressBar) {
                this.statusProgressBar.classList.remove('bg-success');
                this.statusProgressBar.classList.add('bg-danger');
            }

            this.updateStatusProgress();
        }

        completeStatusWorkflow(success, summaryText, autoClose = true) {
            if (!this.statusModalInstance) return;

            if (this.statusProgressBar) {
                this.statusProgressBar.style.width = '100%';
                this.statusProgressBar.classList.remove('bg-danger');
                this.statusProgressBar.classList.add(success ? 'bg-success' : 'bg-warning');
            }

            if (this.statusSummary) {
                this.statusSummary.textContent = summaryText || '';
                this.statusSummary.classList.remove('d-none', 'alert-warning', 'alert-danger', 'alert-success');
                this.statusSummary.classList.add(success ? 'alert-success' : 'alert-warning');
            }

            if (this.statusCloseBtn) {
                this.statusCloseBtn.disabled = false;
            }

            if (autoClose && success) {
                setTimeout(() => {
                    try {
                        this.statusModalInstance.hide();
                    } catch (err) {
                        console.warn('Status modal hide failed:', err);
                    }
                }, 1200);
            }
        }

        failStatusWorkflow(errorMessage) {
            if (!this.statusModalInstance) return;
            let targetIndex = this.statusSteps.findIndex(step => step.state === 'active');
            if (targetIndex === -1) {
                targetIndex = this.statusSteps.length ? this.statusSteps.length - 1 : 0;
            }
            this.setStatusStep(targetIndex, 'error', errorMessage);

            if (this.statusProgressBar) {
                this.statusProgressBar.classList.remove('bg-success');
                this.statusProgressBar.classList.add('bg-danger');
            }

            if (this.statusSummary) {
                this.statusSummary.textContent = errorMessage;
                this.statusSummary.classList.remove('d-none', 'alert-success', 'alert-warning');
                this.statusSummary.classList.add('alert-danger');
            }

            if (this.statusCloseBtn) {
                this.statusCloseBtn.disabled = false;
            }
        }

        initializeEventListeners() {
            // Slider <-> Input Sync
            const slider = document.getElementById('targetCapacity');
            const input = document.getElementById('targetCapacityValue');

            slider.addEventListener('input', () => {
                this.lastTargetCapacityFineAdjust = false;
                input.value = slider.value;
                this.updatePreview();
            });

            input.addEventListener('input', () => {
                this.lastTargetCapacityFineAdjust = false;

                if (input.value === '') {
                    return;
                }

                let numericValue = parseInt(input.value, 10);
                if (isNaN(numericValue)) {
                    return;
                }

                const min = parseInt(slider.min, 10) || 0;
                const max = parseInt(slider.max, 10) || 0;
                numericValue = Math.max(min, Math.min(max, numericValue));

                slider.value = numericValue;
                if (numericValue !== parseInt(input.value, 10)) {
                    input.value = numericValue;
                }
                this.updatePreview();
            });

            input.addEventListener('change', () => {
                let numericValue = parseInt(input.value, 10);
                const min = parseInt(slider.min, 10) || 0;
                const max = parseInt(slider.max, 10) || 0;

                if (isNaN(numericValue)) {
                    numericValue = min;
                }

                numericValue = Math.max(min, Math.min(max, numericValue));

                if (!this.lastTargetCapacityFineAdjust && numericValue % 5 !== 0) {
                    numericValue = Math.round(numericValue / 5) * 5;
                }

                numericValue = Math.max(min, Math.min(max, numericValue));

                slider.value = numericValue;
                input.value = numericValue;
                this.lastTargetCapacityFineAdjust = false;
                this.updatePreview();
            });

            const handleTargetCapacityKey = (event) => {
                const increaseKeys = ['ArrowUp', 'ArrowRight'];
                const decreaseKeys = ['ArrowDown', 'ArrowLeft'];
                if (!increaseKeys.includes(event.key) && !decreaseKeys.includes(event.key)) {
                    return;
                }

                if (event.ctrlKey) {
                    event.preventDefault();
                    const delta = increaseKeys.includes(event.key) ? 1 : -1;
                    this.adjustTargetCapacity(delta, true);
                }
            };

            slider.addEventListener('keydown', handleTargetCapacityKey);
            input.addEventListener('keydown', handleTargetCapacityKey);

            // Event-Delegation f√ºr Priorit√§ten (funktioniert auch nach DOM-Updates)
            document.getElementById('quotaForm').addEventListener('change', (e) => {
                if (e.target.classList.contains('category-select') ||
                    e.target.classList.contains('max-value-input')) {
                    console.log('üîÑ Priorit√§t ge√§ndert (change):', e.target.className, e.target.value);
                    this.updatePreview();
                }
            });

            document.getElementById('quotaForm').addEventListener('input', (e) => {
                if (e.target.classList.contains('max-value-input')) {
                    console.log('üîÑ Priorit√§t Input:', e.target.className, e.target.value);
                    this.updatePreview();
                }
            });

            // Save Button
            document.getElementById('saveQuotaBtn').addEventListener('click', () => this.save());
        }

        adjustTargetCapacity(delta, fineAdjust = false) {
            const slider = document.getElementById('targetCapacity');
            const input = document.getElementById('targetCapacityValue');
            if (!slider || !input) {
                return;
            }

            const min = parseInt(slider.min, 10) || 0;
            const max = parseInt(slider.max, 10) || 0;
            let current = parseInt(slider.value, 10);
            if (isNaN(current)) {
                current = min;
            }

            let nextValue;
            if (fineAdjust) {
                nextValue = current + delta;
            } else {
                const baseStep = 5;
                const direction = delta === 0 ? 0 : (delta > 0 ? 1 : -1);
                if (direction > 0) {
                    nextValue = Math.floor(current / baseStep) * baseStep + baseStep;
                } else if (direction < 0) {
                    nextValue = Math.ceil(current / baseStep) * baseStep - baseStep;
                } else {
                    nextValue = Math.round(current / baseStep) * baseStep;
                }
            }

            nextValue = Math.max(min, Math.min(max, nextValue));

            if (nextValue === current) {
                this.lastTargetCapacityFineAdjust = fineAdjust;
                return;
            }

            slider.value = nextValue;
            input.value = nextValue;
            this.lastTargetCapacityFineAdjust = fineAdjust;
            this.updatePreview();
        }

        /**
         * √ñffne Modal f√ºr selektierte Tage
         */
        show(selectedDays) {
            console.log('üéØ Modal.show() aufgerufen mit selectedDays:', selectedDays);
            this.selectedDays = selectedDays;
            this.lastTargetCapacityFineAdjust = false;

            // Datum-Bereich anzeigen (YYYY-MM-DD Strings zu lokalen Dates)
            const parseDateString = (dateStr) => {
                console.log('   üìÖ Parse:', dateStr);
                const [year, month, day] = dateStr.split('-').map(Number);
                const parsed = new Date(year, month - 1, day);
                console.log('   ‚Üí Parsed Date:', parsed, 'Display:', parsed.toLocaleDateString('de-DE'));
                return parsed;
            };

            const dates = selectedDays.map(parseDateString);
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            console.log('üìÜ Min:', minDate.toLocaleDateString('de-DE'), 'Max:', maxDate.toLocaleDateString('de-DE'));

            const dateRange = selectedDays.length === 1
                ? minDate.toLocaleDateString('de-DE')
                : `${minDate.toLocaleDateString('de-DE')} - ${maxDate.toLocaleDateString('de-DE')}`;

            console.log('üìã Final dateRange:', dateRange);
            document.getElementById('quotaDateRange').textContent = dateRange + ` (${selectedDays.length} Tage)`;

            // Hole aktuellen Histogram-Target-Wert vom Renderer
            if (this.renderer && this.renderer.histogramTargetValue) {
                const histogramTarget = this.renderer.histogramTargetValue;
                console.log('üéØ √úbernehme Histogram Target:', histogramTarget);
                document.getElementById('targetCapacity').value = histogramTarget;
                document.getElementById('targetCapacityValue').value = histogramTarget;
                this.lastTargetCapacityFineAdjust = histogramTarget % 5 !== 0;
            }

            // Aktuelle Belegung laden (TODO: Von API holen)
            this.currentOccupancy = 0; // Placeholder
            document.getElementById('currentOccupancy').textContent = this.currentOccupancy;

            // Preview aktualisieren
            this.updatePreview();

            // Modal anzeigen
            this.modal.show();
        }

        /**
         * Helper-Funktion: Liest Max-Wert aus Input-Feld
         * @returns {number} Infinity wenn leer, sonst geparster Wert (auch 0!)
         */
        getMaxValue(elementId) {
            const input = document.getElementById(elementId);
            if (!input || !input.value || input.value === '') return Infinity;
            const val = parseInt(input.value);
            return isNaN(val) ? Infinity : val;
        }


        /**
         * Berechnet Quota-Verteilung nach Priorit√§ten
         * 
         * STRATEGIE:
         * 1. Sammle alle Eingangsvariablen √ºbersichtlich
         * 2. Berechne zu erstellende Quotas pro Kategorie
         * 
         * @param {number} targetCapacity - Ziel-Gesamtkapazit√§t
         * @param {object} occupancy - { av, internal, total }
         * @param {string} dateStr - Datum (YYYY-MM-DD) f√ºr Detail-Analysen
         */
        async calculateQuotaDistribution(targetCapacity, occupancy, dateStr = null) {
            console.log(`\n${'='.repeat(80)}`);
            console.log(`üßÆ QUOTA-BERECHNUNG${dateStr ? ' f√ºr ' + dateStr : ''}`);
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 1: EINGANGSVARIABLEN VORBEREITEN
            // ========================================================================

            // 1.1 Belegung von AV-Reservierungen (av_id > 0, storno = false)
            const avOccupancy = await this.getBookedCategoriesForDate(dateStr, true); // nur AV
            console.log('üì• AV-Belegung (av_id > 0):');
            console.log(`   Sonder: ${avOccupancy.sonder}`);
            console.log(`   Lager:  ${avOccupancy.lager}`);
            console.log(`   Betten: ${avOccupancy.betten}`);
            console.log(`   DZ:     ${avOccupancy.dz}`);
            console.log(`   TOTAL:  ${avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz}\n`);

            // 1.2 Belegung von internen Reservierungen (av_id = 0, storno = false)
            const internalOccupancy = await this.getBookedCategoriesForDate(dateStr, false); // nur Intern
            console.log('üì• Interne Belegung (av_id = 0):');
            console.log(`   Sonder: ${internalOccupancy.sonder}`);
            console.log(`   Lager:  ${internalOccupancy.lager}`);
            console.log(`   Betten: ${internalOccupancy.betten}`);
            console.log(`   DZ:     ${internalOccupancy.dz}`);
            console.log(`   TOTAL:  ${internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz}\n`);

            // 1.3 Aktuelle Quota des Tages (falls vorhanden)
            const currentQuota = await this.getCurrentQuotaForDate(dateStr);
            console.log('üìä Aktuelle Quota des Tages:');
            console.log(`   Free Places: ${currentQuota.freePlaces || 0}`);
            console.log(`   Sonder:      ${currentQuota.sonder}`);
            console.log(`   Lager:       ${currentQuota.lager}`);
            console.log(`   Betten:      ${currentQuota.betten}`);
            console.log(`   DZ:          ${currentQuota.dz}`);
            console.log(`   TOTAL:       ${currentQuota.sonder + currentQuota.lager + currentQuota.betten + currentQuota.dz}\n`);

            // 1.4 HRS Daily Summary Daten werden NICHT mehr geladen (zu viele API-Calls)
            // Die Berechnung basiert nur auf AV + Intern Belegung

            // 1.5 Zielauslastung gesamt
            console.log('üéØ Zielauslastung gesamt: ' + targetCapacity + ' Betten\n');

            // 1.6 Max-Werte f√ºr Kategorien auslesen (fixe Reihenfolge, keine Priorit√§ten!)
            const maxMBZ = this.getMaxValue('max-mbz');
            const max2BZ = this.getMaxValue('max-2bz');
            const maxSK = this.getMaxValue('max-sk');

            console.log('üìã Max-Werte f√ºr Kategorien:');
            console.log(`   MBZ (Betten): ${maxMBZ === Infinity ? '‚àû' : maxMBZ}`);
            console.log(`   2BZ (DZ):     ${max2BZ === Infinity ? '‚àû' : max2BZ}`);
            console.log(`   SK (Sonder):  ${maxSK === Infinity ? '‚àû' : maxSK}`);
            console.log(`   ML (Lager):   REST\n`);

            console.log(`\n${'='.repeat(80)}`);
            console.log('üìê BERECHNUNGSVORBEREITUNG ABGESCHLOSSEN');
            console.log(`${'='.repeat(80)}\n`);

            // ========================================================================
            // SCHRITT 2: QUOTA-BERECHNUNG - VEREINFACHTE LOGIK
            // ========================================================================

            console.log('üí° QUOTA-FORMEL:\n');

            // 2.1 Berechne Gesamtg√§ste im Haus (AV + Intern)
            const totalGuestsInHouse =
                avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz +
                internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz;

            console.log(`üë• Gesamtg√§ste im Haus: ${totalGuestsInHouse}`);
            console.log(`   (AV: ${avOccupancy.sonder + avOccupancy.lager + avOccupancy.betten + avOccupancy.dz} + Intern: ${internalOccupancy.sonder + internalOccupancy.lager + internalOccupancy.betten + internalOccupancy.dz})\n`);

            // 2.2 Erforderliche Gesamtquota (Qerf)
            // Formel: Qerf = Zielauslastung - Anzahl ALLER G√§ste im Haus
            let Qerf = targetCapacity - totalGuestsInHouse;
            if (Qerf < 0) Qerf = 0;

            console.log(`üìä Erforderliche Gesamtquota (Qerf):`);
            console.log(`   Qerf = ${targetCapacity} (Zielauslastung) - ${totalGuestsInHouse} (G√§ste) = ${Qerf}\n`);

            // 2.3 Quota-Verteilung (EINFACH)
            const result = { lager: 0, betten: 0, dz: 0, sonder: 0 };

            console.log('üéØ Quota-Verteilung:\n');

            // Verteile zuerst MBZ, 2BZ, SK mit ihren Max-Werten
            result.betten = Math.min(maxMBZ, Qerf);
            result.dz = Math.min(max2BZ, Qerf);
            result.sonder = Math.min(maxSK, Qerf);

            console.log(`   MBZ (Betten): ${result.betten} (max ${maxMBZ === Infinity ? '‚àû' : maxMBZ})`);
            console.log(`   2BZ (DZ):     ${result.dz} (max ${max2BZ === Infinity ? '‚àû' : max2BZ})`);
            console.log(`   SK (Sonder):  ${result.sonder} (max ${maxSK === Infinity ? '‚àû' : maxSK})`);

            // ML bekommt den REST
            const usedByOthers = result.betten + result.dz + result.sonder;
            result.lager = Math.max(0, Qerf - usedByOthers);

            console.log(`   ML (Lager):   ${result.lager} (REST: ${Qerf} - ${usedByOthers} = ${result.lager})`);

            const totalQuota = result.sonder + result.lager + result.betten + result.dz;
            console.log(`   TOTAL:        ${totalQuota} (sollte ${Qerf} sein)`);
            console.log(`${'='.repeat(80)}\n`);

            return result;
        }

        /**
         * Aktualisiert Live-Preview - berechnet f√ºr JEDEN TAG individuell
         */
        async updatePreview() {
            console.log('üîÑ updatePreview() START');
            const targetCapacity = parseInt(document.getElementById('targetCapacity').value);
            const previewContainer = document.getElementById('quotaPreviewDays');
            console.log('üì¶ previewContainer:', previewContainer);
            console.log('üéØ targetCapacity:', targetCapacity);
            console.log('üìÖ selectedDays:', this.selectedDays);

            let hasOverbooking = false;
            const tableData = [];

            // Sammle Daten f√ºr alle Tage
            console.log('üîÑ Starte Datensammlung f√ºr', this.selectedDays.length, 'Tage...');
            for (const dateStr of this.selectedDays) {
                console.log('  üìÖ Verarbeite Tag:', dateStr);
                // Berechne Quota-Verteilung (diese Funktion holt sich intern die Belegungen)
                const quotas = await this.calculateQuotaDistribution(targetCapacity, null, dateStr);
                console.log('  ‚úÖ Quotas berechnet:', quotas);

                // Hole Belegungsdaten f√ºr die Anzeige
                const occupancy = await this.getOccupancyForDate(dateStr);

                // Parse Datum
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dateDisplay = date.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit', month: '2-digit', year: 'numeric' });

                // Berechne Gesamtg√§ste
                const totalGuests = occupancy.av + occupancy.internal;
                const availableQuota = Math.max(0, targetCapacity - totalGuests);

                if (availableQuota <= 0) {
                    hasOverbooking = true;
                }

                tableData.push({
                    date: dateDisplay,
                    av: occupancy.av,
                    internal: occupancy.internal,
                    total: totalGuests,
                    quota: availableQuota,
                    ml: quotas.lager,
                    mbz: quotas.betten,
                    bz2: quotas.dz,
                    sk: quotas.sonder,
                    totalQuota: quotas.lager + quotas.betten + quotas.dz + quotas.sonder,
                    isOverbooked: availableQuota <= 0
                });
            }

            // Erstelle Excel-Style Tabelle
            let html = `
                <div style="overflow-x: auto;">
                    <table class="table table-sm table-bordered table-hover" style="font-size: 0.85em; margin: 0;">
                        <thead class="table-dark" style="position: sticky; top: 0; z-index: 10;">
                            <tr>
                                <th style="min-width: 130px;">Datum</th>
                                <th class="text-center" style="min-width: 50px;" title="AV-Reservierungen">AV</th>
                                <th class="text-center" style="min-width: 50px;" title="Interne Reservierungen">Int</th>
                                <th class="text-center" style="min-width: 60px;" title="Gesamt G√§ste">Total</th>
                                <th class="text-center" style="min-width: 60px; background-color: #2d5a3f;" title="Erforderliche Gesamtquota">Qerf</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">ML</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">MBZ</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">2BZ</th>
                                <th class="text-center" style="min-width: 50px; background-color: #1a4d2e;">SK</th>
                                <th class="text-center" style="min-width: 60px; background-color: #2d5a3f;" title="Summe Quotas">Œ£</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            for (const row of tableData) {
                const rowClass = row.isOverbooked ? 'table-danger' : '';
                const quotaClass = row.quota > 0 ? 'text-success fw-bold' : 'text-danger';

                html += `
                    <tr class="${rowClass}">
                        <td><strong>${row.date}</strong></td>
                        <td class="text-center">${row.av}</td>
                        <td class="text-center">${row.internal}</td>
                        <td class="text-center"><strong>${row.total}</strong></td>
                        <td class="text-center ${quotaClass}"><strong>${row.quota}</strong></td>
                        <td class="text-center ${row.ml > 0 ? 'bg-success bg-opacity-25' : ''}">${row.ml}</td>
                        <td class="text-center ${row.mbz > 0 ? 'bg-success bg-opacity-25' : ''}">${row.mbz}</td>
                        <td class="text-center ${row.bz2 > 0 ? 'bg-success bg-opacity-25' : ''}">${row.bz2}</td>
                        <td class="text-center ${row.sk > 0 ? 'bg-success bg-opacity-25' : ''}">${row.sk}</td>
                        <td class="text-center"><strong>${row.totalQuota}</strong></td>
                    </tr>
                `;
            }

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            console.log('üìä TableData:', tableData);
            console.log('üìù HTML Length:', html.length);
            console.log('üéØ Setting innerHTML...');
            previewContainer.innerHTML = html;
            console.log('‚úÖ innerHTML gesetzt! previewContainer.children:', previewContainer.children.length);

            // Overbooking Warning
            const warning = document.getElementById('overbookingWarning');
            if (hasOverbooking) {
                warning.classList.remove('d-none');
            } else {
                warning.classList.add('d-none');
            }
        }


        /**
         * Hole aktuelle Belegung f√ºr ein bestimmtes Datum
         * Unterscheidet zwischen AV-Reservierungen (av_id > 0) und internen (av_id = 0)
         * WICHTIG: Z√§hlt ALLE Betten (lager + betten + dz + sonder)!
         */
        async getOccupancyForDate(dateStr) {
            let avReservations = 0;      // Reservierungen VOM AV-System (av_id > 0)
            let internalReservations = 0; // Interne Reservierungen (av_id = 0)

            if (!this.renderer) {
                console.error('‚ùå renderer nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            const { startDate, endDate } = this.renderer.getTimelineDateRange();
            const histogramData = this.renderer.getHistogramData(startDate, endDate);

            if (!histogramData || !histogramData.dailyDetails) {
                console.error('‚ùå histogramData nicht verf√ºgbar!');
                return { av: 0, internal: 0, total: 0 };
            }

            // Berechne Day-Index aus dateStr
            const date = new Date(dateStr);
            const dayIndex = Math.floor((date - startDate) / (1000 * 60 * 60 * 24));

            const detail = histogramData.dailyDetails[dayIndex];

            if (detail) {
                // Hole Reservierungen aus histogramSource f√ºr dieses Datum
                if (window.histogramSource) {
                    const reservationsForDate = window.histogramSource.filter(res => {
                        const resStart = res.anreise || res.start_date || res.start;
                        const resEnd = res.abreise || res.end_date || res.end;
                        return resStart && resEnd && resStart <= dateStr && dateStr < resEnd;
                    });

                    reservationsForDate.forEach(res => {
                        // Z√§hle ALLE Betten (nicht nur Personen!)
                        const details = res.capacity_details || {};
                        const totalBeds = parseInt(details.lager || 0) +
                            parseInt(details.betten || 0) +
                            parseInt(details.dz || 0) +
                            parseInt(details.sonder || 0);

                        if (res.av_id && res.av_id > 0) {
                            avReservations += totalBeds;
                        } else {
                            internalReservations += totalBeds;
                        }
                    });
                }

                const total = avReservations + internalReservations;
                console.log(`üìä ${dateStr} (dayIndex ${dayIndex}): AV=${avReservations} Betten, Intern=${internalReservations} Betten, Total=${total}`);
            } else {
                console.warn(`‚ö†Ô∏è Kein dailyDetail f√ºr ${dateStr} (dayIndex ${dayIndex})`);
            }

            return { av: avReservations, internal: internalReservations, total: avReservations + internalReservations };
        }

        /**
         * Hole bereits gebuchte AV-Kategorien f√ºr ein bestimmtes Datum
         * WICHTIG: Nur Reservierungen mit av_id > 0 z√§hlen!
```        /**
         * Hole bereits gebuchte Kategorien f√ºr ein bestimmtes Datum
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @param {boolean} onlyAV - true = nur AV-Reservierungen (av_id > 0), false = nur Intern (av_id = 0)
         * @returns {object} - { sonder, lager, betten, dz }
         */
        async getBookedCategoriesForDate(dateStr, onlyAV = true) {
            const booked = { sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !window.histogramSource) {
                return booked;
            }

            // Filtere Reservierungen f√ºr dieses Datum
            const reservationsForDate = window.histogramSource.filter(res => {
                // Filter nach AV oder Intern
                if (onlyAV) {
                    if (!res.av_id || res.av_id <= 0) return false; // Nur AV-Reservierungen
                } else {
                    if (res.av_id && res.av_id > 0) return false; // Nur interne Reservierungen
                }

                // Pr√ºfe ob Datum im Reservierungs-Zeitraum liegt
                const resStart = res.anreise || res.start_date || res.start;
                const resEnd = res.abreise || res.end_date || res.end;

                return dateStr >= resStart && dateStr < resEnd;
            });

            // Z√§hle nach Kategorien (aus capacity_details)
            reservationsForDate.forEach(res => {
                const details = res.capacity_details || {};

                booked.sonder += parseInt(details.sonder || 0);
                booked.lager += parseInt(details.lager || 0);
                booked.betten += parseInt(details.betten || 0);
                booked.dz += parseInt(details.dz || 0);
            });

            return booked;
        }

        /**
         * Hole aktuelle Quota f√ºr ein bestimmtes Datum (falls bereits gesetzt)
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { freePlaces, sonder, lager, betten, dz }
         */
        async getCurrentQuotaForDate(dateStr) {
            const quota = { freePlaces: 0, sonder: 0, lager: 0, betten: 0, dz: 0 };

            if (!dateStr || !this.renderer) {
                return quota;
            }

            const MS_IN_DAY = 24 * 60 * 60 * 1000;
            const { startDate, endDate } = this.renderer.getTimelineDateRange();

            const normalizedStart = new Date(startDate);
            normalizedStart.setHours(12, 0, 0, 0);

            const normalizedDate = new Date(dateStr);
            normalizedDate.setHours(12, 0, 0, 0);

            const dayIndex = Math.floor((normalizedDate - normalizedStart) / MS_IN_DAY);

            // Hole Availability-Daten (enthaelt Quota-Informationen) - Backend ist schon inklusiv!
            const histogramData = this.renderer.getHistogramData(normalizedStart, endDate);

            if (histogramData && histogramData.dailyDetails && dayIndex >= 0 && dayIndex < histogramData.dailyDetails.length) {
                const details = histogramData.dailyDetails[dayIndex];
                const quotaDetails = details.quota || {};

                quota.freePlaces = details.free_capacity || 0;
                quota.sonder = quotaDetails.sonder || 0;
                quota.lager = quotaDetails.lager || 0;
                quota.betten = quotaDetails.betten || 0;
                quota.dz = quotaDetails.dz || 0;
            }

            return quota;
        }

        /**
         * Hole HRS Daily Summary Daten f√ºr ein bestimmtes Datum
         * Diese Daten sind ESSENTIELL f√ºr die korrekte Quota-Berechnung!
         * 
         * @param {string} dateStr - Datum (YYYY-MM-DD)
         * @returns {object} - { totalGuests, categories: { lager, betten, dz, sonder } }
         */
        async getDailySummaryForDate(dateStr) {
            const result = {
                totalGuests: 0,
                categories: {
                    lager: { freePlaces: 0, assigned: 0 },
                    betten: { freePlaces: 0, assigned: 0 },
                    dz: { freePlaces: 0, assigned: 0 },
                    sonder: { freePlaces: 0, assigned: 0 }
                }
            };

            if (!dateStr) {
                return result;
            }

            try {
                // Lade Daily Summary aus DB via API
                const response = await fetch(`/wci/zp/getDailySummary.php?date=${dateStr}`);
                if (!response.ok) {
                    console.warn(`‚ö†Ô∏è getDailySummary failed: ${response.status}`);
                    return result;
                }

                const data = await response.json();

                if (data.success && data.data) {
                    result.totalGuests = data.data.total_guests || 0;

                    // Mappe Kategorien
                    const categoryMap = {
                        'ML': 'lager',
                        'MBZ': 'betten',
                        '2BZ': 'dz',
                        'SK': 'sonder'
                    };

                    if (data.data.categories) {
                        data.data.categories.forEach(cat => {
                            const mappedName = categoryMap[cat.category_type];
                            if (mappedName) {
                                result.categories[mappedName] = {
                                    freePlaces: parseInt(cat.free_places || 0),
                                    assigned: parseInt(cat.assigned_guests || 0)
                                };
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('‚ùå Error loading daily summary:', error);
            }

            return result;
        }

        /**
         * Validierung
         */
        validate() {
            // Einfache Validierung: Pr√ºfe ob targetCapacity gesetzt ist
            const targetCapacity = parseInt(document.getElementById('targetCapacity').value);

            if (!targetCapacity || targetCapacity <= 0) {
                alert('‚ùå Fehler: Zielauslastung muss gr√∂√üer als 0 sein!');
                return false;
            }

            // Pr√ºfe ob Tage selektiert sind
            if (!this.selectedDays || this.selectedDays.length === 0) {
                alert('‚ùå Fehler: Keine Tage ausgew√§hlt!');
                return false;
            }

            return true;
        }

        /**
         * Speichert Quotas via API
         */
        async save() {
            if (!this.validate()) return;

            const saveBtn = document.getElementById('saveQuotaBtn');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '‚è≥ Speichern...';

            const statusEnabled = this.startStatusWorkflow([
                'Sende Daten an HRS',
                'Quotas schreiben',
                'Import aktualisieren'
            ]);

            try {
                const targetCapacity = parseInt(document.getElementById('targetCapacityValue').value) || 0;

                // Berechne f√ºr jeden Tag individuell
                const dailyQuotas = [];
                for (const dateStr of this.selectedDays) {
                    // 1. Berechne die neuen Quota-Werte (Q_berechnet)
                    const calculatedQuotas = await this.calculateQuotaDistribution(targetCapacity, null, dateStr);

                    // 2. Hole bereits gebuchte AV-G√§ste pro Kategorie (assigned_guests)
                    const assignedGuestsAV = await this.getBookedCategoriesForDate(dateStr, true);

                    // 3. WICHTIG: Berechne die zu schreibenden Werte f√ºr HRS
                    // Formel: Q_write = assigned_guests + Q_berechnet
                    const quotasToWrite = {
                        lager: assignedGuestsAV.lager + calculatedQuotas.lager,
                        betten: assignedGuestsAV.betten + calculatedQuotas.betten,
                        dz: assignedGuestsAV.dz + calculatedQuotas.dz,
                        sonder: assignedGuestsAV.sonder + calculatedQuotas.sonder
                    };

                    console.log(`üìä ${dateStr}:`);
                    console.log(`   Assigned AV: L=${assignedGuestsAV.lager}, B=${assignedGuestsAV.betten}, DZ=${assignedGuestsAV.dz}, S=${assignedGuestsAV.sonder}`);
                    console.log(`   Calculated Q: L=${calculatedQuotas.lager}, B=${calculatedQuotas.betten}, DZ=${calculatedQuotas.dz}, S=${calculatedQuotas.sonder}`);
                    console.log(`   ‚Üí Write to HRS: L=${quotasToWrite.lager}, B=${quotasToWrite.betten}, DZ=${quotasToWrite.dz}, S=${quotasToWrite.sonder}`);

                    dailyQuotas.push({
                        date: dateStr,
                        quota_lager: quotasToWrite.lager,
                        quota_betten: quotasToWrite.betten,
                        quota_dz: quotasToWrite.dz,
                        quota_sonder: quotasToWrite.sonder,
                        targetCapacity: targetCapacity
                    });
                }

                // API Call
                const requestBody = {
                    quotas: dailyQuotas,
                    operation: 'update'
                };

                console.log('üì§ Sending to HRS API:', requestBody);

                const response = await fetch('/wci/hrs/hrs_write_quota_v3.php?v=20251011_v3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('üì• Response status:', response.status);

                if (statusEnabled) {
                    this.setStatusStep(0, response.ok ? 'success' : 'error', `HTTP ${response.status}`);
                    if (response.ok) {
                        this.setStatusStep(1, 'active');
                    }
                }

                // Read response as text first
                const responseText = await response.text();
                console.log('üìÑ Response body (first 500 chars):', responseText.substring(0, 500));

                // Check if response is JSON
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (e) {
                    console.error('‚ùå JSON Parse Error:', e.message);
                    console.error('üìÑ Full response:', responseText);
                    throw new Error('Server returned invalid JSON. Response: ' + responseText.substring(0, 200));
                }

                if (!response.ok) {
                    console.error('‚ùå API Error Response:', result);
                    if (statusEnabled) {
                        this.failStatusWorkflow(result.error || result.message || `HTTP ${response.status}`);
                    }
                    throw new Error(result.error || result.message || 'Unknown server error');
                }

                if (result.success) {
                    const createdCount = Number.isFinite(result.createdCount) ? result.createdCount : (Array.isArray(result.createdQuotas) ? result.createdQuotas.length : 0);
                    const deletedCount = Number.isFinite(result.deletedCount) ? result.deletedCount : (Array.isArray(result.deletedQuotas) ? result.deletedQuotas.length : 0);
                    const adjustedClosedCount = Number.isFinite(result.adjustedClosedCount) ? result.adjustedClosedCount : (Array.isArray(result.adjustedClosedQuotas) ? result.adjustedClosedQuotas.length : 0);
                    const importInfo = result.localRefresh || {};
                    const importHasData = importInfo && Object.keys(importInfo).length > 0;
                    const importSuccess = importHasData && typeof importInfo.success === 'boolean' ? importInfo.success : true;

                    if (statusEnabled) {
                        this.setStatusStep(1, 'success', `${createdCount} erstellt, ${deletedCount} gel√∂scht${adjustedClosedCount ? `, ${adjustedClosedCount} geschlossen angepasst` : ''}`);
                        if (this.statusSteps.length >= 3) {
                            if (importHasData && importInfo.success === false) {
                                this.setStatusStep(2, 'error', importInfo.error || 'Import fehlgeschlagen');
                            } else {
                                let importDetail = 'Kein Import erforderlich';
                                if (importHasData) {
                                    if (importInfo.success === true) {
                                        importDetail = 'Import aktualisiert';
                                    } else if (Array.isArray(importInfo.logs)) {
                                        importDetail = `${importInfo.logs.length} Log-Eintr√§ge`;
                                    }
                                }
                                this.setStatusStep(2, 'success', importDetail);
                            }
                        }
                        this.completeStatusWorkflow(importSuccess !== false, result.message || 'Fertig.');
                    } else {
                        alert(`‚úÖ Erfolg!\n\n${result.message}\n\nErstellt: ${createdCount} Quotas\nGel√∂scht: ${deletedCount} Quotas`);
                    }

                    // Timeline neu laden f√ºr den betroffenen Zeitbereich
                    console.log('üîÑ Reloading timeline data after quota changes...');

                    // Wenn affectedDateRange vorhanden, logge es
                    if (result.affectedDateRange) {
                        console.log('üìÖ Affected date range:', result.affectedDateRange.from, 'to', result.affectedDateRange.to);
                    }

                    // Pr√ºfe ob HRS Import erfolgreich war
                    if (result.localRefresh) {
                        if (result.localRefresh.success) {
                            console.log('‚úÖ HRS Import successful - Cache aktualisiert');
                        } else {
                            console.warn('‚ö†Ô∏è HRS Import failed:', result.localRefresh.error || 'Unknown error');
                        }
                    }

                    // Warte damit DB-Transaktion und Import sicher committed sind
                    console.log('‚è≥ Waiting 800ms for DB commit and import...');
                    await new Promise(resolve => setTimeout(resolve, 800));

                    // Verwende die globale reloadTimelineData Funktion
                    if (typeof window.reloadTimelineData === 'function') {
                        console.log('üîÑ Calling window.reloadTimelineData()...');
                        await window.reloadTimelineData();
                        console.log('‚úÖ Timeline data reloaded successfully');

                        // Force histogram redraw
                        if (window.renderer && typeof window.renderer.render === 'function') {
                            console.log('üé® Forcing histogram redraw...');
                            window.renderer.render();
                            console.log('‚úÖ Histogram redrawn');
                        }
                    } else {
                        console.warn('‚ö†Ô∏è window.reloadTimelineData() not found, trying page reload...');
                        // Fallback: Page reload
                        setTimeout(() => {
                            window.location.reload();
                        }, 500);
                    }

                    this.modal.hide();
                } else {
                    if (statusEnabled) {
                        this.failStatusWorkflow(result.error || 'Unbekannter Fehler');
                    } else {
                        alert(`‚ùå Fehler beim Speichern:\n\n${result.error}`);
                    }
                }

            } catch (error) {
                console.error('Quota save error:', error);
                if (statusEnabled) {
                    this.failStatusWorkflow(error.message || 'Unbekannter Fehler');
                } else {
                    alert(`‚ùå Netzwerkfehler:\n\n${error.message}`);
                }
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'üíæ Speichern';
            }
        }
    }

    // Globale Instanz erstellen (wird von timeline-unified.js genutzt)
    window.quotaInputModal = null;

    // Initialisierungs-Funktion (wird nach dem Laden des HTML aufgerufen)
    window.initQuotaInputModal = function () {
        console.log('üìã initQuotaInputModal aufgerufen');

        // Warte auf renderer-Initialisierung
        const checkRenderer = setInterval(() => {
            if (typeof window.renderer !== 'undefined' && window.renderer) {
                window.quotaInputModal = new QuotaInputModal(window.renderer);
                console.log('‚úÖ Quota Input Modal initialized mit renderer:', window.renderer);
                clearInterval(checkRenderer);
            } else {
                console.log('‚è≥ Warte auf window.renderer...');
            }
        }, 100);

        // Timeout nach 10 Sekunden
        setTimeout(() => {
            if (!window.quotaInputModal) {
                console.warn('‚ö†Ô∏è Quota Modal konnte nicht initialisiert werden - renderer nicht gefunden');
                console.log('window.renderer ist:', window.renderer);
            }
        }, 10000);
    };

    // Wenn DOMContentLoaded schon vorbei ist (bei dynamischem Laden), sofort initialisieren
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.initQuotaInputModal);
    } else {
        // DOM ist bereits bereit, sofort initialisieren
        window.initQuotaInputModal();
    }
</script>