<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Timeline Unified - Single Canvas Rendering</title>

    <!-- Bootstrap 5.3.2 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">

    <!-- Bootstrap 5 Dark Theme Overrides -->
    <style>
        /* Bootstrap Modal Dark Theme */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.85);
        }

        .modal-content {
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            border: 1px solid #444;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            border-bottom: 1px solid #444;
        }

        .modal-footer {
            border-top: 1px solid #444;
        }

        .modal-title {
            color: #fff;
            font-weight: 600;
        }

        .modal-body {
            color: #e0e0e0;
        }

        .btn-close {
            filter: brightness(0) invert(1);
        }

        /* Form Controls Dark Theme */
        .form-control {
            background: #1e1e1e;
            border: 1px solid #444;
            color: #fff;
        }

        .form-control:focus {
            background: #1e1e1e;
            border-color: #8b5cf6;
            color: #fff;
            box-shadow: 0 0 0 0.25rem rgba(139, 92, 246, 0.25);
        }

        /* Button Styles */
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5568d3 0%, #653a8c 100%);
            border: none;
        }

        .btn-secondary {
            background: #555;
            border: none;
        }

        .btn-secondary:hover {
            background: #666;
            border: none;
        }
    </style>

    <style>
        :root {
            /* Unified modal color system (keine visuellen Änderungen, nur zentralisierte Variablen) */
            --modal-overlay-bg: rgba(0, 0, 0, 0.7);
            --modal-bg: #2c2c2c;
            --modal-border: #555;
            --modal-header-color: #f5f5f5;
            --modal-body-color: #cccccc;
            --modal-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            --modal-input-bg: #1a1a1a;
            --modal-input-border: #555;
            --modal-input-color: #f5f5f5;
            --modal-input-focus: #007bff;
            --modal-textarea-focus-shadow: rgba(255, 215, 0, 0.25);
            --modal-btn-cancel-bg: #555;
            --modal-btn-cancel-bg-hover: #666;
            --modal-btn-danger-bg: #dc3545;
            --modal-btn-danger-bg-hover: #c82333;
            --modal-btn-primary-bg: #007bff;
            --modal-btn-primary-bg-hover: #0056b3;
            --modal-btn-secondary-bg: #6c757d;
            --modal-btn-secondary-bg-hover: #5a6268;
            --modal-checkbox-accent: #007bff;
            --dataset-section-bg: #2a2a2a;
            --dataset-section-border: #444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c2c2c;
            padding: 0;
        }

        .main-areas-container {
            background: #2c2c2c;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .timeline-unified-container {
            position: relative !important;
        }

        .scroll-horizontal::-webkit-scrollbar,
        .scroll-vertical::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .scroll-horizontal::-webkit-scrollbar-track,
        .scroll-vertical::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .scroll-horizontal::-webkit-scrollbar-thumb,
        .scroll-vertical::-webkit-scrollbar-thumb {
            background: #555555;
            border-radius: 6px;
        }

        .scroll-horizontal::-webkit-scrollbar-thumb:hover,
        .scroll-vertical::-webkit-scrollbar-thumb:hover {
            background: #777777;
        }

        .performance-info {
            display: none;
            /* Performance-Info ausgeblendet */
        }

        .radial-menu {
            position: absolute;
            /* width and height set dynamically by JavaScript */
            pointer-events: none;
            z-index: 9999;
            display: none;
            /* Start slightly rotated so the show animation rotates +360° to final +90° */
            transform: rotate(-270deg) scale(0.05);
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                opacity 0.5s ease-out;
        }

        .radial-menu.active {
            display: block;
            /* Final resting orientation rotated +90° clockwise */
            transform: rotate(90deg) scale(1);
            opacity: 1;
        }

        .radial-menu.hiding {
            /* Continue the rotation direction when hiding */
            transform: rotate(450deg) scale(0.05);
            opacity: 0;
        }

        .radial-menu svg {
            /* width and height set dynamically by JavaScript */
            filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.35));
        }

        .radial-menu path.segment {
            cursor: pointer;
            pointer-events: auto;
            stroke: rgba(0, 0, 0, 0.25);
            stroke-width: 1;
        }

        .radial-menu path.segment:hover {
            filter: brightness(1.2);
        }

        .radial-menu text {
            fill: #f5f5f5;
            font-size: 11px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
        }

        .radial-menu .center-button {
            cursor: pointer;
            pointer-events: auto;
        }

        .timeline-topbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            padding: 0 12px;
            z-index: 5;
            background: var(--topbar-bg, rgba(34, 34, 34, 0.95));
            color: var(--topbar-fg, #f5f5f5);
            border-bottom: 1px solid var(--topbar-border, rgba(255, 255, 255, 0.12));
        }

        .timeline-topbar-actions {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 0 0 auto;
        }

        .timeline-topbar-button {
            appearance: none;
            border: 1px solid var(--topbar-border, rgba(255, 255, 255, 0.2));
            background: transparent;
            color: inherit;
            font-size: 11px;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .timeline-nav-container {
            flex: 1 1 auto;
            height: 100%;
            display: flex;
            align-items: center;
        }

        .timeline-nav-canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 4px;
            cursor: grab;
        }

        .timeline-nav-canvas.dragging {
            cursor: grabbing;
        }

        .timeline-topbar-button:hover,
        .timeline-topbar-button[aria-expanded="true"] {
            background: var(--topbar-menu-bg, rgba(28, 28, 28, 0.95));
            border-color: var(--topbar-accent, #4facfe);
        }

        .timeline-topbar-menu {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            right: auto;
            min-width: 260px;
            max-width: min(360px, calc(100vw - 24px));
            background: var(--topbar-menu-bg, rgba(30, 30, 30, 0.96));
            border: 1px solid var(--topbar-border, rgba(255, 255, 255, 0.18));
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
            display: none;
            pointer-events: auto;
        }

        .timeline-topbar-menu[data-open="true"] {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .topbar-menu-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .topbar-menu-section label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--topbar-muted, rgba(255, 255, 255, 0.6));
        }

        .topbar-select,
        .topbar-menu input[type="number"] {
            width: 100%;
            background: rgba(0, 0, 0, 0.25);
            color: var(--topbar-fg, #f5f5f5);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
        }

        .topbar-menu input[type="number"]:focus,
        .topbar-select:focus {
            outline: none;
            border-color: var(--topbar-accent, #4facfe);
            box-shadow: 0 0 0 2px rgba(79, 172, 254, 0.2);
        }

        .topbar-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .topbar-control-row input[type="range"] {
            flex: 1;
        }

        .topbar-menu-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
        }

        .topbar-field input[type="number"] {
            width: 100%;
        }

        .topbar-menu-links {
            display: flex;
            justify-content: flex-end;
        }

        .topbar-link {
            color: var(--topbar-fg, #f5f5f5);
            font-size: 12px;
            text-decoration: none;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .topbar-link:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--topbar-accent, #4facfe);
        }

        /* Modal Dialog Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-overlay-bg);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-dialog {
            background: var(--modal-bg);
            border: 1px solid var(--modal-border);
            border-radius: 8px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--modal-shadow);
            animation: modalSlideIn 0.2s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .modal-header {
            color: var(--modal-header-color);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
        }

        .modal-header .icon {
            margin-right: 8px;
            font-size: 20px;
        }

        .modal-body {
            color: var(--modal-body-color);
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 24px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .modal-button-cancel {
            background: var(--modal-btn-cancel-bg);
            color: var(--modal-header-color);
        }

        .modal-button-cancel:hover {
            background: var(--modal-btn-cancel-bg-hover);
        }

        .modal-button-danger {
            background: var(--modal-btn-danger-bg);
            color: white;
        }

        .modal-button-danger:hover {
            background: var(--modal-btn-danger-bg-hover);
        }

        .modal-button-primary {
            background: var(--modal-btn-primary-bg);
            color: white;
        }

        .modal-button-primary:hover {
            background: var(--modal-btn-primary-bg-hover);
        }

        /* Input Modal Styles */
        .modal-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--modal-input-border);
            border-radius: 4px;
            background: var(--modal-input-bg);
            color: var(--modal-input-color);
            font-size: 14px;
            margin-bottom: 16px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--modal-input-focus);
        }

        .modal-textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--modal-input-border);
            border-radius: 4px;
            background: var(--modal-input-bg);
            color: var(--modal-input-color);
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 16px;
        }

        .modal-textarea:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 0 2px var(--modal-textarea-focus-shadow);
        }

        .modal-textarea::placeholder {
            color: #888;
        }

        .modal-button-secondary {
            background: var(--modal-btn-secondary-bg);
            color: white;
            border: none;
        }

        .modal-button-secondary:hover {
            background: var(--modal-btn-secondary-bg-hover);
        }

        .modal-checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            color: #cccccc;
        }

        .modal-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--modal-checkbox-accent);
        }

        .modal-checkbox-label {
            font-size: 14px;
            cursor: pointer;
        }

        /* Dataset Modal Styles */
        .dataset-section {
            margin-bottom: 24px;
            border: 1px solid var(--dataset-section-border);
            border-radius: 6px;
            padding: 16px;
            background: var(--dataset-section-bg);
        }

        .dataset-section-title {
            color: #f5f5f5;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dataset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .dataset-field {
            display: flex;
            flex-direction: column;
        }

        .dataset-field label {
            color: #cccccc;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .dataset-field input,
        .dataset-field textarea {
            padding: 8px 12px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #1a1a1a;
            color: #f5f5f5;
            font-size: 14px;
        }

        .dataset-field input:focus,
        .dataset-field textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .dataset-field input:read-only {
            background: #333;
            color: #aaa;
            cursor: not-allowed;
        }

        /* Compact overrides for the dataset modal */
        #dataset-modal .modal-dialog {
            padding: 14px;
            /* was 24px */
            border-radius: 6px;
            /* slightly tighter */
        }

        #dataset-modal .modal-header {
            margin-bottom: 10px;
            /* was 16px */
            font-size: 16px;
            /* was 18px */
        }

        #dataset-modal .modal-header .icon {
            margin-right: 6px;
            /* was 8px */
            font-size: 18px;
            /* was 20px */
        }

        #dataset-modal .modal-body {
            margin-bottom: 12px;
            /* was 24px */
        }

        #dataset-modal .modal-actions {
            gap: 8px;
            /* was 12px */
        }

        #dataset-modal .modal-button {
            padding: 8px 14px;
            /* was 10px 20px */
            font-size: 13px;
            /* was 14px */
            border-radius: 5px;
            /* was 6px */
        }

        #dataset-modal .modal-input,
        #dataset-modal .modal-textarea,
        #dataset-modal .dataset-field input,
        #dataset-modal .dataset-field textarea {
            padding: 6px 10px;
            /* was 8px 12px */
            margin-bottom: 10px;
            /* was 16px */
            font-size: 13px;
            /* was 14px */
        }

        #dataset-modal .modal-textarea {
            min-height: 64px;
            /* was 80px */
        }

        #dataset-modal .modal-checkbox-group {
            gap: 6px;
            /* was 8px */
            margin-bottom: 10px;
            /* was 16px */
        }

        #dataset-modal .dataset-section {
            margin-bottom: 12px;
            /* was 24px */
            padding: 10px;
            /* was 16px */
            border-radius: 5px;
            /* was 6px */
        }

        #dataset-modal .dataset-section-title {
            font-size: 14px;
            /* was 16px */
            margin-bottom: 10px;
            /* was 16px */
            gap: 6px;
            /* was 8px */
        }

        #dataset-modal .dataset-grid {
            gap: 10px;
            /* was 16px */
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            /* a bit tighter */
        }

        #dataset-modal .dataset-field label {
            font-size: 12px;
            /* was 13px */
            margin-bottom: 4px;
            /* was 6px */
        }

        /* Room Assignment Modal */
        .assign-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            user-select: none;
            /* Verhindert Text-Selektion im gesamten Modal */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .assign-modal[open] {
            display: flex;
        }

        .assign-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.55);
            backdrop-filter: blur(2px);
        }

        .assign-card {
            position: relative;
            z-index: 1;
            width: min(1200px, 94vw);
            max-height: 90vh;
            background: #0f172a;
            color: #e5e7eb;
            border: 1px solid #1f2937;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .assign-body {
            display: flex;
            gap: 20px;
            padding: 8px;
            height: 100%;
            overflow: hidden;
        }

        .assign-grid {
            flex: 1;
            background: #f9fafb;
            color: #111827;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px;
            overflow-y: auto;
            height: 100%;
            max-height: 70vh;
        }

        .assign-grid-inner {
            display: grid;
            gap: 1px;
            grid-auto-rows: 40px;
            grid-template-columns: repeat(auto-fill, minmax(200px, 200px));
        }

        .assign-room {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 2px 4px;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            gap: 6px;
            min-height: 40px;
            height: 40px;
            box-sizing: border-box;
            position: relative;
            width: 100%;
        }

        .assign-room.drop-target {
            outline: 2px solid #60a5fa;
            outline-offset: 2px;
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25) inset;
        }

        /* Disabled state for rooms that cannot accept more assignments (max <= 0) */
        .assign-room.disabled {
            opacity: 1;
        }

        .assign-room.disabled .assign-bar {
            cursor: not-allowed;
        }

        .assign-room-title {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: center;
            gap: 1px;
            flex: 1 1 auto;
            min-width: 0;
            margin-right: 0;
        }

        .assign-room-title-stack {
            display: flex;
            flex-direction: column;
            gap: 1px;
            max-width: 100%;
        }

        .assign-room-name {
            font-size: 10px;
            font-weight: 600;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .assign-room-meta {
            color: #64748b;
            font-size: 7.5px;
            font-weight: 400;
            line-height: 1;
        }

        /* Debug: per-day availability als farbkodierte Ovale */
        .assign-bar-debug {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5px;
            pointer-events: none;
            margin-top: 1px;
        }

        .assign-day-oval {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 12px;
            height: 10px;
            border-radius: 2px;
            font-size: 7px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
            padding: 0 1px;
        }

        .assign-day-oval.full {
            background: #16a34a;
            /* Grün - volle Kapazität frei */
        }

        .assign-day-oval.empty {
            background: #dc2626;
            /* Rot - keine Kapazität frei */
        }

        .assign-day-oval.partial {
            background: #ca8a04;
            /* Gelb - teilweise frei */
        }

        /* Zimmer-Hintergrundfarben basierend auf Gesamtverfügbarkeit */
        .assign-room.room-full-available {
            background: #bbf7d0;
            /* Dunkleres Hellgrün */
            border-color: #16a34a;
        }

        .assign-room.room-no-available {
            background: #fecaca;
            /* Dunkleres Hellrot */
            border-color: #dc2626;
        }

        .assign-room.room-partial-available {
            background: #fef08a;
            /* Dunkleres Hellgelb */
            border-color: #ca8a04;
        }

        /* Leere Grid-Zellen */
        .assign-empty-cell {
            min-height: 40px;
            background: transparent;
        }

        .assign-bar {
            position: relative;
            height: 15px;
            border-radius: 4px;
            background: #eef2f7;
            border: 1px solid #dde3ea;
            cursor: ew-resize;
            flex: 0 0 auto;
            width: 60px;
            min-width: 60px;
            margin-top: 0;
            align-self: flex-start;
            overflow: hidden;
        }

        .assign-bar-fill {
            position: absolute;
            inset: 0;
            border-radius: 4px;
            overflow: hidden;
            pointer-events: none;
        }

        .assign-bar-segment {
            position: absolute;
            top: 0;
            height: 100%;
            transition: width 0.2s ease, left 0.2s ease;
        }

        .assign-bar-segment.occupied {
            left: 0;
            background: linear-gradient(90deg, #f87171, #dc2626);
        }

        .assign-bar-segment.assigned {
            left: 0;
            background: linear-gradient(90deg, #93c5fd, #3b82f6);
        }

        .assign-bar-label {
            display: none !important;
        }

        .assign-bar-cap {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            color: #475569;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
        }

        .assign-room-actions {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: flex-start;
            gap: 2px;
            flex: 0 0 auto;
            width: 60px;
            margin-left: auto;
        }

        .assign-controls-wrap {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 4px;
        }

        .assign-btn {
            appearance: none;
            border: 1px solid #cbd5e1;
            background: #fff;
            color: #0f172a;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            min-width: 100px;
            height: 40px;
        }

        .assign-btn.small {
            padding: 0 4px;
            font-size: 10px;
            min-width: 24px;
            height: 16px;
            line-height: 14px;
            border-radius: 4px;
        }

        .assign-controls-wrap .assign-btn.small {
            min-width: 20px;
        }

        .assign-btn:hover {
            background: #f8fafc;
        }

        .assign-sidebar {
            width: 280px;
            flex-shrink: 0;
            background: #f9fafb;
            color: #111827;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .assign-kpis {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .assign-kpi {
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
        }

        .assign-kpi .label {
            color: #64748b;
            font-size: 12px;
        }

        .assign-kpi .value {
            font-size: 18px;
            font-weight: 700;
        }

        .assign-stock {
            background: #fff;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .assign-stock.complete {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border-color: #15803d;
            color: #f0fdf4;
            box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.35), 0 6px 12px rgba(22, 163, 74, 0.35);
        }

        .assign-stock.complete .assign-token {
            background: linear-gradient(180deg, #4ade80, #22c55e);
            color: #064e3b;
        }

        .assign-token {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 90px;
            height: 36px;
            border-radius: 8px;
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            color: #fff;
            font-weight: 800;
            cursor: grab;
            user-select: none;
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.35);
            border: 1px solid #1d4ed8;
            font-size: 13px;
        }

        .assign-token:active {
            cursor: grabbing;
        }

        .assign-ghost {
            position: fixed;
            z-index: 10001;
            pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0.9;
            filter: drop-shadow(0 6px 16px rgba(0, 0, 0, 0.25));
        }

        .assign-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .assign-actions .button-row-1 {
            display: flex;
            gap: 4px;
        }

        .assign-actions .button-row-2 {
            display: flex;
            justify-content: center;
        }

        .assign-actions .assign-btn {
            flex: 1;
            font-size: 11px;
            padding: 6px 8px;
            white-space: nowrap;
        }

        .assign-actions .button-row-2 .assign-btn {
            flex: none;
            min-width: 80px;
        }

        .assign-actions .primary {
            background: linear-gradient(180deg, #3b82f6, #2563eb);
            border-color: #1d4ed8;
            color: #fff;
        }

        .assign-actions .danger {
            background: linear-gradient(180deg, #ef4444, #dc2626);
            border-color: #b91c1c;
            color: #fff;
        }

        .assign-actions .reset {
            background: linear-gradient(180deg, #f59e0b, #d97706);
            border-color: #92400e;
            color: #fff;
        }

        .assign-reservation-info {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 16px 14px;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 14px;
        }

        .assign-reservation-info h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 4px;
        }

        .assign-reservation-info .info-row {
            margin-bottom: 4px;
            display: flex;
            gap: 8px;
        }

        .assign-reservation-info .info-label {
            font-weight: 600;
            color: #4b5563;
            min-width: 72px;
            font-size: 13px;
        }

        .assign-reservation-info .info-value {
            color: #1f2937;
            flex: 1;
            font-size: 14px;
        }

        .assign-reservation-info .info-categories {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .assign-reservation-info .info-category {
            background: #f3f4f6;
            color: #374151;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }

        .assign-ablage-rooms {
            background: #fffbeb;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
        }

        .assign-ablage-rooms h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            font-weight: 600;
            color: #92400e;
            border-bottom: 1px solid #f59e0b;
            padding-bottom: 4px;
        }

        .assign-ablage-room {
            background: #fef3c7;
            border: 1px solid #d97706;
            border-radius: 4px;
            padding: 6px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .assign-ablage-room:hover {
            background: #fde68a;
            border-color: #b45309;
        }

        .assign-ablage-room.drop-target {
            background: #ecfdf5;
            border-color: #10b981;
        }

        .assign-ablage-room-title {
            font-size: 11px;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 2px;
        }

        .assign-ablage-room-meta {
            font-size: 9px;
            color: #a16207;
        }

        @media (max-width: 1100px) {
            .assign-body {
                flex-direction: column;
            }

            .assign-sidebar {
                width: 100%;
                order: -1;
            }
        }

        /* Debug Console Styles */
        .debug-console {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 400px;
            height: 300px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-bottom: none;
            border-right: none;
            box-shadow: -4px -4px 12px rgba(0, 0, 0, 0.3);
            z-index: 9998;
            display: none;
            flex-direction: column;
        }

        .debug-console.active {
            display: flex;
        }

        .debug-console-header {
            background: #333;
            color: #f5f5f5;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #555;
        }

        .debug-console-controls {
            display: flex;
            gap: 8px;
        }

        .debug-console-btn {
            background: #555;
            color: #f5f5f5;
            border: none;
            padding: 2px 6px;
            font-size: 10px;
            border-radius: 2px;
            cursor: pointer;
        }

        .debug-console-btn:hover {
            background: #666;
        }

        .debug-console-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.3;
        }

        .debug-log-entry {
            margin-bottom: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .debug-log-timestamp {
            color: #888;
        }

        .debug-log-level-info {
            color: #5bc0de;
        }

        .debug-log-level-warn {
            color: #f0ad4e;
        }

        .debug-log-level-error {
            color: #d9534f;
        }

        .debug-log-level-success {
            color: #5cb85c;
        }

        /* Debug Toggle Button */
        .debug-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: #333;
            color: #f5f5f5;
            border: 1px solid #555;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 9999;
            font-family: 'Courier New', monospace;
        }

        .debug-toggle:hover {
            background: #444;
        }

        /* Debug console disabled by default */
        #debug-console,
        #debug-toggle {
            display: none !important;
        }
    </style>
</head>

<body>
    <div class="main-areas-container"></div>
    <div id="timeline-radial-menu" class="radial-menu"></div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal-overlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <span class="icon">⚠️</span>
                <span id="modal-title">Bestätigung erforderlich</span>
            </div>
            <div class="modal-body">
                <p id="modal-message">Sind Sie sicher, dass Sie diese Aktion ausführen möchten?</p>
            </div>
            <div class="modal-actions">
                <button id="modal-cancel" class="modal-button modal-button-cancel">Abbrechen</button>
                <button id="modal-confirm" class="modal-button modal-button-danger">Löschen</button>
            </div>
        </div>
    </div>

    <!-- Designation Edit Modal -->
    <div id="designation-modal" class="modal-overlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <span class="icon">✏️</span>
                <span>Bezeichnung bearbeiten</span>
            </div>
            <div class="modal-body">
                <label for="designation-input"
                    style="color: #cccccc; font-size: 14px; display: block; margin-bottom: 8px;">
                    Neue Bezeichnung:
                </label>
                <input type="text" id="designation-input" class="modal-input" placeholder="Bezeichnung eingeben...">

                <div id="designation-multiple-options" class="modal-checkbox-group" style="display: none;">
                    <input type="checkbox" id="designation-update-all" class="modal-checkbox">
                    <label for="designation-update-all" class="modal-checkbox-label">
                        Alle Zimmer-Zuweisungen dieser Reservierung aktualisieren
                    </label>
                </div>
            </div>
            <div class="modal-actions">
                <button id="designation-cancel" class="modal-button modal-button-cancel">Abbrechen</button>
                <button id="designation-save" class="modal-button modal-button-primary">Speichern</button>
            </div>
        </div>
    </div>

    <!-- Notes Edit Modal -->
    <div id="notes-modal" class="modal-overlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <span>Notiz</span>
            </div>
            <div class="modal-body">
                <label for="notes-textarea"
                    style="color: #cccccc; font-size: 14px; display: block; margin-bottom: 8px;">
                    Notiz-Text:
                </label>
                <textarea id="notes-textarea" class="modal-textarea" placeholder="Ihre Notiz hier eingeben..."
                    rows="4"></textarea>

                <div class="modal-char-counter"
                    style="text-align: right; color: #999; font-size: 11px; margin-top: -8px; margin-bottom: 8px;">
                    <span id="notes-char-count">0</span> Zeichen
                </div>
            </div>
            <div class="modal-actions">
                <button id="notes-cancel" class="modal-button modal-button-cancel">Abbrechen</button>
                <button id="notes-clear" class="modal-button modal-button-secondary"
                    style="display: none;">Löschen</button>
                <button id="notes-save" class="modal-button modal-button-primary">Speichern</button>
            </div>
        </div>
    </div>

    <!-- Dataset Edit Modal -->
    <div id="dataset-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 900px; width: 95vw;">
            <div class="modal-header">
                <span class="icon">📋</span>
                <span>AV-Res Stammdaten bearbeiten</span>
                <div id="dataset-av-indicator"
                    style="display: none; margin-left: auto; background: #27ae60; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                    AV-Reservierung (av_id: <span id="dataset-av-id-display"></span>)
                </div>
            </div>
            <div class="modal-body" style="max-height: 75vh; overflow-y: auto;">

                <!-- Grunddaten -->
                <div class="dataset-section">
                    <h3 class="dataset-section-title">📋 Grunddaten</h3>
                    <div class="dataset-grid">
                        <div class="dataset-field">
                            <label for="dataset-av-id">AV-ID:</label>
                            <input type="text" id="dataset-av-id" class="modal-input" readonly>
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-storno">Storno:</label>
                            <select id="dataset-storno" class="modal-input">
                                <option value="0">Aktiv</option>
                                <option value="1">Storniert</option>
                            </select>
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-hund">Hund:</label>
                            <select id="dataset-hund" class="modal-input">
                                <option value="0">Nein</option>
                                <option value="1">Ja</option>
                            </select>
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-arr">Arrangement:</label>
                            <select id="dataset-arr" class="modal-input">
                                <option value="">Kein Arrangement</option>
                                <!-- Wird dynamisch befüllt -->
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Aufenthaltsdaten -->
                <div class="dataset-section">
                    <h3 class="dataset-section-title">🏨 Aufenthaltsdaten</h3>
                    <div class="dataset-grid">
                        <div class="dataset-field">
                            <label for="dataset-anreise">Anreise:</label>
                            <input type="date" id="dataset-anreise" class="modal-input">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-abreise">Abreise:</label>
                            <input type="date" id="dataset-abreise" class="modal-input">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-lager">Lager:</label>
                            <input type="number" id="dataset-lager" class="modal-input" min="0">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-betten">Betten:</label>
                            <input type="number" id="dataset-betten" class="modal-input" min="0">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-dz">Doppelzimmer:</label>
                            <input type="number" id="dataset-dz" class="modal-input" min="0">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-sonder">Plätze:</label>
                            <input type="number" id="dataset-sonder" class="modal-input" min="0">
                        </div>
                    </div>
                </div>

                <!-- Gästeinformationen -->
                <div class="dataset-section">
                    <h3 class="dataset-section-title">👤 Gästeinformationen</h3>
                    <div class="dataset-grid">
                        <div class="dataset-field">
                            <label for="dataset-vorname">Vorname:</label>
                            <input type="text" id="dataset-vorname" class="modal-input">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-nachname">Nachname:</label>
                            <input type="text" id="dataset-nachname" class="modal-input">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-email">E-Mail:</label>
                            <input type="email" id="dataset-email" class="modal-input">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-handy">Handy:</label>
                            <input type="tel" id="dataset-handy" class="modal-input">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-email-date">Email-Datum:</label>
                            <input type="text" id="dataset-email-date" class="modal-input" placeholder="dd.mm.yyyy">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-origin">Herkunft:</label>
                            <select id="dataset-origin" class="modal-input">
                                <option value="">Keine Herkunft</option>
                                <!-- Wird dynamisch befüllt -->
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Zusatzinformationen -->
                <div class="dataset-section">
                    <h3 class="dataset-section-title">ℹ️ Zusatzinformationen</h3>
                    <div class="dataset-grid">
                        <div class="dataset-field">
                            <label for="dataset-gruppe">Gruppenname:</label>
                            <input type="text" id="dataset-gruppe" class="modal-input">
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-bem">Bemerkungen (allgemein):</label>
                            <textarea id="dataset-bem" class="modal-input" rows="3"></textarea>
                        </div>
                        <div class="dataset-field">
                            <label for="dataset-bem-av">Bemerkungen (AV):</label>
                            <textarea id="dataset-bem-av" class="modal-input" rows="3"></textarea>
                        </div>
                    </div>
                </div>

            </div>
            <div class="modal-actions">
                <button id="dataset-cancel" class="modal-button modal-button-cancel">Abbrechen</button>
                <button id="dataset-save" class="modal-button modal-button-primary">Speichern</button>
            </div>
        </div>
    </div>

    <!-- Room Assignment Modal -->
    <div id="assignModal" class="assign-modal" aria-hidden="true">
        <div class="assign-backdrop" data-close="assign"></div>
        <div class="assign-card" role="dialog" aria-modal="true" aria-labelledby="assignTitle">
            <div class="assign-body">
                <div class="assign-sidebar">
                    <div id="assignReservationInfo" class="assign-reservation-info">
                        <!-- Reservierungsdetails werden hier eingefügt -->
                    </div>
                    <div id="assignStock" class="assign-stock">
                        <div>zu Disponieren</div>
                        <div id="assignToken" class="assign-token" title="Ziehen, um 1 Einheit zuzuweisen">0</div>
                    </div>
                    <div class="assign-kpis">
                        <div class="assign-kpi">
                            <div class="label">Zugewiesen</div>
                            <div id="kpiAssigned" class="value">0</div>
                        </div>
                        <div class="assign-kpi">
                            <div class="label">Benötigt</div>
                            <div id="kpiRemaining" class="value">0</div>
                        </div>
                    </div>
                    <div class="assign-actions">
                        <div class="button-row-1">
                            <button id="assignReset" class="assign-btn reset">Reset</button>
                            <button id="assignSave" class="assign-btn primary">Save</button>
                        </div>
                        <div class="button-row-2">
                            <button id="assignCancel" class="assign-btn">Cancel</button>
                        </div>
                    </div>
                    <div id="assignAblageRooms" class="assign-ablage-rooms">
                        <!-- Ablage-Zimmer werden hier eingefügt -->
                    </div>
                    <div id="assignInfo" class="assign-info"></div>
                </div>
                <div class="assign-grid">
                    <div id="assignGridInner" class="assign-grid-inner"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Console -->
    <div id="debug-console" class="debug-console">
        <div class="debug-console-header">
            <span>🐛 Debug Console</span>
            <div class="debug-console-controls">
                <button id="debug-clear" class="debug-console-btn">Clear</button>
                <button id="debug-export" class="debug-console-btn">Export</button>
                <button id="debug-close" class="debug-console-btn">✕</button>
            </div>
        </div>
        <div id="debug-console-content" class="debug-console-content">
            <!-- Debug logs will appear here -->
        </div>
    </div>

    <!-- Debug Toggle Button -->
    <button id="debug-toggle" class="debug-toggle">Debug Console</button>

    <!-- Scripts -->
    <script src="timeline-unified.js"></script>
    <script>
        if (typeof TimelineUnifiedRenderer === 'undefined') {
            console.error('FEHLER: TimelineUnifiedRenderer wurde nicht geladen!');
        }

        // ===== MODAL HELPER (Bootstrap 5) =====
        /**
         * ModalHelper - Bootstrap 5 Modal Wrapper
         * Provides alert, confirm, and prompt dialogs using Bootstrap 5 modals
         */
        const ModalHelper = {
            /**
             * Show alert dialog
             * @param {string} message - Message to display
             * @param {string} title - Dialog title (optional)
             * @returns {Promise<void>}
             */
            alert: function (message, title = 'Information') {
                return new Promise((resolve) => {
                    // Remove existing modal if present
                    const existingModal = document.getElementById('modal-helper-alert');
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Create modal HTML
                    const modalHtml = `
                        <div class="modal fade" id="modal-helper-alert" tabindex="-1" aria-labelledby="modalAlertTitle" aria-hidden="true">
                            <div class="modal-dialog modal-dialog-centered">
                                <div class="modal-content" style="background: #2d2d2d; border: 1px solid #444;">
                                    <div class="modal-header" style="border-bottom: 1px solid #444;">
                                        <h5 class="modal-title" id="modalAlertTitle" style="color: #fff;">${title}</h5>
                                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body" style="color: #e0e0e0; white-space: pre-wrap;">
                                        ${message}
                                    </div>
                                    <div class="modal-footer" style="border-top: 1px solid #444;">
                                        <button type="button" class="btn btn-primary" data-bs-dismiss="modal" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none;">OK</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Add to DOM
                    document.body.insertAdjacentHTML('beforeend', modalHtml);

                    // Initialize and show modal
                    const modalElement = document.getElementById('modal-helper-alert');
                    const modal = new bootstrap.Modal(modalElement);

                    // Resolve on close
                    modalElement.addEventListener('hidden.bs.modal', () => {
                        modalElement.remove();
                        resolve();
                    }, { once: true });

                    modal.show();
                });
            },

            /**
             * Show confirm dialog
             * @param {string} message - Message to display
             * @param {string} title - Dialog title (optional)
             * @returns {Promise<boolean>} - true if confirmed, false if cancelled
             */
            confirm: function (message, title = 'Bestätigung') {
                return new Promise((resolve) => {
                    // Remove existing modal if present
                    const existingModal = document.getElementById('modal-helper-confirm');
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Create modal HTML
                    const modalHtml = `
                        <div class="modal fade" id="modal-helper-confirm" tabindex="-1" aria-labelledby="modalConfirmTitle" aria-hidden="true">
                            <div class="modal-dialog modal-dialog-centered">
                                <div class="modal-content" style="background: #2d2d2d; border: 1px solid #444;">
                                    <div class="modal-header" style="border-bottom: 1px solid #444;">
                                        <h5 class="modal-title" id="modalConfirmTitle" style="color: #fff;">${title}</h5>
                                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body" style="color: #e0e0e0; white-space: pre-wrap;">
                                        ${message}
                                    </div>
                                    <div class="modal-footer" style="border-top: 1px solid #444;">
                                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" id="modal-confirm-cancel" style="background: #555; border: none;">Abbrechen</button>
                                        <button type="button" class="btn btn-primary" id="modal-confirm-ok" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none;">OK</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Add to DOM
                    document.body.insertAdjacentHTML('beforeend', modalHtml);

                    // Initialize modal
                    const modalElement = document.getElementById('modal-helper-confirm');
                    const modal = new bootstrap.Modal(modalElement);

                    // Handle buttons
                    const okBtn = document.getElementById('modal-confirm-ok');
                    const cancelBtn = document.getElementById('modal-confirm-cancel');

                    okBtn.addEventListener('click', () => {
                        modal.hide();
                        resolve(true);
                    }, { once: true });

                    cancelBtn.addEventListener('click', () => {
                        modal.hide();
                        resolve(false);
                    }, { once: true });

                    // Resolve false on backdrop click or ESC
                    modalElement.addEventListener('hidden.bs.modal', () => {
                        modalElement.remove();
                    }, { once: true });

                    modal.show();
                });
            },

            /**
             * Show prompt dialog
             * @param {string} message - Message to display
             * @param {string} defaultValue - Default input value (optional)
             * @param {string} title - Dialog title (optional)
             * @returns {Promise<string|null>} - Input value if confirmed, null if cancelled
             */
            prompt: function (message, defaultValue = '', title = 'Eingabe') {
                return new Promise((resolve) => {
                    // Remove existing modal if present
                    const existingModal = document.getElementById('modal-helper-prompt');
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Create modal HTML
                    const modalHtml = `
                        <div class="modal fade" id="modal-helper-prompt" tabindex="-1" aria-labelledby="modalPromptTitle" aria-hidden="true">
                            <div class="modal-dialog modal-dialog-centered">
                                <div class="modal-content" style="background: #2d2d2d; border: 1px solid #444;">
                                    <div class="modal-header" style="border-bottom: 1px solid #444;">
                                        <h5 class="modal-title" id="modalPromptTitle" style="color: #fff;">${title}</h5>
                                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body">
                                        <p style="color: #e0e0e0; white-space: pre-wrap; margin-bottom: 12px;">${message}</p>
                                        <input type="text" class="form-control" id="modal-prompt-input" value="${defaultValue}" style="background: #1e1e1e; border: 1px solid #444; color: #fff;">
                                    </div>
                                    <div class="modal-footer" style="border-top: 1px solid #444;">
                                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" id="modal-prompt-cancel" style="background: #555; border: none;">Abbrechen</button>
                                        <button type="button" class="btn btn-primary" id="modal-prompt-ok" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none;">OK</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Add to DOM
                    document.body.insertAdjacentHTML('beforeend', modalHtml);

                    // Initialize modal
                    const modalElement = document.getElementById('modal-helper-prompt');
                    const modal = new bootstrap.Modal(modalElement);
                    const input = document.getElementById('modal-prompt-input');
                    const okBtn = document.getElementById('modal-prompt-ok');
                    const cancelBtn = document.getElementById('modal-prompt-cancel');

                    // Focus input when modal is shown
                    modalElement.addEventListener('shown.bs.modal', () => {
                        input.focus();
                        input.select();
                    }, { once: true });

                    // Handle OK button
                    okBtn.addEventListener('click', () => {
                        modal.hide();
                        resolve(input.value);
                    }, { once: true });

                    // Handle Cancel button
                    cancelBtn.addEventListener('click', () => {
                        modal.hide();
                        resolve(null);
                    }, { once: true });

                    // Handle Enter key in input
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            modal.hide();
                            resolve(input.value);
                        }
                    });

                    // Clean up on close
                    modalElement.addEventListener('hidden.bs.modal', () => {
                        modalElement.remove();
                    }, { once: true });

                    modal.show();
                });
            }
        };

        // ===== GLOBAL VARIABLES =====
        let timelineRenderer = null; // Timeline-Renderer-Instanz
        window.arrangementsCatalog = [];
        window.histogramSource = [];
        window.histogramStornoSource = [];
        window.histogramAvailability = [];

        const TIMELINE_THEME_PRESETS = {
            professional: {
                label: 'Professional',
                sidebar: { bg: '#2c3e50', text: '#ecf0f1' },
                header: { bg: '#34495e', text: '#ecf0f1' },
                master: { bg: '#2c3e50', bar: '#3498db' },
                room: { bg: '#2c3e50', bar: '#27ae60' },
                histogram: { bg: '#34495e', bar: '#e74c3c', text: '#ecf0f1' }
            },
            comfort: {
                label: 'Comfort',
                sidebar: { bg: '#f8f9fa', text: '#495057' },
                header: { bg: '#ffffff', text: '#343a40' },
                master: { bg: '#f1f3f4', bar: '#007bff' },
                room: { bg: '#f1f3f4', bar: '#28a745' },
                histogram: { bg: '#ffffff', bar: '#17a2b8', text: '#495057' }
            },
            focus: {
                label: 'Focus',
                sidebar: { bg: '#1a1a2e', text: '#ffffff' },
                header: { bg: '#16213e', text: '#ffffff' },
                master: { bg: '#0f3460', bar: '#e94560' },
                room: { bg: '#0f3460', bar: '#f39c12' },
                histogram: { bg: '#16213e', bar: '#e94560', text: '#ffffff' }
            },
            nature: {
                label: 'Nature',
                sidebar: { bg: '#2d5016', text: '#a8e6cf' },
                header: { bg: '#5d4e75', text: '#ffffff' },
                master: { bg: '#134e5e', bar: '#71b280' },
                room: { bg: '#134e5e', bar: '#ffd3a5' },
                histogram: { bg: '#5d4e75', bar: '#a8e6cf', text: '#ffffff' }
            },
            ocean: {
                label: 'Ocean',
                sidebar: { bg: '#1e3a8a', text: '#dbeafe' },
                header: { bg: '#1e40af', text: '#dbeafe' },
                master: { bg: '#155e75', bar: '#06b6d4' },
                room: { bg: '#155e75', bar: '#0891b2' },
                histogram: { bg: '#1e40af', bar: '#0ea5e9', text: '#dbeafe' }
            },
            sunset: {
                label: 'Sunset',
                sidebar: { bg: '#7c2d12', text: '#fed7aa' },
                header: { bg: '#9a3412', text: '#fed7aa' },
                master: { bg: '#a16207', bar: '#f59e0b' },
                room: { bg: '#a16207', bar: '#dc2626' },
                histogram: { bg: '#9a3412', bar: '#ea580c', text: '#fed7aa' }
            },
            earth: {
                label: 'Earth',
                sidebar: { bg: '#44403c', text: '#d6d3d1' },
                header: { bg: '#57534e', text: '#d6d3d1' },
                master: { bg: '#78716c', bar: '#a3a3a3' },
                room: { bg: '#78716c', bar: '#84cc16' },
                histogram: { bg: '#57534e', bar: '#eab308', text: '#d6d3d1' }
            },
            rainbow: {
                label: 'Rainbow',
                sidebar: { bg: '#f1f5f9', text: '#475569' },
                header: { bg: '#e2e8f0', text: '#475569' },
                master: { bg: '#fef3c7', bar: '#8b5cf6' },
                room: { bg: '#fef3c7', bar: '#10b981' },
                histogram: { bg: '#e2e8f0', bar: '#f59e0b', text: '#475569' }
            },
            grayscale: {
                label: 'Grayscale',
                sidebar: { bg: '#1f2937', text: '#f9fafb' },
                header: { bg: '#374151', text: '#f9fafb' },
                master: { bg: '#4b5563', bar: '#9ca3af' },
                room: { bg: '#4b5563', bar: '#6b7280' },
                histogram: { bg: '#374151', bar: '#d1d5db', text: '#f9fafb' }
            }
        };

        function getTimelineRenderer() {
            if (timelineRenderer) return timelineRenderer;
            if (typeof TimelineUnifiedRenderer !== 'undefined') {
                return TimelineUnifiedRenderer.instance || null;
            }
            return null;
        }

        function cloneTimelineConfig(config) {
            return JSON.parse(JSON.stringify(config || {}));
        }

        function persistTimelineThemeConfig(config) {
            try {
                const configString = JSON.stringify(config);
                const expires = new Date();
                expires.setFullYear(expires.getFullYear() + 1);
                document.cookie = `timeline_config=${encodeURIComponent(configString)}; expires=${expires.toUTCString()}; path=/`;
                localStorage.setItem('timeline_config', configString);
            } catch (error) {
                console.warn('Timeline-Konfiguration konnte nicht gespeichert werden:', error);
            }
        }

        function clampNumber(value, min, max) {
            const num = Number(value);
            if (!Number.isFinite(num)) return min;
            return Math.max(min, Math.min(max, num));
        }

        function detectTimelinePreset(config) {
            if (!config) return 'custom';

            const matchesPreset = (preset) => {
                const sectionMatches = (sectionName, keys) => {
                    const presetSection = preset[sectionName];
                    const configSection = config[sectionName] || {};
                    if (!presetSection) return true;
                    return keys.every(key => presetSection[key] === configSection[key]);
                };

                return sectionMatches('sidebar', ['bg', 'text']) &&
                    sectionMatches('header', ['bg', 'text']) &&
                    sectionMatches('master', ['bg', 'bar']) &&
                    sectionMatches('room', ['bg', 'bar']) &&
                    sectionMatches('histogram', ['bg', 'bar', 'text']);
            };

            for (const [key, preset] of Object.entries(TIMELINE_THEME_PRESETS)) {
                if (matchesPreset(preset)) {
                    return key;
                }
            }

            return 'custom';
        }

        function applyTimelinePreset(presetKey) {
            const renderer = getTimelineRenderer();
            const preset = TIMELINE_THEME_PRESETS[presetKey];
            if (!renderer || !preset) return;

            const baseConfig = cloneTimelineConfig(renderer.themeConfig || renderer.loadThemeConfiguration?.() || {});
            const updatedConfig = {
                sidebar: { ...preset.sidebar, fontSize: baseConfig.sidebar?.fontSize ?? 12 },
                header: { ...preset.header, fontSize: baseConfig.header?.fontSize ?? 10 },
                master: {
                    ...preset.master,
                    fontSize: baseConfig.master?.fontSize ?? 10,
                    barHeight: baseConfig.master?.barHeight ?? renderer.MASTER_BAR_HEIGHT ?? 16
                },
                room: {
                    ...preset.room,
                    fontSize: baseConfig.room?.fontSize ?? 10,
                    barHeight: baseConfig.room?.barHeight ?? renderer.ROOM_BAR_HEIGHT ?? 16
                },
                histogram: {
                    ...preset.histogram,
                    fontSize: baseConfig.histogram?.fontSize ?? 9
                },
                dayWidth: baseConfig.dayWidth ?? renderer.DAY_WIDTH ?? 90,
                weeksPast: baseConfig.weeksPast ?? 2,
                weeksFuture: baseConfig.weeksFuture ?? 104
            };

            persistTimelineThemeConfig(updatedConfig);
            renderer.themeConfig = updatedConfig;
            renderer.refreshThemeConfiguration();
            renderer.updateTopbarVisuals?.();
            updateTimelineToolbarValues();
            try {
                localStorage.setItem('timeline_theme_preset', presetKey);
            } catch (error) {
                console.warn('Konnte timeline_theme_preset nicht speichern:', error);
            }
        }

        function updateTimelineWeekRange(past, future) {
            const renderer = getTimelineRenderer();
            if (!renderer) return;

            const sanitizedPast = clampNumber(past, 0, 52);
            const sanitizedFuture = clampNumber(future, 4, 208);
            const currentConfig = cloneTimelineConfig(renderer.themeConfig || renderer.loadThemeConfiguration?.() || {});

            if (currentConfig.weeksPast === sanitizedPast && currentConfig.weeksFuture === sanitizedFuture) {
                updateTimelineToolbarValues();
                return;
            }

            currentConfig.weeksPast = sanitizedPast;
            currentConfig.weeksFuture = sanitizedFuture;

            persistTimelineThemeConfig(currentConfig);
            renderer.themeConfig = currentConfig;
            renderer.refreshThemeConfiguration();
            renderer.updateTopbarVisuals?.();
            updateTimelineToolbarValues();

            try {
                const detected = detectTimelinePreset(currentConfig);
                localStorage.setItem('timeline_theme_preset', detected);
            } catch (error) {
                console.warn('Konnte timeline_theme_preset nicht speichern:', error);
            }

            if (typeof window.reloadTimelineData === 'function') {
                window.reloadTimelineData();
            }
        }

        function updateTimelineToolbarValues() {
            const renderer = getTimelineRenderer();
            const toolbar = document.getElementById('timeline-toolbar');
            if (!renderer || !toolbar) return;

            const config = renderer.themeConfig || {};

            const presetSelect = document.getElementById('timeline-preset-select');
            if (presetSelect) {
                let presetKey = detectTimelinePreset(config);
                if (!presetSelect.querySelector(`option[value="${presetKey}"]`)) {
                    presetKey = 'custom';
                }
                presetSelect.value = presetKey;
            }

            const menuSizeSlider = document.getElementById('timeline-menu-size');
            const menuSizeDisplay = document.getElementById('timeline-menu-size-display');
            if (menuSizeSlider && menuSizeDisplay) {
                let storedSize = null;
                try {
                    const stored = localStorage.getItem('timeline_menu_size');
                    if (stored) {
                        const parsed = parseInt(stored, 10);
                        if (!Number.isNaN(parsed)) {
                            storedSize = parsed;
                        }
                    }
                } catch (error) {
                    console.warn('Konnte timeline_menu_size nicht laden:', error);
                }

                const currentSize = storedSize ?? renderer.radialMenu?.size ?? 220;
                menuSizeSlider.value = String(currentSize);
                menuSizeDisplay.textContent = `${currentSize}px`;
            }

            const weeksPastInput = document.getElementById('timeline-weeks-past');
            const weeksFutureInput = document.getElementById('timeline-weeks-future');
            if (weeksPastInput) {
                weeksPastInput.value = String(config.weeksPast ?? 2);
            }
            if (weeksFutureInput) {
                weeksFutureInput.value = String(config.weeksFuture ?? 104);
            }
        }

        /**
         * Create Import Progress Modal (Compact Version)
         * @param {string} dateFrom - Start date
         * @param {string} dateTo - End date
         * @param {number} dayCount - Number of days
         * @returns {bootstrap.Modal} Modal instance
         */
        function createImportProgressModal(dateFrom, dateTo, dayCount) {
            // Remove existing modal if present
            const existingModal = document.getElementById('hrs-import-progress-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal HTML (Compact)
            const modalHtml = `
                <div class="modal fade" id="hrs-import-progress-modal" tabindex="-1" aria-labelledby="hrsImportProgressTitle" data-bs-backdrop="static" data-bs-keyboard="false">
                    <div class="modal-dialog modal-dialog-centered" style="max-width: 500px;">
                        <div class="modal-content" style="background: #1e1e1e; border: 1px solid #444;">
                            <div class="modal-header" style="border-bottom: 1px solid #444; padding: 12px 16px;">
                                <h6 class="modal-title" id="hrsImportProgressTitle" style="color: #fff; margin: 0; font-size: 14px;">
                                    <span style="color: #8b5cf6;">📥</span> HRS Import: ${dateFrom} - ${dateTo} (${dayCount} Tage)
                                </h6>
                            </div>
                            <div class="modal-body" style="padding: 12px;">
                                <!-- Progress Steps (Compact) -->
                                <div style="display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px;">
                                    <div class="import-step" data-step="daily" style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px; border-left: 2px solid #666;">
                                        <span class="step-icon" style="font-size: 14px;">⏸️</span>
                                        <span class="step-title" style="color: #fff; font-size: 12px; flex: 1;">Daily</span>
                                        <span class="step-status" style="color: #888; font-size: 11px;">...</span>
                                    </div>
                                    <div class="import-step" data-step="quota" style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px; border-left: 2px solid #666;">
                                        <span class="step-icon" style="font-size: 14px;">⏸️</span>
                                        <span class="step-title" style="color: #fff; font-size: 12px; flex: 1;">Quota</span>
                                        <span class="step-status" style="color: #888; font-size: 11px;">...</span>
                                    </div>
                                    <div class="import-step" data-step="res" style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px; border-left: 2px solid #666;">
                                        <span class="step-icon" style="font-size: 14px;">⏸️</span>
                                        <span class="step-title" style="color: #fff; font-size: 12px; flex: 1;">Reserv.</span>
                                        <span class="step-status" style="color: #888; font-size: 11px;">...</span>
                                    </div>
                                    <div class="import-step" data-step="avcap" style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px; border-left: 2px solid #666;">
                                        <span class="step-icon" style="font-size: 14px;">⏸️</span>
                                        <span class="step-title" style="color: #fff; font-size: 12px; flex: 1;">AV Cap</span>
                                        <span class="step-status" style="color: #888; font-size: 11px;">...</span>
                                    </div>
                                </div>
                                
                                <!-- Live Log (Compact, Auto-Scroll) -->
                                <div id="import-live-log" style="height: 150px; overflow-y: auto; background: #0d0d0d; border: 1px solid #333; border-radius: 4px; padding: 8px; font-family: 'Courier New', monospace; font-size: 10px; line-height: 1.4;">
                                    <!-- Log entries will be added here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Initialize Bootstrap modal
            const modalElement = document.getElementById('hrs-import-progress-modal');
            const modal = new bootstrap.Modal(modalElement);

            // Fix aria-hidden warning: Bootstrap sets it but keeps focus inside
            modalElement.addEventListener('shown.bs.modal', function () {
                modalElement.removeAttribute('aria-hidden');
            });
            modalElement.addEventListener('hidden.bs.modal', function () {
                modalElement.setAttribute('aria-hidden', 'true');
            });

            return modal;
        }

        /**
         * Update Import Progress
         * @param {bootstrap.Modal} modal - Modal instance
         * @param {string} step - Step identifier (daily, quota, res, avcap, complete)
         * @param {string} status - Status (running, success, error)
         * @param {string} message - Status message
         */
        function updateImportProgress(modal, step, status, message) {
            const modalElement = document.getElementById('hrs-import-progress-modal');
            if (!modalElement) return;

            if (step === 'complete') {
                const overallStatus = modalElement.querySelector('#import-overall-status');
                if (overallStatus) {
                    if (status === 'success') {
                        overallStatus.innerHTML = '✅ ' + message;
                        overallStatus.style.background = 'rgba(34, 197, 94, 0.1)';
                        overallStatus.style.borderColor = 'rgba(34, 197, 94, 0.3)';
                        overallStatus.style.color = '#4ade80';
                    } else {
                        overallStatus.innerHTML = '❌ ' + message;
                        overallStatus.style.background = 'rgba(239, 68, 68, 0.1)';
                        overallStatus.style.borderColor = 'rgba(239, 68, 68, 0.3)';
                        overallStatus.style.color = '#f87171';
                    }
                }
                return;
            }

            const stepElement = modalElement.querySelector(`.import-step[data-step="${step}"]`);
            if (!stepElement) return;

            const icon = stepElement.querySelector('.step-icon');
            const statusText = stepElement.querySelector('.step-status');

            // Update based on status
            if (status === 'running') {
                stepElement.style.borderColor = '#8b5cf6';
                stepElement.style.background = 'rgba(139, 92, 246, 0.1)';
                icon.innerHTML = '⏳';
                statusText.innerHTML = message;
                statusText.style.color = '#a78bfa';
            } else if (status === 'success') {
                stepElement.style.borderColor = '#22c55e';
                stepElement.style.background = 'rgba(34, 197, 94, 0.1)';
                icon.innerHTML = '✅';
                statusText.innerHTML = message;
                statusText.style.color = '#4ade80';
            } else if (status === 'error') {
                stepElement.style.borderColor = '#ef4444';
                stepElement.style.background = 'rgba(239, 68, 68, 0.1)';
                icon.innerHTML = '❌';
                statusText.innerHTML = message;
                statusText.style.color = '#f87171';
            }
        }

        /**
         * Add log entry to import live log
         * @param {string} message - Log message
         * @param {string} type - Log type (info, success, error, warn)
         */
        function addImportLog(message, type = 'info') {
            const logContainer = document.getElementById('import-live-log');
            if (!logContainer) return;

            // Show log container if hidden
            if (logContainer.style.display === 'none') {
                logContainer.style.display = 'block';
            }

            // Create log entry
            const timestamp = new Date().toLocaleTimeString('de-DE', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });

            let color = '#a0a0a0'; // info
            let icon = '•';

            if (type === 'success') {
                color = '#4ade80';
                icon = '✓';
            } else if (type === 'error') {
                color = '#f87171';
                icon = '✗';
            } else if (type === 'warn') {
                color = '#fbbf24';
                icon = '⚠';
            }

            const logEntry = document.createElement('div');
            logEntry.style.cssText = `color: ${color}; margin-bottom: 4px; line-height: 1.4;`;
            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${icon} ${message}`;

            logContainer.appendChild(logEntry);

            // Auto-scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function setupTimelineToolbar() {
            const renderer = getTimelineRenderer();
            const toolbar = document.getElementById('timeline-toolbar');
            if (!renderer || !toolbar || toolbar.dataset.initialized === 'true') {
                return;
            }

            const toggle = document.getElementById('timeline-settings-toggle');
            const menu = document.getElementById('timeline-settings-menu');
            const presetSelect = document.getElementById('timeline-preset-select');
            const menuSizeSlider = document.getElementById('timeline-menu-size');
            const menuSizeDisplay = document.getElementById('timeline-menu-size-display');
            const weeksPastInput = document.getElementById('timeline-weeks-past');
            const weeksFutureInput = document.getElementById('timeline-weeks-future');

            if (toggle && menu) {
                const closeMenu = () => {
                    menu.dataset.open = 'false';
                    toggle.setAttribute('aria-expanded', 'false');
                };
                const openMenu = () => {
                    menu.dataset.open = 'true';
                    toggle.setAttribute('aria-expanded', 'true');
                };

                const handleToggle = (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    const isOpen = menu.dataset.open === 'true';
                    if (isOpen) {
                        closeMenu();
                    } else {
                        openMenu();
                    }
                };

                const handleOutsideClick = (event) => {
                    if (menu.dataset.open !== 'true') return;
                    if (!menu.contains(event.target) && event.target !== toggle) {
                        closeMenu();
                    }
                };

                const handleEscape = (event) => {
                    if (event.key === 'Escape' && menu.dataset.open === 'true') {
                        closeMenu();
                    }
                };

                toggle.setAttribute('aria-expanded', 'false');
                toggle.setAttribute('aria-haspopup', 'true');
                toggle.addEventListener('click', handleToggle);
                document.addEventListener('click', handleOutsideClick);
                document.addEventListener('keydown', handleEscape);
                menu.addEventListener('click', (event) => event.stopPropagation());
            }

            if (presetSelect) {
                presetSelect.addEventListener('change', (event) => {
                    const value = event.target.value;
                    if (value && value !== 'custom') {
                        applyTimelinePreset(value);
                    } else if (value === 'custom') {
                        try {
                            localStorage.removeItem('timeline_theme_preset');
                        } catch (error) {
                            console.warn('Konnte timeline_theme_preset nicht entfernen:', error);
                        }
                    }
                });
            }

            if (menuSizeSlider && menuSizeDisplay) {
                menuSizeSlider.addEventListener('input', (event) => {
                    const value = parseInt(event.target.value, 10);
                    if (!Number.isFinite(value)) return;
                    menuSizeDisplay.textContent = `${value}px`;
                    renderer.updateMenuSize(value);
                });

                menuSizeSlider.addEventListener('change', (event) => {
                    const value = parseInt(event.target.value, 10);
                    if (!Number.isFinite(value)) return;
                    try {
                        localStorage.setItem('timeline_menu_size', String(value));
                    } catch (error) {
                        console.warn('Konnte timeline_menu_size nicht speichern:', error);
                    }
                });
            }

            const handleWeeksChange = () => {
                const past = clampNumber(weeksPastInput?.value ?? 2, 0, 52);
                const future = clampNumber(weeksFutureInput?.value ?? 104, 4, 208);
                if (weeksPastInput) weeksPastInput.value = String(past);
                if (weeksFutureInput) weeksFutureInput.value = String(future);
                updateTimelineWeekRange(past, future);
            };

            if (weeksPastInput) {
                weeksPastInput.addEventListener('change', handleWeeksChange);
            }
            if (weeksFutureInput) {
                weeksFutureInput.addEventListener('change', handleWeeksChange);
            }

            // HRS Import Button Handler (with SSE for Daily Summary)
            const hrsImportBtn = document.getElementById('timeline-hrs-import-btn');
            if (hrsImportBtn) {
                hrsImportBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    event.stopPropagation();

                    // Check if days are selected
                    if (!renderer?.isHistogramDaySelectionActive || !renderer?.selectedHistogramDays || renderer.selectedHistogramDays.size === 0) {
                        await ModalHelper.alert('Bitte selektieren Sie zuerst Tage im Histogram (Strg+Klick oder Shift+Klick).');
                        return;
                    }

                    // Get date range from selected days
                    const { startDate } = renderer.getTimelineDateRange();
                    const selectedIndices = Array.from(renderer.selectedHistogramDays).sort((a, b) => a - b);
                    const minIndex = selectedIndices[0];
                    const maxIndex = selectedIndices[selectedIndices.length - 1];

                    const dateFrom = new Date(startDate.getTime() + minIndex * 24 * 60 * 60 * 1000);
                    const dateTo = new Date(startDate.getTime() + maxIndex * 24 * 60 * 60 * 1000);

                    const dateFromStr = dateFrom.toISOString().split('T')[0];
                    const dateToStr = dateTo.toISOString().split('T')[0];

                    const confirmed = await ModalHelper.confirm(
                        `HRS Daten importieren?\n\n` +
                        `Von: ${dateFromStr}\n` +
                        `Bis: ${dateToStr}\n` +
                        `Tage: ${selectedIndices.length}\n\n` +
                        `Dies importiert:\n` +
                        `• Daily Summary (Echtzeit-Fortschritt)\n` +
                        `• Quota (Kapazitäten)\n` +
                        `• Reservierungen\n` +
                        `• AV Capacity Update (für diesen Zeitraum)\n\n` +
                        `Dies kann einige Minuten dauern.`
                    );

                    if (!confirmed) return;

                    // Create Progress Modal
                    const progressModal = createImportProgressModal(dateFromStr, dateToStr, selectedIndices.length);
                    progressModal.show();

                    // Disable import button
                    hrsImportBtn.disabled = true;
                    hrsImportBtn.innerHTML = '⏳ Importiere...';

                    try {
                        // Step 1: Import Daily Summary with SSE (Server-Sent Events)
                        addImportLog('🚀 Starte Daily Summary Import mit Echtzeit-Updates...', 'info');
                        updateImportProgress(progressModal, 'daily', 'running', 'Verbinde mit Server...');

                        // Use SSE for Daily Summary
                        await new Promise((resolve, reject) => {
                            const eventSource = new EventSource(`../hrs/hrs_imp_daily_stream.php?from=${dateFromStr}&to=${dateToStr}`);
                            let dailySuccess = false;

                            eventSource.onmessage = (event) => {
                                try {
                                    const data = JSON.parse(event.data);

                                    switch (data.type) {
                                        case 'start':
                                            addImportLog(data.message, 'info');
                                            break;

                                        case 'phase':
                                            updateImportProgress(progressModal, data.step, 'running', data.message);
                                            addImportLog(`📋 ${data.name}: ${data.message}`, 'info');
                                            break;

                                        case 'total':
                                            addImportLog(`📊 ${data.count} Tage zu importieren`, 'info');
                                            break;

                                        case 'progress':
                                            const percent = data.percent || Math.round((data.current / data.total) * 100);
                                            updateImportProgress(progressModal, 'daily', 'running',
                                                `${data.current}/${data.total} (${percent}%) - ${data.day}`);
                                            break;

                                        case 'log':
                                            const icons = { info: 'ℹ️', success: '✓', error: '✗', warn: '⚠' };
                                            const icon = icons[data.level] || '';
                                            addImportLog(`${icon} ${data.message}`, data.level);
                                            break;

                                        case 'complete':
                                            dailySuccess = true;
                                            updateImportProgress(progressModal, data.step, 'success', data.message);
                                            addImportLog(`✅ ${data.message}`, 'success');
                                            break;

                                        case 'finish':
                                            addImportLog(`🎉 ${data.message}`, 'success');
                                            eventSource.close();
                                            resolve();
                                            break;

                                        case 'error':
                                            addImportLog(`❌ ${data.message}`, 'error');
                                            updateImportProgress(progressModal, 'daily', 'error', data.message);
                                            eventSource.close();
                                            reject(new Error(data.message));
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE message:', e);
                                }
                            };

                            eventSource.onerror = (error) => {
                                console.error('SSE connection error:', error);
                                eventSource.close();
                                if (!dailySuccess) {
                                    addImportLog('❌ Verbindung zum Server verloren', 'error');
                                    updateImportProgress(progressModal, 'daily', 'error', 'Verbindungsfehler');
                                    reject(new Error('SSE connection failed'));
                                } else {
                                    // If we already marked as successful, just close gracefully
                                    resolve();
                                }
                            };

                            // Timeout after 5 minutes
                            setTimeout(() => {
                                if (!dailySuccess) {
                                    eventSource.close();
                                    reject(new Error('Import timeout'));
                                }
                            }, 300000);
                        });

                        // Step 2: Import Quota (SSE)
                        addImportLog('Starte Quota Import...', 'info');

                        await new Promise((resolve, reject) => {
                            let quotaSuccess = false;
                            const eventSource = new EventSource(`../hrs/hrs_imp_quota_stream.php?from=${dateFromStr}&to=${dateToStr}`);

                            eventSource.onmessage = (event) => {
                                try {
                                    const data = JSON.parse(event.data);

                                    switch (data.type) {
                                        case 'start':
                                            addImportLog(data.message, 'info');
                                            break;

                                        case 'phase':
                                            updateImportProgress(progressModal, data.step, 'running', data.message);
                                            break;

                                        case 'total':
                                            addImportLog(`${data.count} Quota-Einträge zu importieren`, 'info');
                                            break;

                                        case 'progress':
                                            const percent = data.percent || 0;
                                            updateImportProgress(progressModal, 'quota', 'running',
                                                `${data.current}/${data.total} (${percent}%) - Quota ${data.quota_id}`);
                                            break;

                                        case 'log':
                                            const icons = { info: 'ℹ️', success: '✓', error: '✗', warn: '⚠' };
                                            const icon = icons[data.level] || '';
                                            addImportLog(`${icon} ${data.message}`, data.level);
                                            break;

                                        case 'complete':
                                            quotaSuccess = true;
                                            updateImportProgress(progressModal, data.step, 'success', data.message);
                                            addImportLog(`✅ ${data.message}`, 'success');
                                            break;

                                        case 'finish':
                                            addImportLog(`🎉 ${data.message}`, 'success');
                                            eventSource.close();
                                            resolve();
                                            break;

                                        case 'error':
                                            addImportLog(`❌ ${data.message}`, 'error');
                                            updateImportProgress(progressModal, 'quota', 'error', data.message);
                                            eventSource.close();
                                            reject(new Error(data.message));
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE message:', e);
                                }
                            };

                            eventSource.onerror = (error) => {
                                console.error('SSE connection error:', error);
                                eventSource.close();
                                if (!quotaSuccess) {
                                    addImportLog('❌ Verbindung zum Server verloren', 'error');
                                    updateImportProgress(progressModal, 'quota', 'error', 'Verbindungsfehler');
                                    reject(new Error('SSE connection failed'));
                                } else {
                                    resolve();
                                }
                            };

                            setTimeout(() => {
                                if (!quotaSuccess) {
                                    eventSource.close();
                                    reject(new Error('Quota import timeout'));
                                }
                            }, 300000);
                        });

                        // Step 3: Import Reservations (SSE)
                        addImportLog('Starte Reservierungen Import...', 'info');

                        await new Promise((resolve, reject) => {
                            let resSuccess = false;
                            const eventSource = new EventSource(`../hrs/hrs_imp_res_stream.php?from=${dateFromStr}&to=${dateToStr}`);

                            eventSource.onmessage = (event) => {
                                try {
                                    const data = JSON.parse(event.data);

                                    switch (data.type) {
                                        case 'start':
                                            addImportLog(data.message, 'info');
                                            break;

                                        case 'phase':
                                            updateImportProgress(progressModal, data.step, 'running', data.message);
                                            break;

                                        case 'total':
                                            addImportLog(`${data.count} Reservierungen zu importieren`, 'info');
                                            break;

                                        case 'progress':
                                            const percent = data.percent || 0;
                                            updateImportProgress(progressModal, 'res', 'running',
                                                `${data.current}/${data.total} (${percent}%) - Res ${data.res_id}`);
                                            break;

                                        case 'log':
                                            const icons = { info: 'ℹ️', success: '✓', error: '✗', warn: '⚠' };
                                            const icon = icons[data.level] || '';
                                            addImportLog(`${icon} ${data.message}`, data.level);
                                            break;

                                        case 'complete':
                                            resSuccess = true;
                                            updateImportProgress(progressModal, data.step, 'success', data.message);
                                            addImportLog(`✅ ${data.message}`, 'success');
                                            break;

                                        case 'finish':
                                            addImportLog(`🎉 ${data.message}`, 'success');
                                            eventSource.close();
                                            resolve();
                                            break;

                                        case 'error':
                                            addImportLog(`❌ ${data.message}`, 'error');
                                            updateImportProgress(progressModal, 'res', 'error', data.message);
                                            eventSource.close();
                                            reject(new Error(data.message));
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE message:', e);
                                }
                            };

                            eventSource.onerror = (error) => {
                                console.error('SSE connection error:', error);
                                eventSource.close();
                                if (!resSuccess) {
                                    addImportLog('❌ Verbindung zum Server verloren', 'error');
                                    updateImportProgress(progressModal, 'res', 'error', 'Verbindungsfehler');
                                    reject(new Error('SSE connection failed'));
                                } else {
                                    resolve();
                                }
                            };

                            setTimeout(() => {
                                if (!resSuccess) {
                                    eventSource.close();
                                    reject(new Error('Reservations import timeout'));
                                }
                            }, 300000);
                        });

                        // Step 4: Update AV Capacity (SSE)
                        addImportLog('Starte AV Capacity Update...', 'info');

                        await new Promise((resolve, reject) => {
                            let avCapSuccess = false;
                            const eventSource = new EventSource(`../api/imps/get_av_cap_range_stream.php?hutID=675&von=${dateFromStr}&bis=${dateToStr}`);

                            eventSource.onmessage = (event) => {
                                try {
                                    const data = JSON.parse(event.data);

                                    switch (data.type) {
                                        case 'start':
                                            addImportLog(data.message, 'info');
                                            break;

                                        case 'phase':
                                            updateImportProgress(progressModal, data.step, 'running', data.message);
                                            break;

                                        case 'total':
                                            addImportLog(`${data.count} API-Aufrufe nötig`, 'info');
                                            break;

                                        case 'progress':
                                            const percent = data.percent || 0;
                                            updateImportProgress(progressModal, 'avcap', 'running',
                                                `API-Aufruf ${data.current}/${data.total} (${percent}%)`);
                                            break;

                                        case 'log':
                                            const icons = { info: 'ℹ️', success: '✓', error: '✗', warn: '⚠' };
                                            const icon = icons[data.level] || '';
                                            addImportLog(`${icon} ${data.message}`, data.level);
                                            break;

                                        case 'complete':
                                            avCapSuccess = true;
                                            updateImportProgress(progressModal, data.step, 'success', data.message);
                                            addImportLog(`✅ ${data.message}`, 'success');
                                            break;

                                        case 'finish':
                                            addImportLog(`🎉 ${data.message}`, 'success');
                                            eventSource.close();
                                            resolve();
                                            break;

                                        case 'error':
                                            addImportLog(`❌ ${data.message}`, 'error');
                                            updateImportProgress(progressModal, 'avcap', 'error', data.message);
                                            eventSource.close();
                                            reject(new Error(data.message));
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE message:', e);
                                }
                            };

                            eventSource.onerror = (error) => {
                                console.error('SSE connection error:', error);
                                eventSource.close();
                                if (!avCapSuccess) {
                                    addImportLog('❌ Verbindung zum Server verloren', 'error');
                                    updateImportProgress(progressModal, 'avcap', 'error', 'Verbindungsfehler');
                                    reject(new Error('SSE connection failed'));
                                } else {
                                    resolve();
                                }
                            };

                            setTimeout(() => {
                                if (!avCapSuccess) {
                                    eventSource.close();
                                    reject(new Error('AV Capacity timeout'));
                                }
                            }, 300000);
                        });

                        // Show success and reload
                        addImportLog('Import erfolgreich abgeschlossen!', 'success');
                        updateImportProgress(progressModal, 'complete', 'success', 'Import erfolgreich abgeschlossen!');

                        // Wait 2 seconds before reload
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        progressModal.hide();

                        // Reload timeline data
                        if (typeof window.reloadTimelineData === 'function') {
                            await window.reloadTimelineData();
                        } else {
                            window.location.reload();
                        }

                    } catch (error) {
                        console.error('❌ Import failed:', error);
                        updateImportProgress(progressModal, 'complete', 'error',
                            `Fehler: ${error.message}`);

                        // Keep modal open on error
                        setTimeout(() => progressModal.hide(), 5000);
                    } finally {
                        hrsImportBtn.disabled = false;
                        hrsImportBtn.innerHTML = '📥 HRS Daten importieren';
                    }
                });
            }

            toolbar.dataset.initialized = 'true';
        }

        function initializeTimelineToolbar() {
            setupTimelineToolbar();
            updateTimelineToolbarValues();
            const renderer = getTimelineRenderer();
            renderer?.updateTopbarVisuals?.();
        }

        // ===== FUNCTION DEFINITIONS (moved to top for onclick availability) =====

        // ===== Room Assignment Modal Controller =====
        (function initRoomAssignController() {
            const modal = document.getElementById('assignModal');
            const gridInner = document.getElementById('assignGridInner');
            const reservationInfo = document.getElementById('assignReservationInfo');
            const kpiAssigned = document.getElementById('kpiAssigned');
            const kpiRemaining = document.getElementById('kpiRemaining');
            const assignStock = document.getElementById('assignStock');
            const btnCancel = document.getElementById('assignCancel');
            const btnSave = document.getElementById('assignSave');
            const btnReset = document.getElementById('assignReset');
            const token = document.getElementById('assignToken');

            let current = null; // { resId, start, end, required, days, draft:{[roomId]:count}, avail: Map(roomId->free) }
            let drag = null;   // token drag state

            function computeRequired(detail) {
                // Ermitteln benötigter Kapazität aus Reservierung (Betten/DZ/Sonder/Lager)
                const data = detail && detail.data ? detail.data : detail.fullData || {};
                const need = Number(data.betten || 0) + Number(data.dz || 0) + Number(data.sonder || 0) + Number(data.lager || 0);
                return Math.max(0, need || Number(detail.capacity || 0) || 0);
            }

            function toTime(value) {
                if (!value) return NaN;
                if (value instanceof Date) {
                    const time = value.getTime();
                    return Number.isFinite(time) ? time : NaN;
                }
                const parsed = new Date(value);
                const time = parsed.getTime();
                return Number.isFinite(time) ? time : NaN;
            }

            function normalizeReservationToken(value) {
                if (value === undefined || value === null) {
                    return '';
                }
                const str = String(value).trim();
                if (/^res_\d+$/i.test(str)) {
                    return str.replace(/^res_/i, '');
                }
                return str;
            }

            function sameReservationId(a, b) {
                const numA = Number(a);
                const numB = Number(b);
                if (Number.isFinite(numA) && Number.isFinite(numB)) {
                    return numA === numB;
                }
                const normA = normalizeReservationToken(a);
                const normB = normalizeReservationToken(b);
                if (!normA || !normB) {
                    return false;
                }
                const numNormA = Number(normA);
                const numNormB = Number(normB);
                if (Number.isFinite(numNormA) && Number.isFinite(numNormB)) {
                    return numNormA === numNormB;
                }
                return normA === normB;
            }

            function extractExistingAssignments(resId, start, end) {
                const assignments = {};
                if (!resId) {
                    return assignments;
                }

                const details = Array.isArray(window.roomDetails) ? window.roomDetails : [];
                const targetStart = toTime(start);
                const targetEnd = toTime(end);

                details.forEach(detail => {
                    if (!detail) return;

                    const data = detail.data || {};
                    const full = detail.fullData || {};
                    const detailResId = detail.res_id ?? detail.resid ?? data.res_id ?? data.id ?? full.res_id ?? full.id;
                    if (detailResId === undefined || detailResId === null) {
                        return;
                    }
                    if (!sameReservationId(detailResId, resId)) {
                        return;
                    }

                    const roomIdRaw = detail.room_id ?? detail.zimID ?? data.room_id ?? data.zimID ?? full.room_id ?? full.zimID;
                    const roomIdNum = Number(roomIdRaw);
                    if (!Number.isFinite(roomIdNum)) {
                        return;
                    }

                    const detailStart = toTime(detail.start || detail.von || data.start || data.von || full.start || full.von);
                    const detailEnd = toTime(detail.end || detail.bis || data.end || data.bis || full.end || full.bis);
                    if (Number.isFinite(targetStart) && Number.isFinite(targetEnd) && Number.isFinite(detailStart) && Number.isFinite(detailEnd)) {
                        if (detailEnd <= targetStart || detailStart >= targetEnd) {
                            return;
                        }
                    }

                    const capacityRaw = detail.capacity ?? detail.anz ?? data.capacity ?? data.anz ?? full.capacity ?? full.anz;
                    const capacity = Math.round(Number(capacityRaw));
                    if (!Number.isFinite(capacity) || capacity <= 0) {
                        return;
                    }

                    const key = String(roomIdNum);
                    assignments[key] = (assignments[key] || 0) + capacity;
                });

                return assignments;
            }

            function isAblageRoom(room) {
                const caption = (room.caption || room.display_name || '').toLowerCase();
                return caption.includes('ablage') || caption === 'ablage';
            }

            function isVisibleRoom(room) {
                if (!room) return false;
                const raw = room.visible;
                if (raw === undefined || raw === null) return true;
                if (typeof raw === 'boolean') return raw;
                const num = Number(raw);
                if (!Number.isNaN(num)) return num !== 0;
                if (typeof raw === 'string') {
                    const trimmed = raw.trim().toLowerCase();
                    if (trimmed === '' || trimmed === 'true') return true;
                    if (trimmed === 'false') return false;
                }
                return !!raw;
            }

            function renderAblageRooms(avail, perDay) {
                const container = document.getElementById('assignAblageRooms');
                if (!container) return;

                const ablageRooms = (Array.isArray(window.rooms) ? window.rooms : []).filter(isAblageRoom);

                if (ablageRooms.length === 0) {
                    container.style.display = 'none';
                    return;
                }

                container.style.display = 'block';
                container.innerHTML = '<h4>Ablage</h4>';

                ablageRooms.forEach(room => {
                    const roomElement = document.createElement('div');
                    roomElement.className = 'assign-ablage-room';
                    roomElement.dataset.roomId = room.id;

                    const baseAvail = Number(avail.get(Number(room.id)) || 0);
                    roomElement.dataset.available = String(baseAvail);

                    let assigned = Number(current.draft[room.id] || 0);
                    const roomTotalCap = Number(room.kapazitaet || room.capacity || 0);

                    // Erstelle Titel und Meta-Info Elements
                    const titleEl = document.createElement('div');
                    titleEl.className = 'assign-ablage-room-title';
                    titleEl.textContent = room.caption || room.display_name || ('Zimmer ' + room.id);

                    const metaEl = document.createElement('div');
                    metaEl.className = 'assign-ablage-room-meta';
                    const ablageTotalCapacity = roomTotalCap > 0 ? roomTotalCap : Math.max(baseAvail, 0);
                    const ablageExisting = ablageTotalCapacity > 0 ? Math.max(0, ablageTotalCapacity - baseAvail) : 0;
                    const ablageAssigned = Math.max(assigned, 0);
                    const ablageOccupied = ablageTotalCapacity > 0
                        ? Math.min(ablageTotalCapacity, ablageExisting + Math.min(ablageAssigned, Math.max(0, ablageTotalCapacity - ablageExisting)))
                        : Math.max(0, ablageExisting + ablageAssigned);
                    metaEl.textContent = ablageTotalCapacity > 0
                        ? `${ablageOccupied}/${ablageTotalCapacity}`
                        : '';

                    roomElement.appendChild(titleEl);
                    roomElement.appendChild(metaEl);

                    container.appendChild(roomElement);
                });
            }

            function updateAblageRoomCounts() {
                // Aktualisiere nur die Anzeige der zugewiesenen Zahlen in Ablage-Zimmern
                const container = document.getElementById('assignAblageRooms');
                if (!container) return;

                container.querySelectorAll('.assign-ablage-room').forEach(roomElement => {
                    const roomId = roomElement.dataset.roomId;
                    const baseAvail = Number(roomElement.dataset.available || 0);
                    const assigned = Number(current.draft[roomId] || 0);

                    // Finde das Zimmer-Objekt für die Kapazität
                    const room = (Array.isArray(window.rooms) ? window.rooms : []).find(r => r.id == roomId);
                    const roomTotalCap = room ? Number(room.kapazitaet || room.capacity || 0) : 0;
                    const ablageTotalCapacity = roomTotalCap > 0 ? roomTotalCap : Math.max(baseAvail, 0);
                    const ablageExisting = ablageTotalCapacity > 0 ? Math.max(0, ablageTotalCapacity - baseAvail) : 0;
                    const ablageAssigned = Math.max(assigned, 0);
                    const ablageOccupied = ablageTotalCapacity > 0
                        ? Math.min(ablageTotalCapacity, ablageExisting + Math.min(ablageAssigned, Math.max(0, ablageTotalCapacity - ablageExisting)))
                        : Math.max(0, ablageExisting + ablageAssigned);

                    const metaEl = roomElement.querySelector('.assign-ablage-room-meta');
                    if (metaEl) {
                        metaEl.textContent = ablageTotalCapacity > 0
                            ? `${ablageOccupied}/${ablageTotalCapacity}`
                            : '';
                    }
                });
            }

            function renderReservationInfo(detail) {
                if (!detail || !reservationInfo) return;

                // Debug: Schauen welche Daten verfügbar sind
                console.log('🔍 Detail object:', detail);
                console.log('🔍 Detail.data:', detail.data);
                console.log('🔍 Detail.fullData:', detail.fullData);

                // Combine all possible data sources
                const combined = { ...detail, ...(detail.data || {}), ...(detail.fullData || {}) };
                console.log('🔍 Combined data:', combined);

                // Name handling - use direct properties first
                let nachname = combined.nachname || combined.lastname || '';
                let vorname = combined.vorname || combined.firstname || '';

                // Fallback: try to split from various name fields
                if (!nachname && !vorname) {
                    const fullName = combined.name || combined.guest_name || combined.title || 'Unbekannt';
                    const nameParts = fullName.split(' ');
                    if (nameParts.length > 1) {
                        nachname = nameParts[nameParts.length - 1]; // Last part as surname
                        vorname = nameParts.slice(0, -1).join(' '); // Everything else as first name
                    } else {
                        nachname = nameParts[0] || '';
                    }
                }

                // Format dates
                const anreise = detail.start instanceof Date ? detail.start.toLocaleDateString('de-DE') : new Date(detail.start).toLocaleDateString('de-DE');
                const abreise = detail.end instanceof Date ? detail.end.toLocaleDateString('de-DE') : new Date(detail.end).toLocaleDateString('de-DE');

                // Categories - check capacity_details and direct properties
                const categories = [];
                const capacity_details = combined.capacity_details || {};

                const dz = Number(combined.dz || capacity_details.dz || 0);
                const betten = Number(combined.betten || capacity_details.betten || 0);
                const lager = Number(combined.lager || capacity_details.lager || 0);
                const sonder = Number(combined.sonder || capacity_details.sonder || 0);

                if (dz > 0) categories.push(`${dz} DZ`);
                if (betten > 0) categories.push(`${betten} Betten`);
                if (lager > 0) categories.push(`${lager} Lager`);
                if (sonder > 0) categories.push(`${sonder} Sonder`);

                // If no specific categories found, show total capacity
                if (categories.length === 0 && combined.capacity > 0) {
                    categories.push(`${combined.capacity} Personen`);
                }

                const arrangement = combined.arr || combined.arrangement || combined.package || '';
                const hund = Number(combined.hund || combined.dog || 0) > 0 ? 'Ja' : '';
                const herkunft = combined.herkunft || combined.origin || combined.country || '';
                const bemerkung = combined.bem || combined.bemerkung || combined.remark || combined.comment || '';
                const bemerkungAV = combined.bem_av || combined.av_remark || '';

                console.log('🔍 Extracted data:', {
                    nachname, vorname, anreise, abreise, categories,
                    arrangement, hund, herkunft, bemerkung, bemerkungAV,
                    capacity_details, capacity: combined.capacity
                });

                let html = `<h4>Reservierung</h4>`;
                html += `<div class="info-row"><span class="info-label">Name:</span><span class="info-value">${nachname} ${vorname}</span></div>`;
                html += `<div class="info-row"><span class="info-label">Zeitraum:</span><span class="info-value">${anreise} → ${abreise}</span></div>`;

                if (categories.length > 0) {
                    html += `<div class="info-row"><span class="info-label">Bedarf:</span><div class="info-categories">`;
                    categories.forEach(cat => html += `<span class="info-category">${cat}</span>`);
                    html += `</div></div>`;
                }

                const requiredTotal = current && Number.isFinite(current.required) ? Number(current.required) : Number(combined.capacity || 0) || 0;
                const assignedInitial = current && current.draft
                    ? Object.values(current.draft).reduce((sum, val) => sum + (Number(val) || 0), 0)
                    : 0;
                if (requiredTotal > 0) {
                    let statusLabel = '';
                    if (assignedInitial >= requiredTotal) {
                        statusLabel = 'Vollständig disponiert';
                    } else if (assignedInitial > 0) {
                        statusLabel = 'Teilweise disponiert';
                    } else {
                        statusLabel = 'Nicht disponiert';
                    }
                    html += `<div class="info-row" data-role="assign-status-row"><span class="info-label">Disponierung:</span><span class="info-value" data-role="assign-status-value">${assignedInitial}/${requiredTotal}${statusLabel ? ` (${statusLabel})` : ''}</span></div>`;
                }

                if (arrangement) html += `<div class="info-row"><span class="info-label">Arrangement:</span><span class="info-value">${arrangement}</span></div>`;
                if (hund) html += `<div class="info-row"><span class="info-label">Hund:</span><span class="info-value">${hund}</span></div>`;
                if (herkunft) html += `<div class="info-row"><span class="info-label">Herkunft:</span><span class="info-value">${herkunft}</span></div>`;
                if (bemerkung) html += `<div class="info-row"><span class="info-label">Bemerkung:</span><span class="info-value">${bemerkung}</span></div>`;
                if (bemerkungAV) html += `<div class="info-row"><span class="info-label">Bemerkung AV:</span><span class="info-value">${bemerkungAV}</span></div>`;

                reservationInfo.innerHTML = html;
            }

            function daysBetween(start, end) {
                const ms = 24 * 3600 * 1000;
                const a = new Date(start.getFullYear(), start.getMonth(), start.getDate()).getTime();
                const b = new Date(end.getFullYear(), end.getMonth(), end.getDate()).getTime();
                return Math.max(1, Math.round((b - a) / ms));
            }

            function layoutFromRooms(rooms) {
                if (!Array.isArray(rooms) || rooms.length === 0) {
                    gridInner.style.gridTemplateColumns = 'repeat(1, 200px)';
                    return { minX: 1, minY: 1, width: 1, height: 1, groups: new Map() };
                }

                const visibleRooms = rooms.filter(r => !isAblageRoom(r) && isVisibleRoom(r));
                const sourceRooms = visibleRooms.length > 0 ? visibleRooms : rooms;

                const coords = sourceRooms.map(r => ({
                    x: Number.isFinite(Number(r.px)) ? Number(r.px) : 1,
                    y: Number.isFinite(Number(r.py)) ? Number(r.py) : 1,
                    room: r
                }));
                const xs = coords.map(c => c.x);
                const ys = coords.map(c => c.y);
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const minY = Math.min(...ys);
                const maxY = Math.max(...ys);
                const width = Math.max(1, (maxX - minX) + 1);
                const height = Math.max(1, (maxY - minY) + 1);

                gridInner.style.gridTemplateColumns = `repeat(${width}, 200px)`;

                const map = new Map();
                coords.forEach(({ x, y, room }) => {
                    const normX = x - minX;
                    const normY = y - minY;
                    const key = `${normX}_${normY}`;
                    if (!map.has(key)) map.set(key, []);
                    map.get(key).push(room);
                });

                return { minX, minY, width, height, groups: map };
            }

            // Lokales YYYY-MM-DD Format (vermeidet UTC-Verschiebungen)
            function ymdLocal(d) {
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const da = String(d.getDate()).padStart(2, '0');
                return `${y}-${m}-${da}`;
            }

            // Verfügbarkeit je Zimmer für spezifischen Zeitraum berechnen
            async function computeAvailabilityMap(start, end) {
                const result = new Map();
                if (!Array.isArray(window.rooms) || window.rooms.length === 0) return result;

                // Berechne Verfügbarkeit für den spezifischen Zeitraum via API
                const startStr = ymdLocal(start);
                const endStr = ymdLocal(end);

                try {
                    // Tagesbasierte Verfügbarkeit: relevante Zahl ist die Belegung am Anreisetag (start)
                    const response = await fetch(`http://192.168.15.14:8080/wci/zp/getRooms.php?calc=day&day=${startStr}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && Array.isArray(data.data)) {
                            data.data.forEach(room => {
                                const roomId = Number(room.id);
                                const available = Math.max(0, Number(room.frei || 0));
                                result.set(roomId, available);
                            });
                            return result;
                        }
                    }
                } catch (error) {
                    console.warn('Fehler beim Laden der Verfügbarkeit:', error);
                }

                // Fallback: verwende lokale Daten
                window.rooms.forEach(room => {
                    const roomId = Number(room.id);
                    let available = 0;

                    // Wenn getRooms.php schon 'frei' berechnet hat, verwende das
                    if (typeof room.frei === 'number') {
                        available = Math.max(0, room.frei);
                    } else {
                        // Fallback: eigene Berechnung (weniger präzise)
                        const totalCap = Number(room.kapazitaet || room.capacity || 0);
                        if (!totalCap) {
                            available = 0;
                        } else {
                            const startDate = new Date(start.getFullYear(), start.getMonth(), start.getDate());
                            const endDate = new Date(end.getFullYear(), end.getMonth(), end.getDate());

                            // Index roomDetails by room for speed
                            const detailsByRoom = new Map();
                            const details = Array.isArray(window.roomDetails) ? window.roomDetails : [];
                            details.forEach(d => {
                                const rid = Number(d.room_id);
                                if (!rid) return;
                                if (!detailsByRoom.has(rid)) detailsByRoom.set(rid, []);
                                detailsByRoom.get(rid).push(d);
                            });

                            const dayKey = (dt) => Math.floor(new Date(dt.getFullYear(), dt.getMonth(), dt.getDate()).getTime() / (24 * 3600 * 1000));
                            const startKey = dayKey(startDate);
                            const endKey = dayKey(endDate); // exclusive

                            let minFree = totalCap;
                            const list = detailsByRoom.get(roomId) || [];

                            // Precompute detail span keys
                            const spans = list.map(d => {
                                const s = d.start instanceof Date ? d.start : new Date(d.start);
                                const e = d.end instanceof Date ? d.end : new Date(d.end);
                                const sk = dayKey(s);
                                const ek = dayKey(e);
                                return { sk, ek, cap: Number(d.capacity || d.data?.capacity || 0) || 0 };
                            });

                            for (let k = startKey; k < endKey; k++) {
                                let used = 0;
                                for (const sp of spans) {
                                    if (k >= sp.sk && k < sp.ek) used += sp.cap;
                                }
                                const free = Math.max(0, totalCap - used);
                                if (free < minFree) minFree = free;
                                if (minFree === 0) break;
                            }

                            available = Math.max(0, minFree);
                        }
                    }

                    result.set(roomId, available);
                });

                return result;
            }

            // Liste der Tage [start, end) als YYYY-MM-DD
            function listDays(start, end) {
                const out = [];
                const d = new Date(start.getFullYear(), start.getMonth(), start.getDate());
                const e = new Date(end.getFullYear(), end.getMonth(), end.getDate());
                while (d < e) {
                    out.push(ymdLocal(d));
                    d.setDate(d.getDate() + 1);
                }
                return out;
            }

            // Debug: pro-Tag freie Kapazität laden (calc=day) und als Map<roomId, number[]> zurückgeben
            async function computePerDayAvailability(start, end) {
                const perDayMap = new Map();
                const days = listDays(start, end);
                if (days.length === 0) return perDayMap;
                try {
                    const requests = days.map(dayStr => fetch(`http://192.168.15.14:8080/wci/zp/getRooms.php?calc=day&day=${dayStr}`)
                        .then(r => r.ok ? r.json() : null)
                        .catch(() => null));
                    const results = await Promise.all(requests);
                    results.forEach((res, idx) => {
                        if (!res || !res.success || !Array.isArray(res.data)) return;
                        res.data.forEach(room => {
                            const rid = Number(room.id);
                            const free = Math.max(0, Number(room.frei || 0));
                            if (!perDayMap.has(rid)) perDayMap.set(rid, Array(days.length).fill(0));
                            perDayMap.get(rid)[idx] = free;
                        });
                    });
                } catch (e) {
                    console.warn('Per-day availability load failed:', e);
                }
                return perDayMap;
            }

            function renderGrid() {
                if (!current) return;
                const layout = layoutFromRooms(rooms || []);
                gridInner.innerHTML = '';
                const frag = document.createDocumentFragment();
                // Berechne per-Tag Verfügbarkeit und leite daraus die Basis-Verfügbarkeit (Minimum über alle Nächte) ab
                computePerDayAvailability(current.start, current.end)
                    .then(perDay => {
                        // Avail = Minimum der freien Plätze über alle Nächte je Zimmer
                        const avail = new Map();
                        const roomsList = Array.isArray(window.rooms) ? window.rooms : [];
                        roomsList.forEach(r => {
                            const rid = Number(r.id);
                            const arr = perDay.get(rid);
                            if (Array.isArray(arr) && arr.length) {
                                const minFree = arr.reduce((m, v) => Math.min(m, Number(v) || 0), Number.POSITIVE_INFINITY);
                                avail.set(rid, Number.isFinite(minFree) ? Math.max(0, minFree) : 0);
                            } else {
                                // Fallback: falls keine per-Tag-Daten, verwende ggf. bereits geliefertes 'frei' aus rooms
                                const fallback = (typeof r.frei === 'number') ? Math.max(0, r.frei) : 0;
                                avail.set(rid, fallback);
                            }
                        });
                        current.avail = avail;
                        renderGridWithAvailability(layout, frag, avail, perDay);
                    })
                    .catch(error => {
                        console.warn('Fehler beim Laden der per-Tag-Verfügbarkeit:', error);
                        const avail = new Map();
                        const perDay = new Map();
                        current.avail = avail;
                        renderGridWithAvailability(layout, frag, avail, perDay);
                    });
            }

            function renderGridWithAvailability(layout, frag, avail, perDay) {
                // Zuerst Ablage-Zimmer im Sidebar rendern
                renderAblageRooms(avail, perDay);

                // Dann normale Zimmer ins Grid (ohne Ablage)
                for (let y = 0; y < layout.height; y++) {
                    for (let x = 0; x < layout.width; x++) {
                        const group = layout.groups.get(`${x}_${y}`) || [];
                        if (group.length === 0) {
                            // Leere Zelle - einfacher Platzhalter
                            const empty = document.createElement('div');
                            empty.className = 'assign-empty-cell';
                            frag.appendChild(empty);
                            continue;
                        }

                        // Filtere Ablage-Zimmer aus dem Grid
                        const normalRooms = group.filter(room => !isAblageRoom(room) && isVisibleRoom(room));
                        if (normalRooms.length === 0) {
                            const empty = document.createElement('div');
                            empty.className = 'assign-empty-cell';
                            frag.appendChild(empty);
                            continue;
                        }

                        normalRooms.forEach(room => {
                            const roomWrap = document.createElement('div');
                            roomWrap.className = 'assign-room';
                            roomWrap.dataset.roomId = room.id;
                            const baseAvail = Math.max(0, Math.round(Number(avail.get(Number(room.id)) || 0)));
                            roomWrap.dataset.available = String(baseAvail);
                            let assigned = Math.max(0, Math.round(Number(current.draft[room.id] || 0)));
                            const title = document.createElement('div');
                            title.className = 'assign-room-title';
                            const roomTotalCap = Number(room.kapazitaet || room.capacity || 0);
                            const initialDraftMap = (current && current.initialDraft) ? current.initialDraft : {};
                            const baselineAssigned = Math.max(0, Math.round(Number(initialDraftMap[room.id] || 0)));
                            const initialTotalCapacity = roomTotalCap > 0
                                ? roomTotalCap
                                : Math.max(baselineAssigned + baseAvail, assigned + baseAvail, baseAvail);
                            const initialExisting = initialTotalCapacity > 0 ? Math.max(0, initialTotalCapacity - baseAvail) : 0;
                            const baseOtherOccupied = Math.max(0, initialExisting - baselineAssigned);
                            const maxByCapacity = roomTotalCap > 0 ? Math.max(0, roomTotalCap - baseOtherOccupied) : Number.POSITIVE_INFINITY;
                            const maxByData = Math.max(0, baselineAssigned + baseAvail);
                            const roomOwnCapacity = Math.max(0, Math.floor(Math.min(maxByCapacity, maxByData)));
                            if (assigned > roomOwnCapacity) {
                                assigned = roomOwnCapacity;
                                current.draft[room.id] = assigned;
                            }
                            const roomTitleText = room.caption || room.display_name || ('Zimmer ' + room.id);
                            const displayTotalCapacity = roomTotalCap > 0 ? roomTotalCap : baseOtherOccupied + roomOwnCapacity;
                            const initialOccupied = displayTotalCapacity > 0
                                ? Math.min(displayTotalCapacity, baseOtherOccupied + assigned)
                                : baseOtherOccupied + assigned;
                            const initialMetaValue = displayTotalCapacity > 0 && Number.isFinite(initialOccupied)
                                ? `${initialOccupied}/${displayTotalCapacity}`
                                : '';
                            roomWrap.dataset.roomCapacityOwn = String(roomOwnCapacity);
                            roomWrap.dataset.baselineAssigned = String(baselineAssigned);
                            roomWrap.dataset.otherOccupied = String(baseOtherOccupied);
                            roomWrap.dataset.displayCapacity = String(displayTotalCapacity);
                            title.innerHTML = '';
                            const titleLabel = document.createElement('span');
                            titleLabel.textContent = roomTitleText;
                            titleLabel.className = 'assign-room-name';
                            const metaLabel = document.createElement('span');
                            metaLabel.className = 'assign-room-meta';
                            if (initialMetaValue) {
                                metaLabel.textContent = initialMetaValue;
                                metaLabel.style.display = '';
                            } else {
                                metaLabel.textContent = '';
                                metaLabel.style.display = 'none';
                            }
                            const titleStack = document.createElement('div');
                            titleStack.className = 'assign-room-title-stack';
                            titleStack.appendChild(titleLabel);
                            titleStack.appendChild(metaLabel);
                            title.appendChild(titleStack);
                            // Farb-Akzent links auf Basis der Zimmerfarbe (#RRGGBB oder #AARRGGBB)
                            if (room.col && typeof room.col === 'string') {
                                let col = room.col.trim();
                                if (col.startsWith('#') && col.length === 9) col = '#' + col.slice(3);
                                if (/^#[0-9a-fA-F]{6}$/.test(col)) {
                                    roomWrap.style.boxShadow = `inset 4px 0 0 ${col}`;
                                }
                            }

                            const bar = document.createElement('div');
                            bar.className = 'assign-bar';

                            const fill = document.createElement('div');
                            fill.className = 'assign-bar-fill';
                            const occupiedFill = document.createElement('div');
                            occupiedFill.className = 'assign-bar-segment occupied';
                            const assignedFill = document.createElement('div');
                            assignedFill.className = 'assign-bar-segment assigned';
                            fill.appendChild(occupiedFill);
                            fill.appendChild(assignedFill);

                            const label = document.createElement('div');
                            label.className = 'assign-bar-label';
                            const capLabel = document.createElement('div');
                            capLabel.className = 'assign-bar-cap';
                            // Debug-Label: per-Tag freie Kapazitäten als farbkodierte Ovale
                            const debugLabel = document.createElement('div');
                            debugLabel.className = 'assign-bar-debug';
                            const perDayArr = perDay && perDay.get(Number(room.id));
                            const perDayBaseline = Array.isArray(perDayArr) ? perDayArr.map(val => Number(val) || 0) : null;
                            const dayOvals = [];

                            // Erstelle Ovale für jeden Tag
                            if (Array.isArray(perDayArr) && perDayArr.length) {
                                perDayArr.forEach((dayCapacity, index) => {
                                    const oval = document.createElement('div');
                                    oval.className = 'assign-day-oval';
                                    oval.textContent = dayCapacity;

                                    // Farbkodierung basierend auf Kapazität vs. Zimmerkapazität
                                    if (dayCapacity === 0) {
                                        oval.classList.add('empty');
                                    } else if (dayCapacity >= roomTotalCap) {
                                        oval.classList.add('full');
                                    } else {
                                        oval.classList.add('partial');
                                    }

                                    dayOvals.push(oval);
                                    debugLabel.appendChild(oval);
                                });
                            }

                            title.appendChild(debugLabel);

                            // Bestimme Zimmer-Hintergrundfarbe basierend auf Gesamtverfügbarkeit
                            // Wende Farbklassen direkt auf roomWrap an
                            if (Array.isArray(perDayArr) && perDayArr.length) {
                                const minCapacity = Math.min(...perDayArr);
                                const hasZeroDay = perDayArr.some(cap => cap === 0);

                                if (hasZeroDay) {
                                    // Sobald ein Tag 0 Kapazität hat, ist das Zimmer nicht nutzbar
                                    roomWrap.classList.add('room-no-available');
                                } else if (minCapacity >= roomTotalCap) {
                                    // Alle Tage haben volle Kapazität frei
                                    roomWrap.classList.add('room-full-available');
                                } else {
                                    // Teilweise verfügbar (aber kein Tag mit 0)
                                    roomWrap.classList.add('room-partial-available');
                                }
                            }
                            const btnMinus = document.createElement('button'); btnMinus.className = 'assign-btn small'; btnMinus.textContent = '−';
                            const btnPlus = document.createElement('button'); btnPlus.className = 'assign-btn small'; btnPlus.textContent = '+';

                            const updateBar = () => {
                                const assignableLimit = roomOwnCapacity;
                                let assignedEffective = Math.max(0, Math.min(assigned, assignableLimit));
                                if (assigned !== assignedEffective) {
                                    assigned = assignedEffective;
                                    current.draft[room.id] = assignedEffective;
                                }

                                const otherOccupied = baseOtherOccupied;
                                let totalCapacity = displayTotalCapacity > 0 ? displayTotalCapacity : (otherOccupied + assignableLimit);
                                if (!(Number.isFinite(totalCapacity) && totalCapacity > 0)) {
                                    totalCapacity = Math.max(0, otherOccupied + assignedEffective);
                                }

                                const occupiedPct = totalCapacity > 0 ? (otherOccupied / totalCapacity) * 100 : 0;
                                const assignedPct = totalCapacity > 0 ? (assignedEffective / totalCapacity) * 100 : 0;
                                const remainingCapacity = Math.max(0, assignableLimit - assignedEffective);
                                const availableToAddRaw = Math.min(remainingCapacity, Math.max(0, remaining()));
                                const availableToAddInt = Math.floor(availableToAddRaw);

                                if (dayOvals.length && perDayBaseline) {
                                    const capacityForComparison = roomTotalCap > 0 ? roomTotalCap : totalCapacity;
                                    const delta = assignedEffective - baselineAssigned;
                                    let minRemaining = Number.POSITIVE_INFINITY;
                                    let hasZeroRemaining = false;
                                    dayOvals.forEach((oval, idx) => {
                                        if (!oval) return;
                                        const baseline = Number(perDayBaseline[idx] ?? 0);
                                        const rawRemaining = baseline - delta;
                                        const remainingCap = capacityForComparison > 0
                                            ? Math.max(0, Math.min(capacityForComparison, rawRemaining))
                                            : Math.max(0, rawRemaining);
                                        oval.textContent = String(remainingCap);
                                        oval.classList.remove('empty', 'partial', 'full');
                                        if (remainingCap <= 0) {
                                            oval.classList.add('empty');
                                            hasZeroRemaining = true;
                                        } else if (capacityForComparison > 0 && remainingCap >= capacityForComparison) {
                                            oval.classList.add('full');
                                        } else {
                                            oval.classList.add('partial');
                                        }
                                        if (remainingCap < minRemaining) {
                                            minRemaining = remainingCap;
                                        }
                                    });

                                    roomWrap.classList.remove('room-no-available', 'room-full-available', 'room-partial-available');
                                    if (hasZeroRemaining) {
                                        roomWrap.classList.add('room-no-available');
                                    } else if (capacityForComparison > 0 && minRemaining >= capacityForComparison) {
                                        roomWrap.classList.add('room-full-available');
                                    } else if (dayOvals.length) {
                                        roomWrap.classList.add('room-partial-available');
                                    }
                                }

                                if (totalCapacity > 0) {
                                    occupiedFill.style.display = otherOccupied > 0 ? 'block' : 'none';
                                    occupiedFill.style.width = `${occupiedPct}%`;

                                    assignedFill.style.display = assignedEffective > 0 ? 'block' : 'none';
                                    assignedFill.style.left = `${occupiedPct}%`;
                                    assignedFill.style.width = `${assignedPct}%`;
                                } else {
                                    occupiedFill.style.display = 'none';
                                    assignedFill.style.display = assignedEffective > 0 ? 'block' : 'none';
                                    assignedFill.style.left = '0%';
                                    assignedFill.style.width = assignedEffective > 0 ? '100%' : '0%';
                                }

                                label.textContent = assignedEffective > 0 ? `+${assignedEffective}` : '0';
                                capLabel.textContent = '';
                                capLabel.style.display = 'none';

                                const currentOccupied = totalCapacity > 0
                                    ? Math.min(totalCapacity, otherOccupied + assignedEffective)
                                    : Math.max(0, otherOccupied + assignedEffective);
                                const roomTitleText = room.caption || room.display_name || ('Zimmer ' + room.id);
                                const metaValue = totalCapacity > 0 && Number.isFinite(currentOccupied)
                                    ? `${currentOccupied}/${totalCapacity}`
                                    : '';

                                titleLabel.textContent = roomTitleText;
                                if (metaValue) {
                                    metaLabel.textContent = metaValue;
                                    metaLabel.style.display = '';
                                } else {
                                    metaLabel.textContent = '';
                                    metaLabel.style.display = 'none';
                                }

                                btnMinus.disabled = assigned <= 0;
                                btnPlus.disabled = availableToAddInt <= 0;
                                roomWrap.classList.toggle('disabled', availableToAddInt <= 0);

                                bar.dataset.assignableLimit = String(assignableLimit);
                                bar.dataset.availableToAdd = String(availableToAddRaw);
                                bar.dataset.availableToAddInt = String(availableToAddInt);
                                bar.dataset.totalCapacity = String(totalCapacity);
                                bar.dataset.otherOccupied = String(otherOccupied);
                                bar.dataset.remainingCapacity = String(remainingCapacity);
                            };

                            let barDrag = null;
                            bar.addEventListener('mousedown', (e) => {
                                const rect = bar.getBoundingClientRect();
                                barDrag = { startX: e.clientX, rect, startAssigned: assigned };
                                document.addEventListener('mousemove', onMove);
                                document.addEventListener('mouseup', onUp, { once: true });
                                e.preventDefault();
                            });
                            function onMove(e) {
                                if (!barDrag) return;
                                const rel = Math.max(0, Math.min(1, (e.clientX - barDrag.rect.left) / barDrag.rect.width));
                                const assignableLimit = roomOwnCapacity;
                                const assignedEffective = Math.max(0, Math.min(assigned, assignableLimit));
                                const remainingCapacity = Math.max(0, assignableLimit - assignedEffective);
                                const availableToAdd = Math.min(remainingCapacity, Math.max(0, remaining()));
                                const maxAssignAbs = Math.min(assignableLimit, assignedEffective + availableToAdd);
                                const sliderRange = assignableLimit;
                                const next = Math.round(rel * sliderRange);
                                const bounded = Math.max(0, Math.min(maxAssignAbs, next));
                                if (bounded !== assigned) { current.draft[room.id] = bounded; updateTotals(); assigned = bounded; updateBar(); }
                            }
                            function onUp() { document.removeEventListener('mousemove', onMove); barDrag = null; }

                            btnMinus.addEventListener('click', () => { if (assigned > 0) { current.draft[room.id] = assigned - 1; assigned--; updateTotals(); updateBar(); } });
                            btnPlus.addEventListener('click', () => {
                                const assignableLimit = roomOwnCapacity;
                                const assignedEffective = Math.max(0, Math.min(assigned, assignableLimit));
                                const remainingCapacity = Math.max(0, assignableLimit - assignedEffective);
                                const availableToAdd = Math.min(remainingCapacity, Math.max(0, remaining()));
                                const maxAssign = Math.min(assignableLimit, assignedEffective + availableToAdd);
                                const maxAssignInt = Math.floor(maxAssign);
                                const next = Math.min(maxAssignInt, assigned + 1);
                                if (next > assigned) {
                                    current.draft[room.id] = next;
                                    assigned = next;
                                    updateTotals();
                                    updateBar();
                                }
                            });

                            bar.appendChild(fill); bar.appendChild(label); bar.appendChild(capLabel);

                            const actionsWrap = document.createElement('div');
                            actionsWrap.className = 'assign-room-actions';
                            const controlsWrap = document.createElement('div');
                            controlsWrap.className = 'assign-controls-wrap';
                            controlsWrap.appendChild(btnMinus);
                            controlsWrap.appendChild(btnPlus);

                            actionsWrap.appendChild(bar);
                            actionsWrap.appendChild(controlsWrap);

                            roomWrap.appendChild(title);
                            roomWrap.appendChild(actionsWrap);
                            // Initialize bar visuals and disabled state
                            updateBar();
                            // Drop target wiring
                            roomWrap.addEventListener('mouseenter', () => { /* highlight handled globally during token drag */ });
                            roomWrap.addEventListener('mouseleave', () => { roomWrap.classList.remove('drop-target'); });
                            roomWrap.addEventListener('mouseup', (e) => {
                                if (!drag) return;
                                const assignableLimit = roomOwnCapacity;
                                const assignedEffective = Math.max(0, Math.min(assigned, assignableLimit));
                                const remainingCapacity = Math.max(0, assignableLimit - assignedEffective);
                                const availableToAdd = Math.min(remainingCapacity, Math.max(0, remaining()));
                                const add = Math.max(0, Math.floor(availableToAdd));
                                if (add > 0) {
                                    current.draft[room.id] = (current.draft[room.id] || 0) + add;
                                    assigned = (current.draft[room.id] || 0);
                                    updateTotals();
                                    updateBar();
                                }
                                endTokenDrag();
                                e.preventDefault();
                            });
                            frag.appendChild(roomWrap);
                        });
                    }
                }
                gridInner.appendChild(frag);
                updateTotals();
            }

            function sumAssigned() { return Object.values(current.draft).reduce((a, b) => a + (Number(b) || 0), 0); }
            function remaining() { return Math.max(0, (current.required || 0) - sumAssigned()); }
            function updateTotals() {
                const a = sumAssigned(); const r = remaining();
                kpiAssigned.textContent = String(a);
                kpiRemaining.textContent = String(r);
                token.textContent = String(r);
                token.style.opacity = r > 0 ? '1' : '0.5';
                token.style.pointerEvents = r > 0 ? 'auto' : 'none';
                if (assignStock) {
                    const requiredTotal = Number(current?.required || 0);
                    assignStock.classList.toggle('complete', requiredTotal > 0 && r <= 0);
                }

                // Refresh disabled state on all rooms (based on latest remaining/assigned)
                gridInner.querySelectorAll('.assign-room').forEach((wrap) => {
                    const roomId = Number(wrap.dataset.roomId || 0);
                    const assignedValue = Number(current && current.draft ? (current.draft[roomId] || 0) : 0);
                    const roomOwnCapacity = Number(wrap.dataset.roomCapacityOwn || 0);
                    const otherOccupied = Number(wrap.dataset.otherOccupied || 0);
                    const assignableLimit = Math.max(0, roomOwnCapacity);
                    const remainingCapacity = Math.max(0, assignableLimit - assignedValue);
                    const availableToAdd = Math.min(remainingCapacity, Math.max(0, r));
                    const availableToAddInt = Math.floor(availableToAdd);
                    wrap.classList.toggle('disabled', availableToAddInt <= 0);

                    const displayCapacity = Number(wrap.dataset.displayCapacity || 0);
                    const totalCapacity = displayCapacity > 0 ? displayCapacity : (otherOccupied + assignableLimit);
                    const barNode = wrap.querySelector('.assign-bar');
                    if (barNode) {
                        barNode.dataset.assignableLimit = String(assignableLimit);
                        barNode.dataset.totalCapacity = String(totalCapacity);
                        barNode.dataset.otherOccupied = String(otherOccupied);
                        barNode.dataset.remainingCapacity = String(remainingCapacity);
                        barNode.dataset.availableToAdd = String(availableToAdd);
                        barNode.dataset.availableToAddInt = String(availableToAddInt);
                    }
                });

                // Aktualisiere auch die Ablage-Zimmer Anzeige
                updateAblageRoomCounts();

                const statusValueEl = reservationInfo?.querySelector('[data-role="assign-status-value"]');
                if (statusValueEl && current) {
                    const requiredTotal = Number(current.required || 0);
                    if (requiredTotal > 0) {
                        const assignedTotal = a;
                        let statusLabel = '';
                        if (assignedTotal >= requiredTotal) {
                            statusLabel = 'Vollständig disponiert';
                        } else if (assignedTotal > 0) {
                            statusLabel = 'Teilweise disponiert';
                        } else {
                            statusLabel = 'Nicht disponiert';
                        }
                        statusValueEl.textContent = `${assignedTotal}/${requiredTotal}${statusLabel ? ` (${statusLabel})` : ''}`;
                    } else {
                        statusValueEl.textContent = `${a}`;
                    }
                }
            }

            function open(detail) {
                if (!detail) return;
                const titleName = detail.name || detail.fullData?.guest_name || 'Reservierung';
                const start = detail.start instanceof Date ? detail.start : new Date(detail.start);
                const end = detail.end instanceof Date ? detail.end : new Date(detail.end);
                const required = computeRequired(detail);
                const resId = detail.data?.res_id || detail.fullData?.res_id || detail.fullData?.id || detail.res_id || detail.id;
                current = { resId, start, end, days: daysBetween(start, end), required, draft: {}, avail: new Map() };

                const existingAssignments = extractExistingAssignments(resId, start, end);
                if (existingAssignments && Object.keys(existingAssignments).length) {
                    current.draft = { ...existingAssignments };
                } else {
                    current.draft = {};
                }
                current.initialDraft = { ...current.draft };

                renderReservationInfo(detail);
                renderGrid();
                modal.setAttribute('open', '');
                modal.setAttribute('aria-hidden', 'false');
                // Token drag handlers - sowohl Mouse als auch Touch Events für Tablet-Unterstützung
                token.addEventListener('mousedown', onTokenDown);
                token.addEventListener('touchstart', onTokenDown, { passive: false });
            }

            function close() {
                modal.removeAttribute('open');
                modal.setAttribute('aria-hidden', 'true');
                current = null;
                endTokenDrag();
                token.removeEventListener('mousedown', onTokenDown);
                token.removeEventListener('touchstart', onTokenDown);
            }

            // Wire close buttons/backdrop
            modal.addEventListener('click', (e) => { const t = e.target; if (t && t.dataset && t.dataset.close === 'assign') { close(); } });

            // Verhindere Standard-Drag-Verhalten und Text-Selektion im Modal
            modal.addEventListener('dragstart', (e) => e.preventDefault());
            modal.addEventListener('selectstart', (e) => e.preventDefault());
            modal.addEventListener('mousedown', (e) => {
                // Nur verhindern wenn es nicht der Token oder ein Button ist
                if (!e.target.closest('.assign-token') && !e.target.closest('button')) {
                    e.preventDefault();
                }
            });
            modal.addEventListener('wheel', (e) => {
                if (!(e.target instanceof Element)) return;
                const numberInput = e.target.closest('input[type="number"]');
                if (numberInput) {
                    e.preventDefault();
                }
            }, { passive: false });

            btnCancel.addEventListener('click', close);
            btnReset.addEventListener('click', () => {
                if (!current) return;
                current.draft = { ...(current.initialDraft || {}) };
                updateTotals();
                renderGrid();
                console.log('Zimmeraufteilung zurückgesetzt');
            });
            btnSave.addEventListener('click', async () => {
                if (!current || !current.resId) { console.warn('Keine ResID, kann nicht speichern'); close(); return; }
                const payload = {
                    res_id: Number(current.resId),
                    // Verwende lokales YYYY-MM-DD, um UTC-Verschiebungen zu vermeiden
                    start: ymdLocal(current.start),
                    end: ymdLocal(current.end),
                    assignments: current.draft
                };
                try {
                    const resp = await fetch('http://192.168.15.14:8080/wci/zp/assignRoomsToReservation.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    const data = await resp.json().catch(() => ({ success: false, error: 'Invalid JSON' }));
                    if (!resp.ok || !data.success) { throw new Error(data.error || (`HTTP ${resp.status}`)); }
                    console.success('Zuweisungen gespeichert.');
                    close();
                    if (typeof window.reloadTimelineData === 'function') { window.reloadTimelineData(); }
                } catch (err) {
                    console.error('Speichern fehlgeschlagen:', err);
                    alert('Fehler beim Speichern: ' + err.message);
                }
            });

            window.openRoomAssignModal = open;

            // ===== Token Dragging =====
            function onTokenDown(e) {
                if (remaining() <= 0) return;

                // Touch oder Mouse Event normalisieren
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                drag = { ghost: null, shiftKey: e.shiftKey };
                createGhost(clientX, clientY);

                // Sowohl Mouse- als auch Touch-Events hinzufügen
                window.addEventListener('mousemove', onTokenMove);
                window.addEventListener('touchmove', onTokenMove, { passive: false });
                window.addEventListener('mouseup', onTokenUp, { once: true });
                window.addEventListener('touchend', onTokenUp, { once: true });

                e.preventDefault();
            }
            function onTokenMove(e) {
                if (!drag) return;

                // Touch oder Mouse Event normalisieren
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                moveGhost(clientX, clientY);
                highlightDrop(clientX, clientY);
                updateGhostContent(clientX, clientY);

                e.preventDefault(); // Verhindert Scrolling beim Touch-Drag
            }
            function onTokenUp(e) {
                if (!drag) return;

                // Touch oder Mouse Event normalisieren
                const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

                const target = document.elementFromPoint(clientX, clientY);
                // Suche sowohl normale Zimmer als auch Ablage-Zimmer
                const roomWrap = target && target.closest ? target.closest('.assign-room, .assign-ablage-room') : null;
                if (roomWrap) {
                    const roomId = Number(roomWrap.dataset.roomId);
                    const assigned = Number(current.draft[roomId] || 0);
                    const remainingTotal = Math.max(0, remaining());
                    let add = 0;

                    if (roomWrap.classList.contains('assign-ablage-room')) {
                        const capAvail = Number(roomWrap.dataset.available || 0);
                        const addMax = Math.min(capAvail - assigned, remainingTotal);
                        add = Math.max(0, Math.floor(addMax));
                    } else {
                        const roomCapacityOwn = Number(roomWrap.dataset.roomCapacityOwn || 0);
                        const remainingCapacity = Math.max(0, roomCapacityOwn - assigned);
                        const addMax = Math.min(remainingCapacity, remainingTotal);
                        add = Math.max(0, Math.floor(addMax));
                    }

                    if (add > 0) {
                        current.draft[roomId] = assigned + add;
                        updateTotals();
                        renderGrid();
                    }
                }
                endTokenDrag();
            }
            function createGhost(x, y) { const g = document.createElement('div'); g.className = 'assign-ghost assign-token'; g.textContent = '?'; document.body.appendChild(g); drag.ghost = g; moveGhost(x, y); }
            function moveGhost(x, y) { if (drag && drag.ghost) { drag.ghost.style.left = x + 'px'; drag.ghost.style.top = y + 'px'; } }
            function updateGhostContent(x, y) {
                if (!drag || !drag.ghost) return;
                const el = document.elementFromPoint(x, y);
                const roomWrap = el && el.closest ? el.closest('.assign-room, .assign-ablage-room') : null;
                if (roomWrap) {
                    const roomId = Number(roomWrap.dataset.roomId);
                    const assigned = Number(current.draft[roomId] || 0);
                    const remainingTotal = Math.max(0, remaining());
                    let addMax = 0;

                    if (roomWrap.classList.contains('assign-ablage-room')) {
                        const capAvail = Number(roomWrap.dataset.available || 0);
                        addMax = Math.min(capAvail - assigned, remainingTotal);
                    } else {
                        const roomCapacityOwn = Number(roomWrap.dataset.roomCapacityOwn || 0);
                        const remainingCapacity = Math.max(0, roomCapacityOwn - assigned);
                        addMax = Math.min(remainingCapacity, remainingTotal);
                    }

                    const addInt = Math.max(0, Math.floor(addMax));
                    drag.ghost.textContent = addInt > 0 ? String(addInt) : '0';
                } else {
                    drag.ghost.textContent = '?';
                }
            }
            function endTokenDrag() {
                if (!drag) return;
                if (drag.ghost && drag.ghost.parentNode) drag.ghost.parentNode.removeChild(drag.ghost);
                unhighlightAll();

                // Alle Event-Listener entfernen
                window.removeEventListener('mousemove', onTokenMove);
                window.removeEventListener('touchmove', onTokenMove);
                window.removeEventListener('mouseup', onTokenUp);
                window.removeEventListener('touchend', onTokenUp);

                drag = null;
            }
            function highlightDrop(x, y) {
                unhighlightAll();
                const el = document.elementFromPoint(x, y);
                const roomWrap = el && el.closest ? el.closest('.assign-room, .assign-ablage-room') : null;
                if (!roomWrap) return;
                const roomId = Number(roomWrap.dataset.roomId || 0);
                const alreadyAssigned = Number(current.draft[roomId] || 0);
                const remainingTotal = Math.max(0, remaining());
                let addMax = 0;

                if (roomWrap.classList.contains('assign-ablage-room')) {
                    const capAvail = Number(roomWrap.dataset.available || 0);
                    addMax = Math.min(capAvail - alreadyAssigned, remainingTotal);
                } else {
                    const roomCapacityOwn = Number(roomWrap.dataset.roomCapacityOwn || 0);
                    const remainingCapacity = Math.max(0, roomCapacityOwn - alreadyAssigned);
                    addMax = Math.min(remainingCapacity, remainingTotal);
                }

                if (Math.floor(addMax) > 0) {
                    roomWrap.classList.add('drop-target');
                }
            }
            function unhighlightAll() {
                gridInner.querySelectorAll('.assign-room.drop-target').forEach(el => el.classList.remove('drop-target'));
                document.querySelectorAll('.assign-ablage-room.drop-target').forEach(el => el.classList.remove('drop-target'));
            }
        })();

        // Modal Confirmation Function
        function showConfirmationModal(title, message, confirmText = 'Bestätigen', cancelText = 'Abbrechen') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmation-modal');
                const modalTitle = document.getElementById('modal-title');
                const modalMessage = document.getElementById('modal-message');
                const modalCancel = document.getElementById('modal-cancel');
                const modalConfirm = document.getElementById('modal-confirm');

                // Set content
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modalCancel.textContent = cancelText;
                modalConfirm.textContent = confirmText;

                // Show modal
                modal.classList.add('active');

                // Handle button clicks
                const onCancel = () => {
                    modal.classList.remove('active');
                    resolve(false);
                    cleanup();
                };

                const onConfirm = () => {
                    modal.classList.remove('active');
                    resolve(true);
                    cleanup();
                };

                const cleanup = () => {
                    modalCancel.removeEventListener('click', onCancel);
                    modalConfirm.removeEventListener('click', onConfirm);
                    modal.removeEventListener('click', onOverlayClick);
                };

                const onOverlayClick = (e) => {
                    if (e.target === modal) {
                        onCancel();
                    }
                };

                modalCancel.addEventListener('click', onCancel);
                modalConfirm.addEventListener('click', onConfirm);
                modal.addEventListener('click', onOverlayClick);
            });
        }

        // Designation Edit Modal Function
        function showDesignationModal(currentDesignation, hasMultipleDetails = false) {
            return new Promise((resolve) => {
                const modal = document.getElementById('designation-modal');
                const designationInput = document.getElementById('designation-input');
                const designationCancel = document.getElementById('designation-cancel');
                const designationSave = document.getElementById('designation-save');
                const multipleOptions = document.getElementById('designation-multiple-options');
                const updateAllCheckbox = document.getElementById('designation-update-all');

                // Set current designation
                designationInput.value = currentDesignation || '';

                // Show/hide multiple options based on whether there are multiple details
                if (hasMultipleDetails) {
                    multipleOptions.style.display = 'flex';
                    updateAllCheckbox.checked = false; // Default: nur der betreffende Balken
                } else {
                    multipleOptions.style.display = 'none';
                }

                // Show modal
                modal.classList.add('active');
                designationInput.focus();
                designationInput.select();

                // Handle button clicks
                const onCancel = () => {
                    modal.classList.remove('active');
                    resolve(null);
                    cleanup();
                };

                const onSave = () => {
                    const newDesignation = designationInput.value.trim();
                    const updateAll = hasMultipleDetails ? updateAllCheckbox.checked : false;

                    modal.classList.remove('active');
                    resolve({
                        designation: newDesignation,
                        updateAll: updateAll
                    });
                    cleanup();
                };

                const onKeyPress = (e) => {
                    if (e.key === 'Enter') {
                        onSave();
                    } else if (e.key === 'Escape') {
                        onCancel();
                    }
                };

                const cleanup = () => {
                    designationCancel.removeEventListener('click', onCancel);
                    designationSave.removeEventListener('click', onSave);
                    designationInput.removeEventListener('keydown', onKeyPress);
                    modal.removeEventListener('click', onOverlayClick);
                };

                const onOverlayClick = (e) => {
                    if (e.target === modal) {
                        onCancel();
                    }
                };

                designationCancel.addEventListener('click', onCancel);
                designationSave.addEventListener('click', onSave);
                designationInput.addEventListener('keydown', onKeyPress);
                modal.addEventListener('click', onOverlayClick);
            });
        }

        // Notes Edit Modal Function
        function showNotesModal(currentNote = '') {
            return new Promise((resolve) => {
                const modal = document.getElementById('notes-modal');
                const notesTextarea = document.getElementById('notes-textarea');
                const notesCancel = document.getElementById('notes-cancel');
                const notesClear = document.getElementById('notes-clear');
                const notesSave = document.getElementById('notes-save');
                const charCount = document.getElementById('notes-char-count');

                // Update character counter
                const updateCharCount = () => {
                    charCount.textContent = notesTextarea.value.length;
                };

                // Set current value
                notesTextarea.value = currentNote;
                updateCharCount();

                // Show/hide clear button based on current note
                if (currentNote && currentNote.trim() !== '') {
                    notesClear.style.display = 'inline-block';
                } else {
                    notesClear.style.display = 'none';
                }

                // Show modal
                modal.classList.add('active');
                notesTextarea.focus();
                notesTextarea.select();

                // Event handlers
                const onCancel = () => {
                    cleanup();
                    modal.classList.remove('active');
                    resolve(null);
                };

                const onSave = () => {
                    const newNote = notesTextarea.value.trim();
                    cleanup();
                    modal.classList.remove('active');
                    resolve(newNote);
                };

                const onClear = () => {
                    cleanup();
                    modal.classList.remove('active');
                    resolve(''); // Empty string to clear the note
                };

                const onKeyPress = (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        onSave();
                    } else if (e.key === 'Escape') {
                        onCancel();
                    }
                };

                const cleanup = () => {
                    notesCancel.removeEventListener('click', onCancel);
                    notesClear.removeEventListener('click', onClear);
                    notesSave.removeEventListener('click', onSave);
                    notesTextarea.removeEventListener('keydown', onKeyPress);
                    notesTextarea.removeEventListener('input', updateCharCount);
                    modal.removeEventListener('click', onOverlayClick);
                };

                const onOverlayClick = (e) => {
                    if (e.target === modal) {
                        onCancel();
                    }
                };

                notesCancel.addEventListener('click', onCancel);
                notesClear.addEventListener('click', onClear);
                notesSave.addEventListener('click', onSave);
                notesTextarea.addEventListener('keydown', onKeyPress);
                notesTextarea.addEventListener('input', updateCharCount);
                modal.addEventListener('click', onOverlayClick);
            });
        }

        // Dataset Modal Function
        function showDatasetModal(detail) {
            return new Promise(async (resolve) => {
                const modal = document.getElementById('dataset-modal');
                const cancelBtn = document.getElementById('dataset-cancel');
                const saveBtn = document.getElementById('dataset-save');
                const avIndicator = document.getElementById('dataset-av-indicator');
                const avIdDisplay = document.getElementById('dataset-av-id-display');

                // Extract AV_Res data - diese Daten müssen von der API kommen
                const avResId = detail.data?.res_id || detail.res_id || detail.resid;

                if (!avResId) {
                    alert('Fehler: Keine AV-Res ID gefunden');
                    resolve(null);
                    return;
                }

                try {
                    // Lade AV_Res Daten von der API
                    const response = await fetch(`http://192.168.15.14:8080/wci/zp/getAVReservationData.php?av_res_id=${avResId}`);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        const text = await response.text();
                        console.error('Non-JSON response:', text);
                        throw new Error('Server returned non-JSON response: ' + text.substring(0, 100));
                    }

                    const avResData = await response.json();

                    if (!avResData.success) {
                        throw new Error(avResData.message || 'Fehler beim Laden der AV-Res Daten');
                    }

                    const data = avResData.data;
                    const isAVReservation = (data.av_id || 0) > 0;

                    // Zeige AV-Indikator
                    if (isAVReservation) {
                        avIndicator.style.display = 'block';
                        avIdDisplay.textContent = data.av_id;
                    } else {
                        avIndicator.style.display = 'none';
                    }

                    // Populate Grunddaten
                    document.getElementById('dataset-av-id').value = data.av_id || '';
                    document.getElementById('dataset-storno').value = data.storno || 0;
                    document.getElementById('dataset-hund').value = data.hund || 0;

                    // Populate Aufenthaltsdaten
                    document.getElementById('dataset-anreise').value = formatDateForInput(data.anreise);
                    document.getElementById('dataset-abreise').value = formatDateForInput(data.abreise);
                    document.getElementById('dataset-lager').value = data.lager || 0;
                    document.getElementById('dataset-betten').value = data.betten || 0;
                    document.getElementById('dataset-dz').value = data.dz || 0;
                    document.getElementById('dataset-sonder').value = data.sonder || 0;

                    // Populate Gästeinformationen
                    document.getElementById('dataset-vorname').value = data.vorname || '';
                    document.getElementById('dataset-nachname').value = data.nachname || '';
                    document.getElementById('dataset-email').value = data.email || '';
                    document.getElementById('dataset-handy').value = data.handy || '';
                    document.getElementById('dataset-email-date').value = formatEmailDateForInput(data.email_date);

                    // Populate Zusatzinformationen
                    document.getElementById('dataset-gruppe').value = data.gruppe || '';
                    document.getElementById('dataset-bem').value = data.bem || '';
                    document.getElementById('dataset-bem-av').value = data.bem_av || '';

                    // Lade Dropdown-Daten und setze Werte
                    await loadArrangementDropdown(data.arr);
                    await loadOriginDropdown(data.origin);

                    // Setze Editierbarkeit basierend auf AV-Status
                    setFieldsEditability(isAVReservation);

                    // Helper-Funktionen
                    function formatDateForInput(dateStr) {
                        if (!dateStr) return '';
                        const date = new Date(dateStr);
                        return date.toISOString().split('T')[0];
                    }

                    function formatDateTimeForInput(dateStr) {
                        if (!dateStr) return '';
                        const date = new Date(dateStr);
                        return date.toISOString().slice(0, 16); // YYYY-MM-DDTHH:mm
                    }

                    function formatEmailDateForInput(dateStr) {
                        if (!dateStr) return '';
                        const date = new Date(dateStr);
                        const day = String(date.getDate()).padStart(2, '0');
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const year = date.getFullYear();
                        return `${day}.${month}.${year}`;
                    }

                    function setFieldsEditability(isAV) {
                        const avProtectedFields = [
                            'dataset-anreise', 'dataset-abreise', 'dataset-lager', 'dataset-betten',
                            'dataset-dz', 'dataset-sonder', 'dataset-gruppe', 'dataset-bem-av',
                            'dataset-vorname', 'dataset-nachname', 'dataset-handy', 'dataset-email',
                            'dataset-storno'
                        ];

                        avProtectedFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (isAV) {
                                field.style.background = '#2a4a2a';
                                field.style.borderColor = '#27ae60';
                                field.title = 'Gesichert - Änderungen werden in AV übernommen';
                            } else {
                                field.style.background = '#1a1a1a';
                                field.style.borderColor = '#555';
                                field.title = '';
                            }
                        });

                        // Immer editierbare Felder
                        const alwaysEditableFields = [
                            'dataset-bem', 'dataset-arr', 'dataset-hund', 'dataset-origin'
                        ];

                        alwaysEditableFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            field.style.background = '#1a1a1a';
                            field.style.borderColor = '#007bff';
                            field.title = 'Immer editierbar';
                        });
                    }

                    async function loadArrangementDropdown(selectedValue) {
                        try {
                            const response = await fetch('http://192.168.15.14:8080/wci/zp/getArrangements.php');
                            const arrangements = await response.json();
                            const select = document.getElementById('dataset-arr');
                            select.innerHTML = '<option value="">Kein Arrangement</option>';
                            if (arrangements && arrangements.success && Array.isArray(arrangements.data)) {
                                // Nach sort sortieren
                                arrangements.data.sort((a, b) => (a.sort || 0) - (b.sort || 0));
                                arrangements.data.forEach(arr => {
                                    const option = document.createElement('option');
                                    option.value = arr.ID;
                                    option.textContent = arr.kbez;
                                    if (arr.ID == selectedValue) option.selected = true;
                                    select.appendChild(option);
                                });
                            }
                        } catch (error) {
                            console.error('Fehler beim Laden der Arrangements:', error);
                        }
                    }

                    async function loadOriginDropdown(selectedValue) {
                        try {
                            const response = await fetch('http://192.168.15.14:8080/wci/zp/getOrigins.php');
                            const origins = await response.json();
                            const select = document.getElementById('dataset-origin');

                            select.innerHTML = '<option value="">Keine Herkunft</option>';

                            if (origins.success && origins.data) {
                                // Sortiere nach sort-Feld
                                origins.data.sort((a, b) => (a.sort || 0) - (b.sort || 0));

                                origins.data.forEach(origin => {
                                    const option = document.createElement('option');
                                    option.value = origin.ID;
                                    option.textContent = origin.country;
                                    if (origin.ID == selectedValue) option.selected = true;
                                    select.appendChild(option);
                                });
                            }
                        } catch (error) {
                            console.error('Fehler beim Laden der Herkünfte:', error);
                        }
                    }

                    // Show modal
                    modal.classList.add('active');

                    // Event handlers
                    const onCancel = () => {
                        cleanup();
                        modal.classList.remove('active');
                        resolve(null);
                    };

                    const onSave = () => {
                        // Sammle alle Formulardaten
                        const formData = {
                            av_res_id: avResId,
                            av_id: data.av_id,
                            isAVReservation: isAVReservation,

                            // Original-Daten für Vergleich
                            originalData: data,

                            // Grunddaten
                            storno: parseInt(document.getElementById('dataset-storno').value) || 0,
                            hund: parseInt(document.getElementById('dataset-hund').value) || 0,
                            arr: parseInt(document.getElementById('dataset-arr').value) || null,

                            // Aufenthaltsdaten
                            anreise: document.getElementById('dataset-anreise').value,
                            abreise: document.getElementById('dataset-abreise').value,
                            lager: parseInt(document.getElementById('dataset-lager').value) || 0,
                            betten: parseInt(document.getElementById('dataset-betten').value) || 0,
                            dz: parseInt(document.getElementById('dataset-dz').value) || 0,
                            sonder: parseInt(document.getElementById('dataset-sonder').value) || 0,

                            // Gästeinformationen
                            vorname: document.getElementById('dataset-vorname').value.trim(),
                            nachname: document.getElementById('dataset-nachname').value.trim(),
                            email: document.getElementById('dataset-email').value.trim(),
                            handy: document.getElementById('dataset-handy').value.trim(),
                            origin: parseInt(document.getElementById('dataset-origin').value) || null,

                            // Zusatzinformationen
                            gruppe: document.getElementById('dataset-gruppe').value.trim(),
                            bem: document.getElementById('dataset-bem').value.trim(),
                            bem_av: document.getElementById('dataset-bem-av').value.trim()
                        };

                        cleanup();
                        modal.classList.remove('active');
                        resolve(formData);
                    };

                    const onKeyPress = (e) => {
                        if (e.key === 'Escape') {
                            onCancel();
                        }
                    };

                    const cleanup = () => {
                        cancelBtn.removeEventListener('click', onCancel);
                        saveBtn.removeEventListener('click', onSave);
                        document.removeEventListener('keydown', onKeyPress);
                    };

                    cancelBtn.addEventListener('click', onCancel);
                    saveBtn.addEventListener('click', onSave);
                    document.addEventListener('keydown', onKeyPress);

                } catch (error) {
                    console.error('Fehler beim Laden der AV-Res Daten:', error);

                    // Fallback: Verwende Dummy-Daten für Demo
                    console.warn('Using fallback dummy data for AV_Res');
                    const avResData = {
                        success: true,
                        data: {
                            av_id: 0,
                            anreise: detail.start || '2025-09-20',
                            abreise: detail.end || '2025-09-22',
                            lager: 1,
                            betten: 2,
                            dz: 0,
                            sonder: 0,
                            vorname: 'Demo',
                            nachname: 'Gast',
                            email: 'demo@example.com',
                            handy: '+43 123 456789',
                            email_date: null,
                            gruppe: 'Test Gruppe',
                            bem: 'Testbemerkung',
                            bem_av: '',
                            storno: 0,
                            arr: null,
                            country_id: null,
                            origin: null,
                            hund: detail.data?.hund || 0
                        }
                    };

                    // Continue with fallback data
                    const data = avResData.data;
                    const isAVReservation = (data.av_id || 0) > 0;

                    // Helper-Funktionen definieren BEVOR sie verwendet werden
                    function formatDateForInput(dateStr) {
                        if (!dateStr) return '';
                        const date = new Date(dateStr);
                        return date.toISOString().split('T')[0];
                    }

                    function formatDateTimeForInput(dateStr) {
                        if (!dateStr) return '';
                        const date = new Date(dateStr);
                        return date.toISOString().slice(0, 16); // YYYY-MM-DDTHH:mm
                    }

                    function setFieldsEditability(isAV) {
                        const avProtectedFields = [
                            'dataset-anreise', 'dataset-abreise', 'dataset-lager', 'dataset-betten',
                            'dataset-dz', 'dataset-sonder', 'dataset-gruppe', 'dataset-bem-av',
                            'dataset-vorname', 'dataset-nachname', 'dataset-handy', 'dataset-email',
                            'dataset-storno'
                        ];

                        avProtectedFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            if (isAV) {
                                field.style.background = '#2a4a2a';
                                field.style.borderColor = '#27ae60';
                                field.title = 'Gesichert - Änderungen werden in AV übernommen';
                            } else {
                                field.style.background = '#1a1a1a';
                                field.style.borderColor = '#555';
                                field.title = '';
                            }
                        });

                        // Immer editierbare Felder
                        const alwaysEditableFields = [
                            'dataset-bem', 'dataset-arr', 'dataset-hund', 'dataset-origin'
                        ];

                        alwaysEditableFields.forEach(fieldId => {
                            const field = document.getElementById(fieldId);
                            field.style.background = '#1a1a1a';
                            field.style.borderColor = '#007bff';
                            field.title = 'Immer editierbar';
                        });
                    }

                    async function loadArrangementDropdown(selectedValue) {
                        try {
                            const select = document.getElementById('dataset-arr');
                            select.innerHTML = '<option value="">Kein Arrangement</option>';
                            // Fallback: Nur Dummy-Optionen
                            const dummyArrangements = [
                                { ID: 1, kbez: 'Standard' },
                                { ID: 2, kbez: 'Halbpension' },
                                { ID: 3, kbez: 'Vollpension' }
                            ];
                            dummyArrangements.forEach(arr => {
                                const option = document.createElement('option');
                                option.value = arr.ID;
                                option.textContent = arr.kbez;
                                if (arr.ID == selectedValue) option.selected = true;
                                select.appendChild(option);
                            });
                        } catch (error) {
                            console.error('Fehler beim Laden der Arrangements:', error);
                        }
                    }

                    async function loadCountryDropdown(selectedValue) {
                        try {
                            const select = document.getElementById('dataset-country');
                            select.innerHTML = '<option value="">Kein Land</option>';
                            // Fallback: Nur Dummy-Optionen
                            const dummyCountries = [
                                { id: 1, country: 'Deutschland' },
                                { id: 2, country: 'Österreich' },
                                { id: 3, country: 'Schweiz' }
                            ];
                            dummyCountries.forEach(country => {
                                const option = document.createElement('option');
                                option.value = country.id;
                                option.textContent = country.country;
                                if (country.id == selectedValue) option.selected = true;
                                select.appendChild(option);
                            });
                        } catch (error) {
                            console.error('Fehler beim Laden der Länder:', error);
                        }
                    }

                    async function loadOriginDropdown(selectedValue) {
                        try {
                            const response = await fetch('http://192.168.15.14:8080/wci/zp/getOrigins.php');
                            const origins = await response.json();
                            const select = document.getElementById('dataset-origin');
                            select.innerHTML = '<option value="">Keine Herkunft</option>';
                            if (origins && origins.success && Array.isArray(origins.data)) {
                                origins.data.sort((a, b) => (a.sort || 0) - (b.sort || 0));
                                origins.data.forEach(origin => {
                                    const option = document.createElement('option');
                                    option.value = origin.ID;
                                    option.textContent = origin.country;
                                    if (origin.ID == selectedValue) option.selected = true;
                                    select.appendChild(option);
                                });
                            }
                        } catch (error) {
                            console.error('Fehler beim Laden der Herkünfte:', error);
                        }
                    }

                    // Zeige AV-Indikator
                    if (isAVReservation) {
                        avIndicator.style.display = 'block';
                        avIdDisplay.textContent = data.av_id;
                    } else {
                        avIndicator.style.display = 'none';
                    }

                    // Populate Grunddaten
                    document.getElementById('dataset-av-id').value = data.av_id || '';
                    document.getElementById('dataset-storno').value = data.storno || 0;
                    document.getElementById('dataset-hund').value = data.hund || 0;

                    // Populate Aufenthaltsdaten
                    document.getElementById('dataset-anreise').value = formatDateForInput(data.anreise);
                    document.getElementById('dataset-abreise').value = formatDateForInput(data.abreise);
                    document.getElementById('dataset-lager').value = data.lager || 0;
                    document.getElementById('dataset-betten').value = data.betten || 0;
                    document.getElementById('dataset-dz').value = data.dz || 0;
                    document.getElementById('dataset-sonder').value = data.sonder || 0;

                    // Populate Gästeinformationen
                    document.getElementById('dataset-vorname').value = data.vorname || '';
                    document.getElementById('dataset-nachname').value = data.nachname || '';
                    document.getElementById('dataset-email').value = data.email || '';
                    document.getElementById('dataset-handy').value = data.handy || '';
                    document.getElementById('dataset-email-date').value = formatEmailDateForInput(data.email_date);

                    // Populate Zusatzinformationen
                    document.getElementById('dataset-gruppe').value = data.gruppe || '';
                    document.getElementById('dataset-bem').value = data.bem || '';
                    document.getElementById('dataset-bem-av').value = data.bem_av || '';

                    // Lade Dropdown-Daten und setze Werte
                    await loadArrangementDropdown(data.arr);
                    await loadOriginDropdown(data.origin);

                    // Setze Editierbarkeit basierend auf AV-Status
                    setFieldsEditability(isAVReservation);

                    // Show modal
                    modal.classList.add('active');

                    // Event handlers
                    const onCancel = () => {
                        cleanup();
                        modal.classList.remove('active');
                        resolve(null);
                    };

                    const onSave = () => {
                        // Sammle alle Formulardaten für Fallback
                        const formData = {
                            av_res_id: avResId,
                            av_id: data.av_id,
                            isAVReservation: isAVReservation,

                            // Grunddaten
                            storno: parseInt(document.getElementById('dataset-storno').value) || 0,
                            hund: parseInt(document.getElementById('dataset-hund').value) || 0,
                            arr: parseInt(document.getElementById('dataset-arr').value) || null,

                            // Aufenthaltsdaten
                            anreise: document.getElementById('dataset-anreise').value,
                            abreise: document.getElementById('dataset-abreise').value,
                            lager: parseInt(document.getElementById('dataset-lager').value) || 0,
                            betten: parseInt(document.getElementById('dataset-betten').value) || 0,
                            dz: parseInt(document.getElementById('dataset-dz').value) || 0,
                            sonder: parseInt(document.getElementById('dataset-sonder').value) || 0,

                            // Gästeinformationen
                            vorname: document.getElementById('dataset-vorname').value.trim(),
                            nachname: document.getElementById('dataset-nachname').value.trim(),
                            email: document.getElementById('dataset-email').value.trim(),
                            handy: document.getElementById('dataset-handy').value.trim(),
                            origin: parseInt(document.getElementById('dataset-origin').value) || null,

                            // Zusatzinformationen
                            gruppe: document.getElementById('dataset-gruppe').value.trim(),
                            bem: document.getElementById('dataset-bem').value.trim(),
                            bem_av: document.getElementById('dataset-bem-av').value.trim()
                        };

                        cleanup();
                        modal.classList.remove('active');
                        resolve(formData);
                    };

                    const onKeyPress = (e) => {
                        if (e.key === 'Escape') {
                            onCancel();
                        }
                    };

                    const cleanup = () => {
                        cancelBtn.removeEventListener('click', onCancel);
                        saveBtn.removeEventListener('click', onSave);
                        document.removeEventListener('keydown', onKeyPress);
                        modal.removeEventListener('click', onOverlayClick);
                    };

                    const onOverlayClick = (e) => {
                        if (e.target === modal) {
                            onCancel();
                        }
                    };

                    cancelBtn.addEventListener('click', onCancel);
                    saveBtn.addEventListener('click', onSave);
                    document.addEventListener('keydown', onKeyPress);
                    modal.addEventListener('click', onOverlayClick);
                }
            });
        }

        // Dataset command handler
        async function handleDatasetCommand(detail) {
            try {
                const result = await showDatasetModal(detail);
                if (result) {
                    // Update AV_Res data via API
                    const response = await fetch('http://192.168.15.14:8080/wci/zp/updateReservationMasterData.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(result)
                    });

                    const updateResult = await response.json();

                    if (updateResult.success) {
                        showToast('AV-Res Daten erfolgreich aktualisiert', 'success');

                        // Aktualisiere lokale Daten wenn verfügbar
                        if (detail.data) {
                            Object.assign(detail.data, result);
                        }

                        // Re-render um Änderungen anzuzeigen
                        if (timelineRenderer) {
                            timelineRenderer.render();
                        }

                        // Spezielle Behandlung für Hund-Änderungen
                        if (result.hund !== undefined) {
                            // Aktualisiere auch AV_ResDet.hund für visuellen Effekt
                            await updateDetailHundStatus(detail, result.hund);
                        }
                    } else {
                        throw new Error(updateResult.message || 'Unbekannter Fehler beim Speichern');
                    }
                } else {
                    console.log('Dataset modal cancelled');
                }
            } catch (error) {
                console.error('Error in handleDatasetCommand:', error);
                showToast('Fehler beim Aktualisieren der Daten: ' + error.message, 'error');
            }
        }

        // Helper function für Hund-Status Update
        async function updateDetailHundStatus(detail, hundStatus) {
            try {
                const detailUpdateData = {
                    id: detail.id,
                    hund: hundStatus ? 1 : 0
                };

                const response = await fetch('http://192.168.15.14:8080/wci/zp/updateRoomDetailAttributes.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(detailUpdateData)
                });

                const result = await response.json();

                if (result.success) {
                    // Update local data
                    if (detail.data) {
                        detail.data.hund = hundStatus ? 1 : 0;
                    }
                    console.log('Detail hund status synchronized with AV_Res');
                } else {
                    console.warn('Failed to sync detail hund status:', result.message);
                }
            } catch (error) {
                console.error('Error syncing detail hund status:', error);
            }
        }

        // Debug Console Functions
        const DebugConsole = {
            logs: [],
            isVisible: false,

            init() {
                const toggle = document.getElementById('debug-toggle');
                const console = document.getElementById('debug-console');
                const clearBtn = document.getElementById('debug-clear');
                const exportBtn = document.getElementById('debug-export');
                const closeBtn = document.getElementById('debug-close');

                toggle.addEventListener('click', () => this.toggle());
                clearBtn.addEventListener('click', () => this.clear());
                exportBtn.addEventListener('click', () => this.export());
                closeBtn.addEventListener('click', () => this.hide());

                // Intercept console methods
                this.interceptConsole();
            },

            toggle() {
                if (this.isVisible) {
                    this.hide();
                } else {
                    this.show();
                }
            },

            show() {
                document.getElementById('debug-console').classList.add('active');
                this.isVisible = true;
                this.scrollToBottom();
            },

            hide() {
                document.getElementById('debug-console').classList.remove('active');
                this.isVisible = false;
            },

            clear() {
                this.logs = [];
                document.getElementById('debug-console-content').innerHTML = '';
            },

            export() {
                const content = this.logs.map(log =>
                    `[${log.timestamp}] ${log.level.toUpperCase()}: ${log.message}`
                ).join('\n');

                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `timeline-debug-${new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-')}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            },

            log(level, ...args) {
                const timestamp = new Date().toLocaleTimeString();
                const message = args.map(arg =>
                    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                ).join(' ');

                const logEntry = { timestamp, level, message };
                this.logs.push(logEntry);

                // Limit logs to last 100 entries
                if (this.logs.length > 100) {
                    this.logs.shift();
                }

                this.render(logEntry);
            },

            render(logEntry) {
                const content = document.getElementById('debug-console-content');
                const entry = document.createElement('div');
                entry.className = 'debug-log-entry';

                entry.innerHTML = `<span class="debug-log-timestamp">[${logEntry.timestamp}]</span> <span class="debug-log-level-${logEntry.level}">${logEntry.level.toUpperCase()}:</span> ${logEntry.message}`;

                content.appendChild(entry);
                this.scrollToBottom();
            },

            scrollToBottom() {
                const content = document.getElementById('debug-console-content');
                content.scrollTop = content.scrollHeight;
            },

            interceptConsole() {
                const originalMethods = {
                    log: console.log,
                    info: console.info,
                    warn: console.warn,
                    error: console.error
                };

                console.log = (...args) => {
                    originalMethods.log(...args);
                    this.log('info', ...args);
                };

                console.info = (...args) => {
                    originalMethods.info(...args);
                    this.log('info', ...args);
                };

                console.warn = (...args) => {
                    originalMethods.warn(...args);
                    this.log('warn', ...args);
                };

                console.error = (...args) => {
                    originalMethods.error(...args);
                    this.log('error', ...args);
                };

                // Custom debug method
                console.debug = (...args) => {
                    originalMethods.log(...args);
                    this.log('info', ...args);
                };

                // Custom success method
                console.success = (...args) => {
                    originalMethods.log(...args);
                    this.log('success', ...args);
                };
            }
        };

        // Initialize Debug Console when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => DebugConsole.init());
        } else {
            DebugConsole.init();
        }

        // Echte Daten laden (API-Integration)
        async function loadRealData() {
            try {
                const MS_IN_DAY = 24 * 60 * 60 * 1000;
                const now = new Date();
                now.setHours(0, 0, 0, 0);

                // Verwende gespeicherte Wochenwerte aus Toolbar-/Cookie-Konfiguration
                const weekRange = getConfiguredWeeksRange();
                const startDate = new Date(now.getTime() - (weekRange.past * 7 * MS_IN_DAY)); // Konfigurierbare Wochen zurück
                const endDate = new Date(now.getTime() + (weekRange.future * 7 * MS_IN_DAY));   // Konfigurierbare Wochen voraus

                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];

                console.log(`Konfigurierte Zeitspanne: ${weekRange.past} Wochen zurück, ${weekRange.future} Wochen voraus`);
                console.log(`Lade Zimmerplan-Daten für ${startDateStr} bis ${endDateStr}`);

                // Cache-Buster für Quota-Feature
                const cacheBuster = `?cb=${Date.now()}`;

                const roomsFetchPromise = fetch(`http://192.168.15.14:8080/wci/zp/getRooms.php?start=${startDateStr}&end=${endDateStr}`).catch(error => { console.error('Rooms fetch failed:', error); return error; });
                const arrangementsFetchPromise = fetch('http://192.168.15.14:8080/wci/get-arrangements.php').catch(error => { console.error('Arrangements fetch failed:', error); return error; });
                const histogramFetchPromise = fetch(`http://192.168.15.14:8080/wci/zp/getHistogramSource.php?start=${startDateStr}&end=${endDateStr}${cacheBuster.replace('?', '&')}`).catch(error => { console.error('Histogram fetch failed:', error); return error; });

                console.log('Fetching main data...');
                const dataResponse = await fetch(`http://192.168.15.14:8080/wci/zp/getZimmerplanData.php?start=${startDateStr}&end=${endDateStr}`);
                console.log('Main data response:', dataResponse.status, dataResponse.statusText);

                if (!dataResponse.ok) {
                    const errorText = await dataResponse.text().catch(() => 'Unable to read error response');
                    console.error('Main data response error:', errorText);
                    throw new Error(`Zimmerplan-API HTTP ${dataResponse.status}: ${dataResponse.statusText}`);
                }

                console.log('Parsing main data JSON...');
                const result = await dataResponse.json();
                console.log('Main data result:', result);

                if (!result.success) {
                    console.error('API returned error:', result.error);
                    throw new Error(result.error || 'API-Fehler');
                }

                console.log('Processing room details...');
                const apiData = result.data || {};

                const roomDetailsSource = Array.isArray(apiData.room_details) ? apiData.room_details : [];
                roomDetails = roomDetailsSource
                    .filter(item => item.room_id && item.start && item.end)
                    .map(item => {
                        const detailData = item.data || {};
                        const detailId = detailData.detail_id || null;
                        const reservationId = detailData.res_id || null;
                        const roomId = item.room_id || detailData.room_id || null;
                        const caption = detailData.caption || detailData.guest_name || '';

                        return {
                            id: item.id || (detailId ? `room_detail_${detailId}` : undefined),
                            detail_id: detailId,
                            res_id: reservationId,
                            reservation_id: reservationId,
                            room_id: roomId,
                            arr_id: detailData.arr_id || item.arr_id || null,
                            av_id: detailData.av_id || item.av_id || null,
                            guest_name: detailData.guest_name || 'Unbekannt',
                            caption,
                            start: parseAPIDate(item.start),
                            end: parseAPIDate(item.end),
                            color: detailData.color || '#3498db',
                            has_dog: detailData.has_dog || false,
                            capacity: detailData.capacity || 1,
                            arrangement_label: detailData.arrangement || detailData.arrangement_kbez || '',
                            ParentID: detailData.ParentID || item.ParentID || 0,
                            note: detailData.note || '',
                            dx: detailData.dx || 0,
                            dy: detailData.dy || 0,
                            data: {
                                ...detailData,
                                detail_id: detailId,
                                res_id: reservationId,
                                room_id: roomId,
                                arr_id: detailData.arr_id || item.arr_id || null,
                                av_id: detailData.av_id || item.av_id || null,
                                caption,
                                ParentID: detailData.ParentID || item.ParentID || 0
                            }
                        };
                    });

                window.roomDetails = roomDetails;

                console.log(`Processed ${roomDetails.length} room details`);

                const timelineItems = Array.isArray(apiData.timeline_items) ? apiData.timeline_items : [];
                console.log(`Processing ${timelineItems.length} timeline items...`);
                const mappedReservations = timelineItems
                    .filter(item => item && item.content && item.start && item.end)
                    .map((item, index) => {
                        const rawData = item.data || {};
                        const normalizedData = { ...rawData };
                        const masterId = normalizedData.id ?? null;
                        const toBoolean = (value) => {
                            if (typeof value === 'boolean') return value;
                            if (typeof value === 'number') return value !== 0;
                            if (typeof value === 'string') {
                                const normalized = value.trim().toLowerCase();
                                if (!normalized) return false;
                                return ['1', 'true', 'yes', 'y', 'ja', 'on'].includes(normalized);
                            }
                            return Boolean(value);
                        };
                        const isDisposed = toBoolean(normalizedData.is_disposed);
                        normalizedData.is_disposed = isDisposed;

                        const capacityRaw = item.capacity ?? normalizedData.capacity ?? 1;
                        const numericCapacity = Number(capacityRaw);
                        return {
                            id: item.id || index,
                            res_id: masterId ?? undefined,
                            resid: masterId ?? undefined,
                            reservation_id: masterId ?? undefined,
                            name: item.name || normalizedData.guest_name || item.content.replace(/<[^>]*>/g, ''),
                            nachname: item.nachname || '',
                            vorname: item.vorname || '',
                            start: parseAPIDate(item.start),
                            end: parseAPIDate(item.end),
                            capacity: Number.isFinite(numericCapacity) ? numericCapacity : 1,
                            arrangement_name: item.arrangement_name || item.arr_kbez || '',
                            arr_kbez: item.arr_kbez || '',
                            has_dog: item.has_dog || item.hund || normalizedData.has_dog || false,
                            hund: item.hund || item.has_dog || false,
                            is_disposed: isDisposed,
                            fullData: normalizedData,
                            data: normalizedData
                        };
                    });

                reservations = mappedReservations;
                window.reservations = reservations;
                console.log(`Processed ${reservations.length} reservations`);

                console.log('Fetching rooms data...');
                const roomsResponse = await roomsFetchPromise;
                let roomsResult = null;
                let roomsResponseStatus = null;

                if (roomsResponse instanceof Response) {
                    roomsResponseStatus = `HTTP ${roomsResponse.status}: ${roomsResponse.statusText}`;
                    console.log('Rooms response status:', roomsResponseStatus);
                    if (roomsResponse.ok) {
                        console.log('Parsing rooms JSON...');
                        roomsResult = await roomsResponse.json();
                        console.log('Rooms result:', roomsResult);
                    } else {
                        try {
                            roomsResult = await roomsResponse.json();
                        } catch (parseError) {
                            console.error('Failed to parse rooms error response:', parseError);
                            // Falls keine JSON-Antwort geliefert wurde, ignorieren wir den Fehler
                        }
                    }
                } else {
                    console.error('Rooms fetch returned error:', roomsResponse);
                }

                if (roomsResult && roomsResult.success) {
                    console.log('Using real rooms data');
                    rooms = Array.isArray(roomsResult.data) ? [...roomsResult.data] : [];
                    rooms.sort((a, b) => {
                        const sortA = a.sort !== undefined ? a.sort : a.id;
                        const sortB = b.sort !== undefined ? b.sort : b.id;
                        return sortA - sortB;
                    });
                    console.log(`Loaded ${rooms.length} rooms`);
                    // Für computeAvailabilityMap verfügbar machen
                    window.rooms = rooms;
                } else {
                    let statusInfo;
                    if (roomsResponse instanceof Response && roomsResponse.ok) {
                        statusInfo = roomsResult && roomsResult.error ? roomsResult.error : 'Unbekannter Fehler';
                    } else if (roomsResponse instanceof Error) {
                        statusInfo = roomsResponse.message || 'Netzwerkfehler';
                    } else {
                        statusInfo = roomsResponseStatus || 'Unbekannter Fehler';
                    }
                    console.warn(`Zimmer konnten nicht geladen werden (${statusInfo}), verwende Fallback.`);
                    rooms = [
                        { id: 1, caption: 'Zimmer 1', capacity: 2, display_name: 'Zimmer 1 (2P)' },
                        { id: 2, caption: 'Zimmer 2', capacity: 4, display_name: 'Zimmer 2 (4P)' },
                        { id: 3, caption: 'Zimmer 3', capacity: 3, display_name: 'Zimmer 3 (3P)' }
                    ];
                    // Für computeAvailabilityMap verfügbar machen
                    window.rooms = rooms;
                }

                arrangementsCatalog = [];
                const arrangementsResponse = await arrangementsFetchPromise;
                if (arrangementsResponse instanceof Response && arrangementsResponse.ok) {
                    try {
                        const arrJson = await arrangementsResponse.json();
                        if (arrJson && typeof arrJson === 'object') {
                            arrangementsCatalog = Object.entries(arrJson).map(([id, label]) => {
                                const cleanLabel = typeof label === 'string' ? label.trim() : '';
                                const shortLabel = cleanLabel.split(/\s+/)[0] || cleanLabel || 'n/a';
                                const numericId = Number(id);
                                return {
                                    id: Number.isFinite(numericId) ? numericId : id,
                                    rawId: id,
                                    label: cleanLabel || 'n/a',
                                    shortLabel
                                };
                            });
                        }
                    } catch (arrError) {
                        console.warn('Arrangements konnten nicht geparst werden:', arrError);
                    }
                } else if (arrangementsResponse instanceof Error) {
                    console.warn('Arrangements konnten nicht geladen werden:', arrangementsResponse.message);
                }

                window.arrangementsCatalog = arrangementsCatalog;

                let histogramSource = [];
                let histogramStornoSource = [];
                let histogramAvailabilitySource = [];
                const histogramResponse = await histogramFetchPromise;
                console.log('🔍 Histogramm Response:', histogramResponse);

                if (histogramResponse instanceof Response && histogramResponse.ok) {
                    try {
                        const histogramJson = await histogramResponse.json();
                        console.log('📊 Histogramm JSON:', histogramJson);

                        if (histogramJson && histogramJson.success && histogramJson.data) {
                            if (Array.isArray(histogramJson.data.histogram)) {
                                histogramSource = histogramJson.data.histogram.map(entry => ({
                                    id: Number(entry.id),
                                    av_id: entry.av_id !== undefined && entry.av_id !== null ? Number(entry.av_id) : null,
                                    start: entry.start,
                                    end: entry.end,
                                    guest_name: entry.guest_name || '',
                                    capacity_details: entry.capacity_details || {}
                                }));
                                console.log(`✅ ${histogramSource.length} Histogramm-Einträge verarbeitet`);
                            } else {
                                console.warn('❌ Histogramm JSON hat keine gültige Struktur (histogram fehlt):', histogramJson);
                            }

                            if (Array.isArray(histogramJson.data.availability)) {
                                // DEBUG: Log first raw entry
                                console.log('🔍 RAW AVAILABILITY ENTRY:', histogramJson.data.availability[0]);

                                histogramAvailabilitySource = histogramJson.data.availability.map(entry => ({
                                    datum: entry.datum,
                                    free_places: Number(entry.free_places ?? entry.free_place ?? 0),
                                    hut_status: entry.hut_status || '',
                                    // Quota-Daten nach Kategorien
                                    quota_dz: Number(entry.quota_dz ?? 0),
                                    quota_betten: Number(entry.quota_betten ?? 0),
                                    quota_lager: Number(entry.quota_lager ?? 0),
                                    quota_sonder: Number(entry.quota_sonder ?? 0)
                                }));

                                // DEBUG: Log first parsed entry
                                console.log('🔍 PARSED AVAILABILITY ENTRY:', histogramAvailabilitySource[0]);
                                console.log(`✅ ${histogramAvailabilitySource.length} Verfügbarkeits-Einträge verarbeitet`);
                            }

                            if (Array.isArray(histogramJson.data.storno)) {
                                histogramStornoSource = histogramJson.data.storno.map(entry => ({
                                    id: Number(entry.id),
                                    av_id: entry.av_id !== undefined && entry.av_id !== null ? Number(entry.av_id) : null,
                                    start: entry.start,
                                    end: entry.end,
                                    guest_name: entry.guest_name || '',
                                    capacity_details: entry.capacity_details || {},
                                    storno: true
                                }));
                                console.log(`✅ ${histogramStornoSource.length} Storno-Histogramm-Einträge verarbeitet`);
                            }
                        } else {
                            console.warn('❌ Histogramm JSON hat keine gültige Struktur:', histogramJson);
                        }
                    } catch (histError) {
                        console.warn('❌ Histogrammdaten konnten nicht geparst werden:', histError);
                    }
                } else if (histogramResponse instanceof Error) {
                    console.warn('❌ Histogrammdaten konnten nicht geladen werden:', histogramResponse.message);
                } else {
                    console.warn('❌ Histogramm Response nicht OK:', histogramResponse?.status, histogramResponse?.statusText);
                }

                window.histogramSource = histogramSource;
                window.histogramStornoSource = histogramStornoSource;
                window.histogramAvailability = histogramAvailabilitySource;

                // DEBUG: Verify assignment worked
                console.log('🔍 AFTER ASSIGNMENT - window.histogramAvailability[0]:', window.histogramAvailability[0]);
                console.log('🔍 AFTER ASSIGNMENT - März 2026:', window.histogramAvailability.find(d => d.datum === '2026-03-01'));

                histogramSourceData = window.histogramSource;
                histogramStornoSourceData = window.histogramStornoSource;
                histogramAvailabilityData = window.histogramAvailability;
                arrangementsCatalog = window.arrangementsCatalog;

                console.log(`✅ Daten geladen: ${reservations.length} Reservierungen, ${roomDetails.length} Zuweisungen, ${rooms.length} Zimmer`);

                renderTimeline();
                if (typeof window.DebugConsole !== 'undefined') console.success('Daten aktualisiert.');

            } catch (error) {
                console.error('Fehler beim Laden der echten Daten:', error);
                // Bei Fehler: leere Timeline anzeigen
                reservations = [];
                roomDetails = [];
                rooms = [];
                arrangementsCatalog = [];
                window.arrangementsCatalog = [];
                window.histogramSource = [];
                window.histogramStornoSource = [];
                window.histogramAvailability = [];
                histogramSourceData = [];
                histogramStornoSourceData = [];
                histogramAvailabilityData = [];
                renderTimeline();
            }
        }

        // Globale Reload-Funktion für externe Aufrufe (z.B. nach Speichern der Zuweisungen)
        window.reloadTimelineData = async function () {
            try { await loadRealData(); } catch (e) { console.error('Reload failed', e); }
        };

        // API-Datum-Parser (kompatibel mit getZimmerplanData.php)
        function parseAPIDate(dateString) {
            if (!dateString) return new Date();

            dateString = dateString.trim();

            // ISO-Format (YYYY-MM-DD oder YYYY-MM-DD HH:MM:SS)
            if (/^\d{4}-\d{2}-\d{2}/.test(dateString)) {
                return new Date(dateString);
            }

            // Deutsches Format (DD.MM.YYYY)
            if (/^\d{1,2}\.\d{1,2}\.\d{4}/.test(dateString)) {
                const parts = dateString.split('.');
                if (parts.length >= 3) {
                    const day = parseInt(parts[0], 10);
                    const month = parseInt(parts[1], 10) - 1;
                    const year = parseInt(parts[2], 10);
                    return new Date(year, month, day, 12, 0, 0, 0);
                }
            }

            return new Date(dateString);
        }

        // Rendere Timeline (Canvas)
        function renderTimeline() {
            // Prüfe ob TimelineUnifiedRenderer verfügbar ist
            if (typeof TimelineUnifiedRenderer === 'undefined') {
                console.error('TimelineUnifiedRenderer ist nicht verfügbar. Prüfe, ob timeline-unified.js korrekt geladen wurde.');
                return;
            }

            // Prüfe ob Container existiert
            const container = document.querySelector('.main-areas-container');
            if (!container) {
                console.error('Container .main-areas-container nicht gefunden');
                return;
            }

            if (timelineRenderer) {
                console.debug('Aktualisiere bestehende Timeline-Instanz.');
                timelineRenderer.setArrangementsCatalog(arrangementsCatalog);
                timelineRenderer.setHistogramSource(window.histogramSource, window.histogramStornoSource, window.histogramAvailability);
                timelineRenderer.updateData(reservations, roomDetails, rooms);
                initializeTimelineToolbar();
            } else {
                console.debug('Erzeuge neue Timeline-Instanz.');
                timelineRenderer = new TimelineUnifiedRenderer('.main-areas-container');
                timelineRenderer.setArrangementsCatalog(arrangementsCatalog);
                timelineRenderer.setHistogramSource(window.histogramSource, window.histogramStornoSource, window.histogramAvailability);
                timelineRenderer.updateData(reservations, roomDetails, rooms);
                initializeTimelineToolbar();
            }
        }

        // ===== INITIALIZATION AND PERFORMANCE MONITORING =====

        // Performance Monitoring deaktiviert
        /*
        let fps = 0;
        let lastFrame = performance.now();
        let frameCount = 0;

        function updatePerformanceInfo() {
            const now = performance.now();
            frameCount++;

            if (now - lastFrame >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrame = now;

                document.getElementById('fps').textContent = fps;
                document.getElementById('reservations-count').textContent = reservations.length;
                document.getElementById('rooms-count').textContent = rooms.length;
            }

            requestAnimationFrame(updatePerformanceInfo);
        }
        updatePerformanceInfo();
        */

        // ===== VARIABLES AND INITIALIZATION =====

        // Globale Variablen für Kompatibilität
        let showDisposedReservations = true;

        // Globale Hilfsfunktion: Konfiguration lesen (Cookie/localStorage) + Live-Overrides
        function getConfiguredWeeksRange() {
            // Live-Overrides bevorzugen (durch Konfig-Seite via postMessage)
            const override = (window.timelineWeeksOverride || {});
            let past = typeof override.past === 'number' ? override.past : undefined;
            let future = typeof override.future === 'number' ? override.future : undefined;

            // Aus Cookie lesen
            try {
                const cookieValue = document.cookie
                    .split('; ')
                    .find(row => row.startsWith('timeline_config='))
                    ?.split('=')[1];
                if (cookieValue) {
                    const cfg = JSON.parse(decodeURIComponent(cookieValue));
                    if (typeof past !== 'number' && typeof cfg.weeksPast === 'number') past = cfg.weeksPast;
                    if (typeof future !== 'number' && typeof cfg.weeksFuture === 'number') future = cfg.weeksFuture;
                }
            } catch (e) {
                console.warn('Konfig aus Cookie konnte nicht gelesen werden:', e);
            }

            // Fallback: localStorage
            try {
                const ls = localStorage.getItem('timeline_config');
                if (ls) {
                    const cfg = JSON.parse(ls);
                    if (typeof past !== 'number' && typeof cfg.weeksPast === 'number') past = cfg.weeksPast;
                    if (typeof future !== 'number' && typeof cfg.weeksFuture === 'number') future = cfg.weeksFuture;
                }
            } catch (e) {
                console.warn('Konfig aus localStorage konnte nicht gelesen werden:', e);
            }

            // Defaults + Begrenzungen
            if (typeof past !== 'number' || isNaN(past)) past = 2;
            if (typeof future !== 'number' || isNaN(future)) future = 104;
            // clamp auf UI-Grenzen
            past = Math.max(0, Math.min(52, past));
            future = Math.max(4, Math.min(208, future));
            return { past, future };
        }

        // Initialisierung
        document.addEventListener('DOMContentLoaded', () => {
            // Message listener für Konfigurationsupdates

            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'updateMetric') {
                    console.log('Received config update:', event.data);

                    if (event.data.metric === 'menu-size' && timelineRenderer) {
                        const menuSize = event.data.value;
                        console.log('Updating menu size to:', menuSize);

                        // Update the radial menu size
                        if (timelineRenderer.updateMenuSize) {
                            timelineRenderer.updateMenuSize(menuSize);
                        } else {
                            // Fallback: update the global constant and force re-render
                            window.TIMELINE_RADIAL_MENU_SIZE = menuSize;
                            const radialMenu = document.getElementById('timeline-radial-menu');
                            if (radialMenu) {
                                radialMenu.style.width = `${menuSize}px`;
                                radialMenu.style.height = `${menuSize}px`;
                                radialMenu.style.marginLeft = `-${menuSize / 2}px`;
                                radialMenu.style.marginTop = `-${menuSize / 2}px`;
                            }
                        }
                        updateTimelineToolbarValues();
                    } else if ((event.data.metric === 'weeks-past' || event.data.metric === 'weeks-future')) {
                        // Live-Overrides merken
                        const val = parseFloat(event.data.value);
                        window.timelineWeeksOverride = window.timelineWeeksOverride || {};
                        if (event.data.metric === 'weeks-past') window.timelineWeeksOverride.past = val;
                        if (event.data.metric === 'weeks-future') window.timelineWeeksOverride.future = val;

                        // Daten neu laden, da sich der Zeitbereich geändert hat
                        console.log(`Zeitbereich geändert: ${event.data.metric} = ${val}. Lade Daten neu...`);
                        loadRealData().then(() => {
                            console.log('Daten erfolgreich für neuen Zeitbereich geladen');
                        }).catch(error => {
                            console.error('Fehler beim Neuladen der Daten nach Zeitbereichs-Änderung:', error);
                        });

                        // Renderer live updaten (sichtbarer Bereich)
                        if (timelineRenderer) {
                            if (!timelineRenderer.themeConfig) {
                                timelineRenderer.themeConfig = {};
                            }
                            if (event.data.metric === 'weeks-past') {
                                timelineRenderer.themeConfig.weeksPast = val;
                            } else if (event.data.metric === 'weeks-future') {
                                timelineRenderer.themeConfig.weeksFuture = val;
                            }
                            if (typeof timelineRenderer.scheduleRender === 'function') {
                                timelineRenderer.scheduleRender('weeks_range_change');
                            }
                            timelineRenderer.updateTopbarVisuals?.();
                        }
                        updateTimelineToolbarValues();
                    }
                }
            });

            // Prüfe auf Theme-Updates (wenn von Konfiguration zurückgekehrt)
            window.addEventListener('focus', () => {
                if (timelineRenderer && timelineRenderer.refreshThemeConfiguration) {
                    timelineRenderer.refreshThemeConfiguration();
                }
            });

            // Hinweis: Kein Abfangen von F5/Ctrl+R mehr – Browser-Reload bleibt Standardverhalten

            // Automatisch echte Daten laden beim Seitenaufruf
            setTimeout(() => {
                console.debug('Automatischer Datenabruf nach Seitenstart.');
                console.debug('TimelineUnifiedRenderer verfügbar:', typeof TimelineUnifiedRenderer);

                // Versuche echte Daten zu laden
                loadRealData().catch(error => {
                    console.error('Auto-load failed:', error);
                });
            }, 100); // 100ms Verzögerung
        });
    </script>

    <!-- Bootstrap 5.3.2 JS Bundle (includes Popper) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
</body>

</html>