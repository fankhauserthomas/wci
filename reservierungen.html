<!-- reservierungen.html -->
<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reservierungsliste - WebCheckin</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Reservierungen-spezifische Styles */
    .main-content {
      display: flex;
      flex-direction: column;
      height: 100vh;
      /* Volle Höhe ohne Navigation */
      min-height: 500px;
      overflow: hidden;
      padding: 0 !important;
      margin: 0 !important;
      box-sizing: border-box;
    }

    /* Statische HP-Arrangements Warnungen - Namen-Zelle */
    .name-cell.hp-warning-red {
      background-color: rgba(220, 53, 69, 0.25) !important;
      border-left: 4px solid #dc3545 !important;
      font-weight: 600 !important;
    }

    .name-cell.hp-warning-orange {
      background-color: rgba(255, 193, 7, 0.25) !important;
      border-left: 4px solid #ffc107 !important;
      font-weight: 600 !important;
    }

    /* Neue Markierungsklassen */
    .name-cell.hp-status-balanced {
      background-color: rgba(40, 167, 69, 0.25) !important;
      border-left: 4px solid #28a745 !important;
      font-weight: 600 !important;
    }

    .name-cell.hp-status-more-arrangements {
      background-color: rgba(220, 53, 69, 0.25) !important;
      border-left: 4px solid #dc3545 !important;
      font-weight: 600 !important;
    }

    .name-cell.hp-status-more-checkins {
      background-color: rgba(156, 39, 176, 0.25) !important;
      border-left: 4px solid #9c27b0 !important;
      font-weight: 600 !important;
    }

    /* Hover-Effekte für HP-Warnungen */
    .name-cell.hp-warning-red:hover {
      background-color: rgba(220, 53, 69, 0.35) !important;
    }

    .name-cell.hp-warning-orange:hover {
      background-color: rgba(255, 193, 7, 0.35) !important;
    }

    /* Hover-Effekte für neue Markierungsklassen */
    .name-cell.hp-status-balanced:hover {
      background-color: rgba(40, 167, 69, 0.35) !important;
    }

    .name-cell.hp-status-more-arrangements:hover {
      background-color: rgba(220, 53, 69, 0.35) !important;
    }

    .name-cell.hp-status-more-checkins:hover {
      background-color: rgba(156, 39, 176, 0.35) !important;
    }

    .controls.legacy-controls {
      flex-shrink: 0;
      background: white;
      z-index: 100;
      border-bottom: 2px solid #ddd;
      padding: 8px;
      /* Weiter reduziert von 10px */
      position: sticky;
      top: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .controls-left {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .progress-indicator {
      display: flex;
      align-items: center;
      padding: 4px 8px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #dee2e6;
      min-width: 350px;
    }

    .progress-stats {
      display: flex;
      flex-direction: row;
      gap: 15px;
      width: 100%;
      align-items: center;
    }

    .progress-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
      flex: 1;
    }

    .progress-label {
      font-size: 10px;
      color: #6c757d;
      font-weight: 500;
      white-space: nowrap;
    }

    .progress-bar-container {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .progress-bar {
      flex: 1;
      height: 12px;
      background: #e9ecef;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #dee2e6;
      min-width: 80px;
    }

    .progress-fill {
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 5px;
    }

    .progress-fill.guests-checkedin {
      background: linear-gradient(90deg, #28a745, #20c997);
    }

    .progress-fill.reservations-processed {
      background: linear-gradient(90deg, #007bff, #17a2b8);
    }

    .progress-text {
      font-size: 12px;
      font-weight: 700;
      color: #000000 !important;
      min-width: 45px;
      text-align: right;
      white-space: nowrap;
      background: rgba(255, 255, 255, 0.95) !important;
      padding: 2px 5px;
      border-radius: 3px;
      border: 1px solid #666;
      text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.8);
    }

    /* Styling für Datum und Suchfeld */
    #filterDate,
    #searchInput {
      background: #fdf6e3 !important;
      border: 2px solid #555 !important;
      border-radius: 4px;
      padding: 6px 8px;
    }

    #filterDate:focus,
    #searchInput:focus {
      background: #fcf4d9 !important;
      border-color: #333 !important;
      outline: none;
      box-shadow: 0 0 0 2px rgba(85, 85, 85, 0.1);
    }

    .table-container {
      flex: 1;
      overflow: hidden;
      position: relative;
      margin-top: -2px;
      /* Kompensiert den Border */
    }

    #resTable {
      width: 100%;
      height: 100%;
      border-collapse: separate;
      border-spacing: 0;
    }

    #resTable thead {
      position: sticky;
      top: 0;
      background: #2ecc71;
      z-index: 50;
      transition: background-color 0.3s ease;
    }

    #resTable thead th {
      background: #2ecc71;
      color: white;
      padding: 8px;
      border-bottom: 2px solid #27ae60;
      text-align: center;
      font-weight: 600;
      transition: background-color 0.3s ease, border-bottom-color 0.3s ease;
      position: relative;
    }

    #resTable thead th:hover {
      background: #27ae60;
    }



    /* Abreise-Modus Styling */
    .departure-mode #resTable thead {
      background: #b8860b;
    }

    .departure-mode #resTable thead th {
      background: #b8860b;
      border-bottom-color: #996f09;
    }

    .departure-mode #resTable thead th:hover {
      background: #996f09;
    }

    /* Button-Styling für verschiedene Modi */
    .toggle-btn {
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    /* Anreise-Modus (Standard - Grün) */
    .arrival-mode .toggle-btn.arrival,
    .arrival-mode .toggle-btn.no-storno,
    .arrival-mode .toggle-btn.all,
    .arrival-mode .toggle-btn.new-res {
      background: #27ae60;
      border-color: #229954;
    }

    .arrival-mode .toggle-btn.arrival:hover,
    .arrival-mode .toggle-btn.no-storno:hover,
    .arrival-mode .toggle-btn.all:hover,
    .arrival-mode .toggle-btn.new-res:hover {
      background: #2ecc71;
      border-color: #27ae60;
    }

    /* Abreise-Modus - Dunkelgold */
    .departure-mode .toggle-btn.departure,
    .departure-mode .toggle-btn.no-storno,
    .departure-mode .toggle-btn.all,
    .departure-mode .toggle-btn.new-res {
      background: #b8860b;
      border-color: #996f09;
    }

    .departure-mode .toggle-btn.departure:hover,
    .departure-mode .toggle-btn.no-storno:hover,
    .departure-mode .toggle-btn.all:hover,
    .departure-mode .toggle-btn.new-res:hover {
      background: #daa520;
      border-color: #b8860b;
    }

    /* Progress Bars Farbanpassung */
    .departure-mode .progress-fill.guests-checkedin {
      background: linear-gradient(90deg, #b8860b, #daa520);
    }

    .departure-mode .progress-fill.reservations-processed {
      background: linear-gradient(90deg, #8b6914, #b8860b);
    }

    .table-container {
      overflow-y: auto;
      max-height: calc(100vh - 150px);
      /* Weitere Reduzierung um sicherzugehen */
    }

    #resTable tbody tr {
      border-bottom: 1px solid #ddd;
    }

    #resTable tbody tr:hover {
      background-color: #f8f9fa;
    }

    #resTable tbody td {
      padding: 6px 8px;
      border-right: 1px solid #ddd;
      vertical-align: middle;
    }

    /* Spaltenbreiten definieren */
    #resTable th:nth-child(1),
    #resTable td:nth-child(1) {
      width: 60px;
      min-width: 60px;
    }

    #resTable th:nth-child(2),
    #resTable td:nth-child(2) {
      width: 80px;
      min-width: 80px;
    }

    #resTable th:nth-child(3),
    #resTable td:nth-child(3) {
      width: 80px;
      min-width: 80px;
    }

    #resTable th:nth-child(4),
    #resTable td:nth-child(4) {
      width: 60px;
      min-width: 60px;
    }

    #resTable th:nth-child(5),
    #resTable td:nth-child(5) {
      width: 200px;
      min-width: 200px;
    }

    #resTable th:nth-child(6),
    #resTable td:nth-child(6) {
      width: 80px;
      min-width: 80px;
    }

    #resTable th:nth-child(7),
    #resTable td:nth-child(7) {
      width: 60px;
      min-width: 60px;
    }

    #resTable th:nth-child(8),
    #resTable td:nth-child(8) {
      width: 150px;
      min-width: 150px;
    }

    #resTable th:nth-child(9),
    #resTable td:nth-child(9) {
      width: 150px;
      min-width: 150px;
    }
  </style>
</head>

<body>
  <main class="main-content">
    <div class="controls legacy-controls">
      <div class="controls-left">
        <!-- Typ-Toggle -->
        <button id="toggleType" class="toggle-btn arrival">Anreise</button>

        <!-- Datum -->
        <input type="date" id="filterDate">

        <!-- Storno-Toggle -->
        <button id="toggleStorno" class="toggle-btn no-storno">Ohne Storno</button>

        <!-- Alle/Offen-Toggle -->
        <button id="toggleOpen" class="toggle-btn all">Alle</button>

        <!-- Suche -->
        <div class="search-container">
          <input type="text" id="searchInput" placeholder="Suche Name…">
          <button type="button" id="clearSearchBtn" class="clear-search-btn" title="Suche löschen">×</button>
        </div>

        <!-- Neue Reservierung Button -->
        <button id="newReservationBtn" class="toggle-btn new-res">+ Neue Reservierung</button>
      </div>

      <!-- Progress Indicator rechts -->
      <div class="progress-indicator">
        <div class="progress-stats">
          <div class="progress-item">
            <div class="progress-label">Gäste eingecheckt</div>
            <div class="progress-bar-container">
              <div class="progress-bar">
                <div class="progress-fill guests-checkedin" style="width: 0%"></div>
              </div>
              <span class="progress-text" id="guestsProgress">0 / 0</span>
            </div>
          </div>
          <div class="progress-item">
            <div class="progress-label">Reservierungen bearbeitet</div>
            <div class="progress-bar-container">
              <div class="progress-bar">
                <div class="progress-fill reservations-processed" style="width: 0%"></div>
              </div>
              <span class="progress-text" id="reservationsProgress">0 / 0</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="table-container">
      <table id="resTable">
        <thead>
          <tr>
            <th>Status</th>
            <th>Anreise</th>
            <th>Abreise</th>
            <th>Anzahl</th>
            <th>Name</th>
            <th>arr</th>
            <th>ANam</th>
            <th>Bem</th>
            <th>Orig</th>
          </tr>
        </thead>
        <tbody>
          <!-- wird per script.js befüllt -->
        </tbody>
      </table>
    </div>
  </main>

  <!-- Info-Modal -->
  <div id="modal" class="modal">
    <div class="modal-content">
      <span id="modalClose" class="close">&times;</span>
      <div id="modalText"></div>
    </div>
  </div>

  <!-- QR-Modal -->
  <div id="qrModal" class="modal">
    <div class="modal-content">
      <span id="qrClose" class="close">&times;</span>
      <div id="qrContainer" style="text-align:center;"></div>
      <div style="text-align:center; margin-top: 20px;">
        <button id="emailGuestBtn" class="btn-email"
          style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
          📧 E-Mail an Gast senden
        </button>
      </div>
    </div>
  </div>

  <!-- Connection Status -->
  <div class="connection-status" id="connection-indicator">
    <div class="status-dot"></div>
    <span class="status-text">Verbindung prüfen...</span>
  </div>

  <!-- Barcode Scanner Modal entfernt - automatische Erkennung mit {..} -->

  <!-- Scripts optimiert für Performance -->
  <script src="js/email-utils.js"></script>
  <script src="js/http-utils.js"></script>
  <script src="js/loading-overlay.js"></script>
  <!-- QRCode.js erst bei Bedarf laden -->
  <script>
    // QR-Code Script nur laden wenn QR-Modal geöffnet wird
    let qrCodeScriptLoaded = false;
    function loadQRCodeScript() {
      if (qrCodeScriptLoaded) return Promise.resolve();

      return new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js';
        script.onload = () => {
          qrCodeScriptLoaded = true;
          console.log('[PERF] QRCode.js bei Bedarf geladen');
          resolve();
        };
        document.head.appendChild(script);
      });
    }
  </script>
  <!-- Sync-Utils verzögert laden für bessere Performance -->
  <script>
    // Sync-Utils nach 3 Sekunden laden um Page-Load zu beschleunigen
    setTimeout(() => {
      const syncScript = document.createElement('script');
      syncScript.src = 'js/sync-utils.js';
      syncScript.onload = () => console.log('[PERF] Sync-Utils verzögert geladen');
      document.head.appendChild(syncScript);
    }, 3000);
  </script>
  <!-- Auto-Barcode-Scanner verzögert laden -->
  <script>
    setTimeout(() => {
      const barcodeScript = document.createElement('script');
      barcodeScript.src = 'auto-barcode-scanner.js';
      barcodeScript.onload = () => console.log('[PERF] Auto-Barcode-Scanner verzögert geladen');
      document.head.appendChild(barcodeScript);
    }, 1500);
  </script>
  <script src="script.js"></script>

  <!-- BACKUP: Name-Click-Handler falls script.js versagt -->
  <script>
    // Simple backup solution for name clicking (Performance-optimiert)
    function addNameClickHandlers() {
      const nameCells = document.querySelectorAll('.name-cell');

      // Skip wenn keine Zellen vorhanden (Performance)
      if (nameCells.length === 0) {
        console.log('🔗 Backup: No name cells found, skipping handler setup');
        return;
      }

      console.log('🔗 Backup: Adding click handlers to', nameCells.length, 'name cells');

      nameCells.forEach(cell => {
        // Only add if not already clickable
        if (!cell.style.cursor || cell.style.cursor !== 'pointer') {
          cell.style.cursor = 'pointer';
          cell.addEventListener('click', function () {
            const resId = this.dataset.id;
            console.log('🔗 Backup: Name clicked, ID:', resId);
            if (resId) {
              window.location.href = `reservation.html?id=${resId}`;
            }
          });
        }
      });
    }

    // Run backup after script.js has had time to work
    setTimeout(addNameClickHandlers, 2000);

    // Also run when table changes
    const observer = new MutationObserver(() => {
      setTimeout(addNameClickHandlers, 500);
    });

    const tbody = document.querySelector('#resTable tbody');
    if (tbody) {
      observer.observe(tbody, { childList: true, subtree: true });
    }
  </script>

  <!-- Modal für neue Reservierung -->
  <div id="newReservationModal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width: 500px;">
      <span id="newResModalClose" class="close">&times;</span>
      <h2>Neue Reservierung</h2>
      <form id="newReservationForm">
        <div class="form-row">
          <label>Nachname*:</label>
          <input type="text" id="newResNachname" required>
        </div>
        <div class="form-row">
          <label>Vorname:</label>
          <input type="text" id="newResVorname">
        </div>
        <div class="form-row">
          <label>Herkunft:</label>
          <select id="newResHerkunft">
            <option value="">Bitte wählen...</option>
          </select>
        </div>
        <div class="form-row">
          <label>Anreise:</label>
          <input type="date" id="newResAnreise">
        </div>
        <div class="form-row">
          <label>Abreise:</label>
          <input type="date" id="newResAbreise">
        </div>
        <div class="form-row">
          <label>Arrangement:</label>
          <select id="newResArrangement">
            <option value="">Bitte wählen...</option>
          </select>
        </div>
        <div class="form-row">
          <label>Anzahl DZ:</label>
          <input type="number" id="newResDZ" min="0" value="0">
        </div>
        <div class="form-row">
          <label>Anzahl Betten:</label>
          <input type="number" id="newResBetten" min="0" value="0">
        </div>
        <div class="form-row">
          <label>Anzahl Lager:</label>
          <input type="number" id="newResLager" min="0" value="0">
        </div>
        <div class="form-row">
          <label>Anzahl Sonder:</label>
          <input type="number" id="newResSonder" min="0" value="0">
        </div>
        <div class="form-row">
          <label>Bemerkung:</label>
          <input type="text" id="newResBemerkung">
        </div>
        <div class="form-actions">
          <button type="submit" class="btn-save">Speichern</button>
          <button type="button" id="newResCancelBtn" class="btn-cancel">Abbrechen</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    // Automatischer Barcode-Scanner läuft im Hintergrund und reagiert auf {..} Pattern

    // Global variable to store real HP data (auch für script.js verfügbar)
    window.realHpData = new Map();

    // Variable für HP-Update-Kontrolle
    let lastHpUpdate = 0;
    const HP_UPDATE_INTERVAL = 5 * 60 * 1000; // 5 Minuten in Millisekunden

    // Globale HP-Update-Kontrolle - verhindert zu häufige Aufrufe
    let isHpUpdateRunning = false;
    let lastHpUpdateTime = 0;
    const MIN_HP_UPDATE_INTERVAL = 5000; // Mindestens 5 Sekunden zwischen HP-Updates

    // Debounce-Funktion hinzufügen
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Throttled HP-Update - verhindert übermäßige API-Aufrufe
    async function throttledHpUpdate() {
      const now = Date.now();

      // Wenn bereits ein Update läuft oder zu früh, ignorieren
      if (isHpUpdateRunning || (now - lastHpUpdateTime < MIN_HP_UPDATE_INTERVAL)) {
        console.log('⏳ HP-Update übersprungen (zu früh oder läuft bereits)');
        return;
      }

      isHpUpdateRunning = true;
      lastHpUpdateTime = now;

      try {
        console.log('🔄 HP-Update wird ausgeführt');
        await setAllHpWarnings();
      } finally {
        isHpUpdateRunning = false;
      }
    }

    // Function to load real HP arrangement data (verwendet Cache wenn möglich)
    async function loadRealHpData() {
      try {
        const date = document.getElementById('filterDate')?.value || new Date().toISOString().split('T')[0];
        const type = document.getElementById('toggleType')?.textContent.includes('Anreise') ? 'arrival' : 'departure';

        // Warte kurz auf mögliche parallele Ladung von script.js
        await new Promise(resolve => setTimeout(resolve, 100));

        // Prüfe ob bereits geladene Daten vorhanden sind (von script.js)
        if (window.realHpData && window.realHpData.size > 0) {
          console.log('✅ HP-Daten aus Cache verwendet:', window.realHpData.size, 'Reservierungen');
          return true;
        }

        // Prüfe ob gerade ein Ladevorgang von script.js läuft
        if (window.hpDataLoading) {
          console.log('⏳ Warte auf parallelen HP-Daten Load...');
          // Warte bis zu 2 Sekunden auf den parallelen Load
          for (let i = 0; i < 20; i++) {
            await new Promise(resolve => setTimeout(resolve, 100));
            if (window.realHpData && window.realHpData.size > 0) {
              console.log('✅ HP-Daten von parallelem Load erhalten:', window.realHpData.size, 'Reservierungen');
              return true;
            }
          }
        }

        console.log('🔄 HP-Daten werden separat geladen...');
        const response = await fetch(`get-all-hp-data.php?date=${date}&type=${type}`);
        const data = await response.json();

        if (data.success) {
          // Clear existing data
          window.realHpData.clear();

          // Store new data indexed by res_id
          data.data.forEach(item => {
            window.realHpData.set(item.res_id, {
              hpArrangements: item.hp_arrangements,
              checkedInCount: item.checked_in_count,
              totalNames: item.total_names,
              name: item.name
            });
          });

          console.log('✅ HP-Daten separat geladen:', window.realHpData.size, 'Reservierungen');
          return true;
        } else {
          console.error('❌ Failed to load HP data:', data.error);
          return false;
        }
      } catch (error) {
        console.error('❌ Error loading HP data:', error);
        return false;
      }
    }

    // Statische HP-Arrangements Hintergrund-Funktion (ressourcenschonend)
    function getStatusPercentage(cell) {
      const pieChart = cell.querySelector('.pie-chart');
      if (pieChart) {
        const textElement = pieChart.querySelector('text');
        if (textElement) {
          const percentText = textElement.textContent.trim();
          return parseInt(percentText.replace('%', '')) || 0;
        }
      }
      return 0;
    }

    function setHpWarningForRow(row) {
      const cells = row.querySelectorAll('td');
      if (cells.length < 9) {
        return;
      }

      // Extrahiere Reservierungs-ID aus data-res-id Attribut der Zeile
      const resId = parseInt(row.dataset.resId);
      if (!resId || isNaN(resId)) {
        return;
      }

      const nameCell = row.querySelector('.name-cell');
      if (!nameCell) {
        return;
      }

      // Versuche echte HP-Daten zu verwenden
      let hpArrangements = 0;
      let checkedInNames = 0;
      let useRealData = false;

      if (window.realHpData.has(resId)) {
        const realData = window.realHpData.get(resId);
        hpArrangements = realData.hpArrangements;
        checkedInNames = realData.checkedInCount;
        useRealData = true;
      } else {
        // Fallback: Alte Logik verwenden
        const anzahlCell = cells[3]; // Anzahl-Spalte (Gesamtgäste)
        const statusCell = cells[0]; // Status-Spalte (Check-in Prozent)
        const anamCell = cells[6]; // ANam-Spalte (HP-Arrangements)

        // Anzahl Gäste ermitteln
        const anzahlText = anzahlCell.textContent.trim();
        const totalGuests = parseInt(anzahlText) || 0;

        // HP-Arrangements aus ANam-Spalte ermitteln - NICHT prozentual!
        const anamText = anamCell.textContent.trim();

        // Text-basierte HP-Arrangements interpretieren - Anzahl der tatsächlichen Arrangements
        if (anamText.includes('HP')) {
          hpArrangements = totalGuests;
        } else if (anamText.includes('BHI')) {
          hpArrangements = totalGuests;
        } else if (anamText.includes('ALA')) {
          hpArrangements = totalGuests;
        } else if (anamText === 'n/a' || anamText === '') {
          hpArrangements = 0;
        } else {
          hpArrangements = parseInt(anamText) || 0;
        }

        // Status-Prozent ermitteln (wieviele Namen sind eingecheckt)
        const statusPercentage = getStatusPercentage(statusCell);
        checkedInNames = Math.round((statusPercentage / 100) * totalGuests);
      }

      // WICHTIG: Namen von Debug-Informationen bereinigen, aber HTML-Logos beibehalten
      const originalHtml = nameCell.innerHTML;
      // Entferne nur Debug-Info in eckigen Klammern, aber behalte HTML-Tags
      const cleanHtml = originalHtml.replace(/\s*\[[^\]]+\]/g, '');
      nameCell.innerHTML = cleanHtml;

      // Debug-Ausgabe für die ersten Zeilen
      if (resId <= 5) {
        console.log(`Debug Row ${resId}:`, {
          name: nameCell.textContent.trim(),
          hpArrangements,
          checkedInNames,
          useRealData
        });
      }

      // Entferne alle alten Klassen
      nameCell.classList.remove('hp-warning-red', 'hp-warning-orange', 'hp-status-balanced', 'hp-status-more-arrangements', 'hp-status-more-checkins');

      // Neue Regeln anwenden:
      if (checkedInNames === 0 && hpArrangements === 0) {
        // Regel: Wenn noch keine Namen eingecheckt und keine Arrangements angegeben -> keine Sonderfarbe
        nameCell.title = '';
        return;
      }

      // Tooltip mit echten oder berechneten Daten
      const dataSource = useRealData ? ' (DB)' : ' (berechnet)';

      if (hpArrangements === checkedInNames && hpArrangements > 0) {
        // Regel: Anzahl HP-Arrangements entspricht Anzahl eingecheckter Namen (beide > 0) -> hellgrüner Hintergrund
        nameCell.classList.add('hp-status-balanced');
        nameCell.title = `✓ Ausgeglichen${dataSource}: ${checkedInNames} eingecheckte Namen = ${hpArrangements} HP-Arrangements`;
      } else if (hpArrangements > checkedInNames) {
        // Regel: Mehr Arrangements als Check-ins -> rot
        nameCell.classList.add('hp-status-more-arrangements');
        nameCell.title = `⚠️ Mehr HP-Arrangements${dataSource}: ${hpArrangements} Arrangements > ${checkedInNames} eingecheckte Namen`;
      } else if (checkedInNames > hpArrangements) {
        // Regel: Mehr Check-ins als Arrangements -> lila
        nameCell.classList.add('hp-status-more-checkins');
        nameCell.title = `⚠️ Mehr eingecheckte Namen${dataSource}: ${checkedInNames} eingecheckte Namen > ${hpArrangements} HP-Arrangements`;
      } else {
        // Fallback: Title löschen wenn keine besonderen Bedingungen erfüllt
        nameCell.title = '';
      }
    }

    // Alle Zeilen auf einmal prüfen (wird nach Tabellenerstellung aufgerufen)
    async function setAllHpWarnings() {
      const tbody = document.querySelector('#resTable tbody');
      if (!tbody) {
        return;
      }

      // Erst HP-Daten laden
      await loadRealHpData();

      const rows = tbody.querySelectorAll('tr');

      // Direkte Verarbeitung aller Zeilen - keine Async/Await nötig
      rows.forEach(row => {
        setHpWarningForRow(row);
      });
    }



    // Progress Indicator Functions
    function updateProgressIndicators() {
      const tbody = document.querySelector('#resTable tbody');
      if (!tbody) return;

      const rows = tbody.querySelectorAll('tr');
      let totalReservations = 0;
      let processedReservations = 0;
      let totalGuests = 0;
      let checkedInGuests = 0;

      // Aktueller Anzeigemodus (Anreise/Abreise)
      const toggleType = document.getElementById('toggleType');
      const isArrival = toggleType && toggleType.textContent.includes('Anreise');

      // Farbschema basierend auf Modus umschalten
      updateColorScheme(isArrival);

      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length < 9) return;

        const statusCell = cells[0];
        const anzahlCell = cells[3];

        // Anzahl Gäste aus der Anzahl-Spalte extrahieren
        const anzahlText = anzahlCell.textContent.trim();
        const guestCount = parseInt(anzahlText) || 0;

        totalReservations++;
        totalGuests += guestCount;

        // Status aus Pie-Chart extrahieren
        const pieChart = statusCell.querySelector('.pie-chart');
        let statusPercentage = 0;

        if (pieChart) {
          // Text aus dem SVG extrahieren (z.B. "75%")
          const textElement = pieChart.querySelector('text');
          if (textElement) {
            const percentText = textElement.textContent.trim();
            statusPercentage = parseInt(percentText.replace('%', '')) || 0;
          }
        }

        // Bei 100% ist die Reservierung vollständig bearbeitet
        if (statusPercentage === 100) {
          processedReservations++;
          checkedInGuests += guestCount;
        } else if (statusPercentage > 0) {
          // Teilweise eingecheckt - anteilig zu den Gästen hinzufügen
          const partialGuests = Math.round((statusPercentage / 100) * guestCount);
          checkedInGuests += partialGuests;
        }
      });

      // Progress Bars aktualisieren
      updateProgressBar('guestsProgress', checkedInGuests, totalGuests, '.guests-checkedin');
      updateProgressBar('reservationsProgress', processedReservations, totalReservations, '.reservations-processed');

      // Labels dynamisch anpassen
      const guestsLabel = document.querySelector('.progress-item:first-child .progress-label');
      const reservationsLabel = document.querySelector('.progress-item:last-child .progress-label');

      if (guestsLabel) {
        guestsLabel.textContent = isArrival ? 'Gäste eingecheckt' : 'Gäste ausgecheckt';
      }
      if (reservationsLabel) {
        reservationsLabel.textContent = isArrival ? 'Reservierungen eingecheckt' : 'Reservierungen ausgecheckt';
      }

      // Debug-Ausgabe (reduziert)
      if (window.debugProgressUpdates) {
        console.log('Progress Update:', {
          totalReservations,
          processedReservations,
          totalGuests,
          checkedInGuests,
          isArrival
        });
      }

      // ENTFERNT: Automatischer HP-Check nach jedem Progress Update
      // Das verursachte die doppelten Checks - HP-Checks werden jetzt nur durch spezifische Events ausgelöst
    }

    // Debounced HP-Update-Funktion (früh definiert)
    const debouncedHpUpdate = debounce(() => throttledHpUpdate(), 2000); // 2 Sekunden Debounce

    // Farbschema basierend auf Anreise/Abreise-Modus umschalten
    function updateColorScheme(isArrival) {
      const body = document.body;

      if (isArrival) {
        body.classList.remove('departure-mode');
        body.classList.add('arrival-mode');
      } else {
        body.classList.remove('arrival-mode');
        body.classList.add('departure-mode');
      }
    }

    function updateProgressBar(textId, current, total, fillSelector) {
      const textElement = document.getElementById(textId);
      const fillElement = document.querySelector(fillSelector);

      if (textElement) {
        textElement.textContent = `${current} / ${total}`;
      }

      if (fillElement) {
        const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
        fillElement.style.width = `${percentage}%`;
      }
    }

    // Progress Indicators aktualisieren wenn Tabelle geladen/gefiltert wird
    function initProgressTracking() {
      // Observer für Tabellenänderungen (weniger sensitiv)
      const tbody = document.querySelector('#resTable tbody');
      if (tbody) {
        let observerTimeout;
        const observer = new MutationObserver(() => {
          // Debounce auch den Observer selbst
          clearTimeout(observerTimeout);
          observerTimeout = setTimeout(() => {
            console.log('🔄 Tabelle geändert - Progress Update');
            updateProgressIndicators();
            // HP-Warnungen nach Tabellenänderungen setzen (debounced)
            debouncedHpUpdate();
          }, 500); // Längere Verzögerung für Observer
        });

        observer.observe(tbody, {
          childList: true,
          subtree: false, // Nur direkte Kinder überwachen, nicht alle Nachkommen
          attributes: false, // Keine Attribut-Änderungen überwachen
        });
      }

      // Überwachung für loadData-Funktion falls verfügbar
      if (window.loadData) {
        const originalLoadData = window.loadData;
        window.loadData = function () {
          const result = originalLoadData.apply(this, arguments);
          setTimeout(updateProgressIndicators, 500);
          // HP-Warnungen nach loadData setzen (debounced)
          debouncedHpUpdate();
          return result;
        };
      }

      // Einmaliger initialer Update (Performance-optimiert)
      setTimeout(() => {
        updateProgressIndicators();
        // HP-Update nur wenn Tabelle bereits Daten hat
        const tbody = document.querySelector('#resTable tbody');
        if (tbody && tbody.children.length > 0) {
          debouncedHpUpdate();
        } else {
          console.log('⏩ HP-Update übersprungen - keine Daten in Tabelle');
        }
      }, 1000);

      // Initial color scheme setzen
      setTimeout(() => {
        const toggleType = document.getElementById('toggleType');
        const isArrival = toggleType && toggleType.textContent.includes('Anreise');
        updateColorScheme(isArrival);
      }, 100);

      // Update bei Filter-Änderungen
      const filterElements = [
        document.getElementById('toggleType'),
        document.getElementById('filterDate'),
        document.getElementById('toggleStorno'),
        document.getElementById('toggleOpen'),
        document.getElementById('searchInput')
      ];

      filterElements.forEach(element => {
        if (element) {
          // Standard change event
          element.addEventListener('change', () => {
            setTimeout(updateProgressIndicators, 200);
            debouncedHpUpdate();
          });

          // Click event für Buttons
          element.addEventListener('click', () => {
            setTimeout(updateProgressIndicators, 200);
            debouncedHpUpdate();
          });

          // Input event für sofortige Reaktion (besonders wichtig für Date-Picker)
          element.addEventListener('input', () => {
            setTimeout(updateProgressIndicators, 300);
            debouncedHpUpdate();
          });

          // Spezielle Behandlung für das Datumsfeld
          if (element.type === 'date') {
            // Zusätzliche Events für bessere Date-Picker Unterstützung
            element.addEventListener('blur', () => {
              setTimeout(updateProgressIndicators, 200);
              debouncedHpUpdate();
            });

            // Focus-out Event als Fallback
            element.addEventListener('focusout', () => {
              setTimeout(updateProgressIndicators, 200);
              debouncedHpUpdate();
            });
          }
        }
      });

      // Reduzierte periodische Updates (nur Progress, HP-Warnungen kontrolliert)
      setInterval(() => {
        updateProgressIndicators();

        // HP-Warnungen nur alle 5 Minuten neu setzen
        const now = Date.now();
        if (now - lastHpUpdate >= HP_UPDATE_INTERVAL) {
          console.log('🔄 HP-Daten werden aktualisiert (alle 5 Min)');
          throttledHpUpdate(); // Verwende throttled Version (ohne await in setInterval)
          lastHpUpdate = now;
        }
      }, 60000); // Alle 60 Sekunden
    }
    // Progress Tracking initialisieren wenn DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initProgressTracking);
    } else {
      initProgressTracking();
    }
  </script>
</body>

</html>