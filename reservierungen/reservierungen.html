<!-- reservierungen.html -->
<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Anti-Cache Meta Tags - Verhindert Browser-Caching -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Last-Modified" content="">

  <!-- Cache-Buster f√ºr Scripts -->
  <meta name="cache-buster" content="20250903-no-timers">

  <title>Reservierungsliste - WebCheckin</title>
  <link rel="stylesheet" href="../include/style.css">
  <style>
    /* Reservierungen-spezifische Styles */
    .main-content {
      display: flex;
      flex-direction: column;
      height: 100vh;
      /* Volle H√∂he ohne Navigation */
      min-height: 500px;
      overflow: hidden;
      padding: 0 !important;
      margin: 0 !important;
      box-sizing: border-box;
    }

    /* Sortiergruppen-Einf√§rbung f√ºr Namen-Zellen */
    .name-cell.sort-group-a {
      background-color: rgba(220, 53, 69, 0.25) !important;
      border-left: 4px solid #dc3545 !important;
      font-weight: 600 !important;
    }

    .name-cell.sort-group-b {
      background-color: rgba(255, 193, 7, 0.25) !important;
      border-left: 4px solid #ffc107 !important;
      font-weight: 600 !important;
    }

    /* Gruppe C: keine Einf√§rbung - Standard-Styling */

    .name-cell.sort-group-d {
      background-color: rgba(0, 123, 255, 0.25) !important;
      border-left: 4px solid #007bff !important;
      font-weight: 600 !important;
    }

    /* Hover-Effekte f√ºr Sortiergruppen */
    .name-cell.sort-group-a:hover {
      background-color: rgba(220, 53, 69, 0.35) !important;
    }

    .name-cell.sort-group-b:hover {
      background-color: rgba(255, 193, 7, 0.35) !important;
    }

    .name-cell.sort-group-c:hover {
      background-color: #f8f9fa !important;
    }

    .name-cell.sort-group-d:hover {
      background-color: rgba(0, 123, 255, 0.35) !important;
    }

    .controls.legacy-controls {
      flex-shrink: 0;
      background: white;
      z-index: 100;
      border-bottom: 2px solid #ddd;
      padding: 8px;
      /* Weiter reduziert von 10px */
      position: sticky;
      top: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .controls-left {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .progress-indicator {
      display: flex;
      align-items: center;
      padding: 4px 8px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #dee2e6;
      min-width: 350px;
    }

    .progress-stats {
      display: flex;
      flex-direction: row;
      gap: 15px;
      width: 100%;
      align-items: center;
    }

    .progress-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
      flex: 1;
    }

    .progress-label {
      font-size: 10px;
      color: #6c757d;
      font-weight: 500;
      white-space: nowrap;
    }

    .progress-bar-container {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .progress-bar {
      flex: 1;
      height: 12px;
      background: #e9ecef;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #dee2e6;
      min-width: 80px;
    }

    .progress-fill {
      height: 100%;
      transition: width 0.3s ease, min-width 0.3s ease;
      border-radius: 5px;
      position: relative;
    }

    /* Mindestbreite f√ºr bessere Sichtbarkeit bei niedrigen Werten */
    .progress-fill[style*="width: 0%"]:not([style*="min-width"]) {
      min-width: 0;
    }

    .progress-fill.guests-checkedin {
      background: linear-gradient(90deg, #28a745, #20c997);
    }

    .progress-fill.reservations-processed {
      background: linear-gradient(90deg, #007bff, #17a2b8);
    }

    .progress-text {
      font-size: 12px;
      font-weight: 700;
      color: #000000 !important;
      min-width: 45px;
      text-align: right;
      white-space: nowrap;
      background: rgba(255, 255, 255, 0.95) !important;
      padding: 2px 5px;
      border-radius: 3px;
      border: 1px solid #666;
      text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.8);
    }

    /* Dashboard Button */
    .dashboard-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      transition: background-color 0.2s ease;
      border: 1px solid #0056b3;
      margin-left: 10px;
    }

    .dashboard-btn:hover {
      background: #0056b3;
      color: white;
      text-decoration: none;
    }

    .dashboard-btn svg {
      flex-shrink: 0;
    }

    /* Styling f√ºr Datum und Suchfeld */
    #filterDate,
    #searchInput {
      background: #fdf6e3 !important;
      border: 2px solid #555 !important;
      border-radius: 4px;
      padding: 6px 8px;
    }

    #filterDate:focus,
    #searchInput:focus {
      background: #fcf4d9 !important;
      border-color: #333 !important;
      outline: none;
      box-shadow: 0 0 0 2px rgba(85, 85, 85, 0.1);
    }

    .date-nav {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .date-nav.hidden {
      display: none;
    }

    .date-nav-btn {
      background: #f0f0f0;
      border: 1px solid #888;
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }

    .date-nav-btn:hover:not(:disabled) {
      background: #e0e0e0;
      border-color: #666;
    }

    .date-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Neue Reservierung Modal */
    .modal-new-reservation .modal-content {
      width: min(90vw, 720px);
      max-width: 720px;
      padding: 20px 24px 24px;
    }

    .modal-new-reservation h2 {
      margin-bottom: 12px;
    }

    .modal-new-reservation form {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .modal-new-reservation .sections-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px 20px;
    }

    .modal-new-reservation .section {
      border: 1px solid #d9dee3;
      border-radius: 8px;
      padding: 12px 14px 14px;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .modal-new-reservation .section h3 {
      margin: 0;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: #495057;
    }

    .modal-new-reservation .field-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px 16px;
    }

    .modal-new-reservation .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .modal-new-reservation label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: #495057;
      margin-bottom: 4px;
    }

    .modal-new-reservation input[type="text"],
    .modal-new-reservation input[type="number"],
    .modal-new-reservation input[type="date"],
    .modal-new-reservation select,
    .modal-new-reservation textarea {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ced4da;
      border-radius: 6px;
      font-size: 14px;
      background: #fff;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .modal-new-reservation textarea {
      min-height: 72px;
      resize: vertical;
    }

    .modal-new-reservation input:focus,
    .modal-new-reservation select:focus,
    .modal-new-reservation textarea:focus {
      outline: none;
      border-color: #2684ff;
      box-shadow: 0 0 0 3px rgba(38, 132, 255, 0.15);
    }

    .modal-new-reservation .checkbox-field {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #495057;
      font-weight: 500;
    }

    .modal-new-reservation .form-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .modal-new-reservation .btn-cancel,
    .modal-new-reservation .btn-save {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .modal-new-reservation .btn-save {
      background: #2d8f4f;
      color: #fff;
    }

    .modal-new-reservation .btn-save:hover {
      background: #257642;
      box-shadow: 0 2px 8px rgba(45, 143, 79, 0.3);
      transform: translateY(-1px);
    }

    .modal-new-reservation .btn-cancel {
      background: #f1f3f5;
      color: #495057;
    }

    .modal-new-reservation .btn-cancel:hover {
      background: #e2e6ea;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    .modal-new-reservation .section small {
      display: block;
      margin-top: 4px;
      color: #868e96;
      font-size: 12px;
    }

    .table-container {
      flex: 1;
      overflow: hidden;
      position: relative;
      margin-top: -2px;
      /* Kompensiert den Border */
    }

    #resTable {
      width: 100%;
      height: 100%;
      border-collapse: separate;
      border-spacing: 0;
    }

    #resTable thead {
      position: sticky;
      top: 0;
      background: #2ecc71;
      z-index: 50;
      transition: background-color 0.3s ease;
    }

    #resTable thead th {
      background: #2ecc71;
      color: white;
      padding: 8px;
      border-bottom: 2px solid #27ae60;
      text-align: center;
      font-weight: 600;
      transition: background-color 0.3s ease, border-bottom-color 0.3s ease;
      position: relative;
    }

    #resTable thead th:hover {
      background: #27ae60;
    }



    /* Abreise-Modus Styling */
    .departure-mode #resTable thead {
      background: #b8860b;
    }

    .departure-mode #resTable thead th {
      background: #b8860b;
      border-bottom-color: #996f09;
    }

    .departure-mode #resTable thead th:hover {
      background: #996f09;
    }

    /* Button-Styling f√ºr verschiedene Modi */
    .toggle-btn {
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    /* Anreise-Modus (Standard - Gr√ºn) */
    .arrival-mode .toggle-btn.arrival,
    .arrival-mode .toggle-btn.no-storno,
    .arrival-mode .toggle-btn.all,
    .arrival-mode .toggle-btn.new-res {
      background: #27ae60;
      border-color: #229954;
    }

    .arrival-mode .toggle-btn.arrival:hover,
    .arrival-mode .toggle-btn.no-storno:hover,
    .arrival-mode .toggle-btn.all:hover,
    .arrival-mode .toggle-btn.new-res:hover {
      background: #2ecc71;
      border-color: #27ae60;
    }

    /* Abreise-Modus - Dunkelgold */
    .departure-mode .toggle-btn.departure,
    .departure-mode .toggle-btn.no-storno,
    .departure-mode .toggle-btn.all,
    .departure-mode .toggle-btn.new-res {
      background: #b8860b;
      border-color: #996f09;
    }

    .departure-mode .toggle-btn.departure:hover,
    .departure-mode .toggle-btn.no-storno:hover,
    .departure-mode .toggle-btn.all:hover,
    .departure-mode .toggle-btn.new-res:hover {
      background: #daa520;
      border-color: #b8860b;
    }

    /* Progress Bars Farbanpassung */
    .departure-mode .progress-fill.guests-checkedin {
      background: linear-gradient(90deg, #b8860b, #daa520);
    }

    .departure-mode .progress-fill.reservations-processed {
      background: linear-gradient(90deg, #8b6914, #b8860b);
    }

    .table-container {
      overflow-y: auto;
      max-height: calc(100vh - 150px);
      /* Weitere Reduzierung um sicherzugehen */
    }

    #resTable tbody tr {
      border-bottom: 1px solid #ddd;
    }

    #resTable tbody tr:hover {
      background-color: #f8f9fa;
    }

    #resTable tbody td {
      padding: 6px 8px;
      border-right: 1px solid #ddd;
      vertical-align: middle;
    }

    /* Spaltenbreiten definieren */
    #resTable th:nth-child(1),
    #resTable td:nth-child(1) {
      width: 60px;
      min-width: 60px;
    }

    #resTable th:nth-child(2),
    #resTable td:nth-child(2) {
      width: 80px;
      min-width: 80px;
    }

    #resTable th:nth-child(3),
    #resTable td:nth-child(3) {
      width: 80px;
      min-width: 80px;
    }

    #resTable th:nth-child(4),
    #resTable td:nth-child(4) {
      width: 60px;
      min-width: 60px;
    }

    #resTable th:nth-child(5),
    #resTable td:nth-child(5) {
      width: 200px;
      min-width: 200px;
    }

    #resTable th:nth-child(6),
    #resTable td:nth-child(6) {
      width: 80px;
      min-width: 80px;
    }

    #resTable th:nth-child(7),
    #resTable td:nth-child(7) {
      width: 60px;
      min-width: 60px;
    }

    #resTable th:nth-child(8),
    #resTable td:nth-child(8) {
      width: 150px;
      min-width: 150px;
    }

    #resTable th:nth-child(9),
    #resTable td:nth-child(9) {
      width: 150px;
      min-width: 150px;
    }
  </style>
</head>

<body>
  <main class="main-content">
    <div class="controls legacy-controls">
      <div class="controls-left">
        <!-- Typ-Toggle -->
        <button id="toggleType" class="toggle-btn arrival">Check-in heute</button>

        <!-- Datum mit Navigation -->
        <div class="date-nav" id="dateNav">
          <button type="button" id="filterDatePrev" class="date-nav-btn" title="Vorheriger Tag">‚óÄ</button>
          <input type="date" id="filterDate">
          <button type="button" id="filterDateNext" class="date-nav-btn" title="N√§chster Tag">‚ñ∂</button>
        </div>

        <!-- Storno-Toggle -->
        <button id="toggleStorno" class="toggle-btn no-storno">Ohne Storno</button>

        <!-- Suche -->
        <div class="search-container">
          <input type="text" id="searchInput" placeholder="Suche Name‚Ä¶">
          <button type="button" id="clearSearchBtn" class="clear-search-btn" title="Suche l√∂schen">√ó</button>
        </div>

        <!-- Neue Reservierung Button -->
        <button id="newReservationBtn" class="toggle-btn new-res">+ Neue Reservierung</button>
      </div>

      <!-- Progress Indicator rechts -->
      <div class="progress-indicator">
        <div class="progress-stats">
          <div class="progress-item">
            <div class="progress-label">G√§ste eingecheckt</div>
            <div class="progress-bar-container">
              <div class="progress-bar">
                <div class="progress-fill guests-checkedin" style="width: 0%"></div>
              </div>
              <span class="progress-text" id="guestsProgress">0 / 0</span>
            </div>
          </div>
          <div class="progress-item">
            <div class="progress-label">Reservierungen bearbeitet</div>
            <div class="progress-bar-container">
              <div class="progress-bar">
                <div class="progress-fill reservations-processed" style="width: 0%"></div>
              </div>
              <span class="progress-text" id="reservationsProgress">0 / 0</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Dashboard Button -->
      <a href="../index.php" class="dashboard-btn" title="Zur√ºck zum Dashboard">
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 0L0 6v10h5V9h6v7h5V6L8 0zm0 2.5L13 7v7h-1V8H4v6H3V7l5-4.5z" />
        </svg>
        Dashboard
      </a>
    </div>

    <div class="table-container">
      <table id="resTable">
        <thead>
          <tr>
            <th>Status</th>
            <th>Anreise</th>
            <th>Abreise</th>
            <th>Anzahl</th>
            <th>Name</th>
            <th>arr</th>
            <th>ANam</th>
            <th>Bem</th>
            <th>Orig</th>
          </tr>
        </thead>
        <tbody>
          <!-- wird per script.js bef√ºllt -->
        </tbody>
      </table>
    </div>
  </main>

  <!-- Info-Modal -->
  <div id="modal" class="modal">
    <div class="modal-content">
      <span id="modalClose" class="close">&times;</span>
      <div id="modalText"></div>
    </div>
  </div>

  <!-- QR-Modal -->
  <div id="qrModal" class="modal">
    <div class="modal-content">
      <span id="qrClose" class="close">&times;</span>
      <div id="qrContainer" style="text-align:center;"></div>
      <div style="text-align:center; margin-top: 20px;">
        <button id="emailGuestBtn" class="btn-email"
          style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
          üìß E-Mail an Gast senden
        </button>
      </div>
    </div>
  </div>

  <!-- Connection Status -->
  <div class="connection-status" id="connection-indicator">
    <div class="status-dot"></div>
    <span class="status-text">Verbindung pr√ºfen...</span>
  </div>

  <!-- Barcode Scanner Modal entfernt - automatische Erkennung mit {..} -->

  <!-- Scripts optimiert f√ºr Performance mit Cache-Buster -->
  <script src="../include/js/email-utils.js?v=20250903"></script>
  <script src="../include/js/http-utils.js?v=20250903"></script>
  <script src="../include/js/loading-overlay.js?v=20250903"></script>
  <!-- Auto-Refresh KOMPLETT DEAKTIVIERT - Timer-Killer laden -->
  <script src="js/auto-refresh-disabled.js?v=20250903"></script>
  <!-- QRCode.js erst bei Bedarf laden -->
  <script>
    // QR-Code Script nur laden wenn QR-Modal ge√∂ffnet wird
    let qrCodeScriptLoaded = false;
    function loadQRCodeScript() {
      if (qrCodeScriptLoaded) return Promise.resolve();

      return new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js';
        script.onload = () => {
          qrCodeScriptLoaded = true;
          resolve();
        };
        document.head.appendChild(script);
      });
    }
  </script>
  <!-- Sync-Utils verz√∂gert laden f√ºr bessere Performance -->
  <script>
    // Sync-Utils nach 3 Sekunden laden um Page-Load zu beschleunigen
    setTimeout(() => {
      const syncScript = document.createElement('script');
      syncScript.src = 'js/sync-utils.js';
      document.head.appendChild(syncScript);
    }, 3000);
  </script>
  <!-- Auto-Barcode-Scanner sofort laden (nicht verz√∂gert) -->
  <script>
    // Scanner sofort laden f√ºr bessere Responsivit√§t (Cache-Buster)
    const barcodeScript = document.createElement('script');
    barcodeScript.src = 'js/auto-barcode-scanner.js?v=20250903';
    barcodeScript.onload = () => console.log('‚úÖ Barcode-Scanner geladen');
    barcodeScript.onerror = () => console.error('‚ùå Barcode-Scanner Ladefehler');
    document.head.appendChild(barcodeScript);
  </script>
  <script src="js/script.js?v=20250903"></script>

  <!-- BACKUP: Name-Click-Handler falls script.js versagt -->
  <script>
    // Simple backup solution for name clicking (Performance-optimiert)
    function addNameClickHandlers() {
      const nameCells = document.querySelectorAll('.name-cell');

      // Skip wenn keine Zellen vorhanden (Performance)
      if (nameCells.length === 0) {
        return;
      }

      nameCells.forEach(cell => {
        // Only add if not already clickable
        if (!cell.style.cursor || cell.style.cursor !== 'pointer') {
          cell.style.cursor = 'pointer';
          cell.addEventListener('click', function () {
            const resId = this.dataset.id;

            if (resId) {
              window.location.href = `reservation.html?id=${resId}`;
            }
          });
        }
      });
    }

    // Run backup after script.js has had time to work - OPTIMIERT
    setTimeout(addNameClickHandlers, 500); // Reduziert von 2000ms auf 500ms

    // Also run when table changes - OPTIMIERT
    const observer = new MutationObserver(() => {
      setTimeout(addNameClickHandlers, 100); // Reduziert von 500ms auf 100ms
    });

    const tbody = document.querySelector('#resTable tbody');
    if (tbody) {
      observer.observe(tbody, { childList: true, subtree: true });
    }
  </script>

  <!-- Modal f√ºr neue Reservierung -->
  <div id="newReservationModal" class="modal modal-new-reservation" style="display:none;">
    <div class="modal-content">
      <span id="newResModalClose" class="close">&times;</span>
      <h2>Neue Reservierung</h2>
      <form id="newReservationForm" novalidate>
        <div class="sections-grid">
          <div class="section">
            <h3>Gast &amp; Herkunft</h3>
            <div class="field-grid">
              <div class="field">
                <label for="newResNachname">Nachname*</label>
                <input type="text" id="newResNachname" required>
              </div>
              <div class="field">
                <label for="newResVorname">Vorname</label>
                <input type="text" id="newResVorname">
              </div>
              <div class="field">
                <label for="newResHerkunft">Herkunft</label>
                <select id="newResHerkunft">
                  <option value="">Bitte w√§hlen...</option>
                </select>
              </div>
            </div>
            <label class="checkbox-field">
              <input type="checkbox" id="newResDog">
              <span>Gast reist mit Hund</span>
            </label>
          </div>

          <div class="section">
            <h3>Reisedaten &amp; Arrangement</h3>
            <div class="field-grid">
              <div class="field">
                <label for="newResAnreise">Anreise*</label>
                <input type="date" id="newResAnreise" required>
              </div>
              <div class="field">
                <label for="newResAbreise">Abreise*</label>
                <input type="date" id="newResAbreise" required>
                <small>Abreise muss nach der Anreise liegen.</small>
              </div>
              <div class="field">
                <label for="newResArrangement">Arrangement*</label>
                <select id="newResArrangement" required>
                  <option value="">Bitte w√§hlen...</option>
                </select>
              </div>
            </div>
          </div>

          <div class="section">
            <h3>Schlafpl√§tze</h3>
            <div class="field-grid">
              <div class="field">
                <label for="newResDZ">Doppelzimmer</label>
                <input type="number" id="newResDZ" min="0" value="0">
              </div>
              <div class="field">
                <label for="newResBetten">Betten</label>
                <input type="number" id="newResBetten" min="0" value="0">
              </div>
              <div class="field">
                <label for="newResLager">Lager</label>
                <input type="number" id="newResLager" min="0" value="0">
              </div>
              <div class="field">
                <label for="newResSonder">Sonder</label>
                <input type="number" id="newResSonder" min="0" value="0">
              </div>
            </div>
            <small>Summe der Schlafpl√§tze muss mindestens 1 betragen.</small>
          </div>

          <div class="section">
            <h3>Bemerkung</h3>
            <textarea id="newResBemerkung" placeholder="Interne Notizen zur Reservierung"></textarea>
          </div>
        </div>

        <div class="form-actions">
          <button type="button" id="newResCancelBtn" class="btn-cancel">Abbrechen</button>
          <button type="submit" class="btn-save">Speichern</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    // Automatischer Barcode-Scanner l√§uft im Hintergrund und reagiert auf {..} Pattern
    // Test mit {test123} oder einem echten Barcode

    // QR-Scanner Debug Panel (nur bei Debug-Mode)
    if (localStorage.getItem('debugMode') === 'true') {
      const debugPanel = document.createElement('div');
      debugPanel.style.cssText = `
        position: fixed; top: 10px; right: 10px; 
        background: rgba(0,0,0,0.8); color: white; 
        padding: 10px; border-radius: 5px; 
        font-family: monospace; font-size: 12px;
        z-index: 9999; max-width: 300px;
      `;
      debugPanel.innerHTML = `
        <h4>üîç QR-Scanner Debug</h4>
        <button onclick="testBarcodeScanner('TEST123')" style="margin: 2px;">Test Scanner</button>
        <button onclick="window.location.href='qr-test.html'" style="margin: 2px;">Volltest</button>
        <button onclick="localStorage.removeItem('debugMode'); location.reload();" style="margin: 2px;">Ausblenden</button>
        <div id="scanner-debug-info">Scanner wird geladen...</div>
      `;
      document.body.appendChild(debugPanel);

      // Update Debug Info
      setInterval(() => {
        const info = document.getElementById('scanner-debug-info');
        if (info && window.autoBarcodeScanner) {
          info.innerHTML = `
            Status: ${window.autoBarcodeScanner.scannerActive ? 'AKTIV' : 'Bereit'}<br>
            Buffer: "${window.autoBarcodeScanner.buffer}"<br>
            Seite: ${window.autoBarcodeScanner.isReservationListPage ? 'Liste' : 'Andere'}
          `;
        }
      }, 1000);
    }

    // Global variable to store real HP data (auch f√ºr script.js verf√ºgbar)
    window.realHpData = new Map();

    // Variable f√ºr HP-Update-Kontrolle
    let lastHpUpdate = 0;
    const HP_UPDATE_INTERVAL = 5 * 60 * 1000; // 5 Minuten in Millisekunden

    // Globale HP-Update-Kontrolle - verhindert zu h√§ufige Aufrufe - OPTIMIERT
    let isHpUpdateRunning = false;
    let lastHpUpdateTime = 0;
    const MIN_HP_UPDATE_INTERVAL = 1000; // Reduziert von 5000ms auf 1000ms f√ºr schnellere Updates

    // Debounce-Funktion hinzuf√ºgen
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Throttled Sort Group Update - verhindert √ºberm√§√üige API-Aufrufe
    async function throttledSortGroupUpdate() {
      const now = Date.now();

      // Wenn bereits ein Update l√§uft oder zu fr√ºh, ignorieren
      if (isHpUpdateRunning || (now - lastHpUpdateTime < MIN_HP_UPDATE_INTERVAL)) {
        // Sortiergruppen-Update wird √ºbersprungen (zu fr√ºh oder l√§uft bereits)
        return;
      }

      isHpUpdateRunning = true;
      lastHpUpdateTime = now;

      try {
        // Sortiergruppen-Update wird ausgef√ºhrt
        await setAllSortGroups();
      } finally {
        isHpUpdateRunning = false;
      }
    }

    // Function to load real HP arrangement data (verwendet Cache wenn m√∂glich)
    async function loadRealHpData() {
      try {
        // Verwende die gleiche Datum-Logik wie script.js loadData()
        let date;
        const mode = localStorage.getItem('filterMode') || 'arrival-today';
        if (mode === 'arrival-today') {
          date = new Date().toISOString().slice(0, 10);
        } else if (mode === 'departure-tomorrow') {
          const d = new Date(); d.setDate(d.getDate() + 1);
          date = d.toISOString().slice(0, 10);
        } else {
          const filterDateEl = document.getElementById('filterDate');
          date = filterDateEl ? filterDateEl.value : new Date().toISOString().slice(0, 10);
        }

        // Verwende die gleiche Type-Logik wie script.js getType()
        const type = (localStorage.getItem('filterMode') || 'arrival-today').startsWith('arrival') ? 'arrival' : 'departure';

        // loadRealHpData gestartet

        // Pr√ºfe zuerst ob bereits aktuelle Daten vorhanden sind
        if (window.realHpData && window.realHpData.size > 0) {
          // Pr√ºfe ob die Daten f√ºr das aktuelle Datum/Type sind
          const currentKey = `${date}_${type}`;
          if (window.lastHpDataKey === currentKey) {
            // HP-Daten aus Cache verwendet (aktuell)
            return true;
          }
        }

        // Pr√ºfe ob gerade ein Ladevorgang von script.js l√§uft
        if (window.hpDataLoading) {
          // Warte auf parallelen HP-Daten Load
          // Warte bis zu 1 Sekunde auf den parallelen Load
          for (let i = 0; i < 10; i++) {
            await new Promise(resolve => setTimeout(resolve, 100));
            if (window.realHpData && window.realHpData.size > 0) {
              // Setze den Key f√ºr Cache-Validation
              window.lastHpDataKey = `${date}_${type}`;
              // HP-Daten von parallelem Load erhalten
              return true;
            }
          }
        }

        // HP-Daten werden separat geladen
        const url = `get-all-hp-data.php?date=${date}&type=${type}`;


        const response = await fetch(url);
        const data = await response.json();



        if (data.success) {
          // Clear existing data
          window.realHpData.clear();

          // Store new data indexed by res_id
          data.data.forEach(item => {
            window.realHpData.set(item.res_id, {
              hpArrangements: item.hp_arrangements,
              checkedInCount: item.checked_in_count,
              totalNames: item.total_names,
              name: item.name,
              sortGroup: item.sort_group,
              sortDescription: item.sort_description
            });
          });

          // Setze Cache-Key f√ºr Validierung
          window.lastHpDataKey = `${date}_${type}`;
          // HP-Daten separat geladen

          return true;
        } else {
          console.error('‚ùå Failed to load HP data:', data.error);
          return false;
        }
      } catch (error) {
        console.error('‚ùå Error loading HP data:', error);
        return false;
      }
    }

    // Statische HP-Arrangements Hintergrund-Funktion (ressourcenschonend)
    function getStatusPercentage(cell) {
      const pieChart = cell.querySelector('.pie-chart');
      if (pieChart) {
        const textElement = pieChart.querySelector('text');
        if (textElement) {
          const percentText = textElement.textContent.trim();
          return parseInt(percentText.replace('%', '')) || 0;
        }
      }
      return 0;
    }

    function setSortGroupForRow(row) {
      const cells = row.querySelectorAll('td');
      if (cells.length < 9) {
        return;
      }

      // Extrahiere Reservierungs-ID aus data-res-id Attribut der Zeile
      const resId = parseInt(row.dataset.resId);
      if (!resId || isNaN(resId)) {
        // Keine g√ºltige resId gefunden f√ºr Zeile
        return;
      }

      const nameCell = row.querySelector('.name-cell');
      if (!nameCell) {
        // Keine name-cell gefunden f√ºr resId
        return;
      }

      // Entferne alle alten Sortiergruppen-Klassen
      nameCell.classList.remove('sort-group-a', 'sort-group-b', 'sort-group-c', 'sort-group-d');

      // Debug: Pr√ºfe ob realHpData verf√ºgbar ist
      // Debug setSortGroupForRow

      // Versuche Sortiergruppen-Daten aus realHpData zu verwenden
      if (window.realHpData && window.realHpData.has(resId)) {
        const realData = window.realHpData.get(resId);

        // Sortiergruppen-Daten f√ºr resId gefunden

        if (realData.sortGroup) {
          const sortGroup = realData.sortGroup.toLowerCase();
          const className = `sort-group-${sortGroup}`;
          nameCell.classList.add(className);

          // Tooltip mit Sortiergruppen-Information
          nameCell.title = realData.sortDescription || `Sortiergruppe ${realData.sortGroup}`;

          // Sortiergruppe erfolgreich angewendet
        } else {
          // Keine sortGroup in realData
        }
      } else {
        // Keine HP-Daten f√ºr resId
      }
    }

    // Globale Verf√ºgbarkeit f√ºr Auto-Refresh
    window.setSortGroupForRow = setSortGroupForRow;

    // Alle Zeilen auf einmal pr√ºfen (wird nach Tabellenerstellung aufgerufen)
    async function setAllSortGroups() {
      const tbody = document.querySelector('#resTable tbody');
      if (!tbody) {
        // setAllSortGroups: Tbody nicht gefunden
        return;
      }

      // Erst HP-Daten laden (enthalten jetzt auch Sortiergruppen)
      await loadRealHpData();

      const rows = tbody.querySelectorAll('tr');
      // Sortiergruppen werden angewendet

      // Direkte Verarbeitung aller Zeilen - keine Async/Await n√∂tig
      rows.forEach(row => {
        setSortGroupForRow(row);
      });

      // Sortiergruppen-Einf√§rbung abgeschlossen
    }

    // Globale Verf√ºgbarkeit f√ºr script.js
    window.setAllSortGroups = setAllSortGroups;

    // Debug-Funktion f√ºr Konsole
    window.debugSortGroups = function () {
      // Debug Sortiergruppen


      if (window.realHpData && window.realHpData.size > 0) {
        const groups = {};
        window.realHpData.forEach((data, resId) => {
          if (data.sortGroup) {
            groups[data.sortGroup] = (groups[data.sortGroup] || 0) + 1;
          }
        });


        // Teste erste 3 Zeilen
        const rows = document.querySelectorAll('#resTable tbody tr');


        for (let i = 0; i < Math.min(3, rows.length); i++) {
          const row = rows[i];
          const resId = parseInt(row.dataset.resId);
          const nameCell = row.querySelector('.name-cell');
          const data = window.realHpData.get(resId);

          // Debug-Info f√ºr Zeile
        }
      }
    };

    // Test-Funktion f√ºr manuelle Sortiergruppen-Anwendung
    window.testSortGroups = function () {
      // Manueller Test der Sortiergruppen
      setAllSortGroups();
    };

    // URL-Parameter f√ºr automatisches Datum setzen
    function checkUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);
      const dateParam = urlParams.get('date');
      const typeParam = (urlParams.get('type') || 'arrival').toLowerCase();

      if (dateParam) {
        const desiredMode = typeParam === 'departure' ? 'departure' : 'arrival';

        if (typeof window.setReservationFilterMode === 'function') {
          window.setReservationFilterMode(desiredMode, { date: dateParam, silent: true });
        } else {
          localStorage.setItem('filterMode', desiredMode);
          localStorage.setItem('filterDate', dateParam);
        }

        const dateField = document.getElementById('filterDate');
        if (dateField) {
          dateField.value = dateParam;
        }

        setTimeout(() => {
          if (window.loadData) {
            window.loadData();
          }
        }, 300);
      }
    }

    // URL-Parameter beim Laden pr√ºfen
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', checkUrlParams);
    } else {
      checkUrlParams();
    }



    // Progress Indicator Functions
    function updateProgressIndicators() {
      const tbody = document.querySelector('#resTable tbody');
      if (!tbody) return;

      const rows = tbody.querySelectorAll('tr');

      // Pr√ºfen ob Tabelle echte Daten hat (nicht nur "Keine Eintr√§ge gefunden")
      if (rows.length === 0 ||
        (rows.length === 1 && rows[0].textContent.includes('Keine Eintr√§ge gefunden'))) {
        // Tabelle ist noch leer oder zeigt "Keine Eintr√§ge" - nicht aktualisieren
        return;
      }

      let totalReservations = 0;
      let processedReservations = 0;
      let totalGuests = 0;
      let checkedInGuests = 0;

      // Aktueller Anzeigemodus (Anreise/Abreise)
      const mode = localStorage.getItem('filterMode') || 'arrival-today';
      const isArrival = mode.startsWith('arrival');

      // Farbschema basierend auf Modus umschalten
      updateColorScheme(isArrival);

      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length < 9) return;

        const statusCell = cells[0];
        const anzahlCell = cells[3];

        // Anzahl G√§ste aus der Anzahl-Spalte extrahieren
        const anzahlText = anzahlCell.textContent.trim();
        const guestCount = parseInt(anzahlText) || 0;

        totalReservations++;
        totalGuests += guestCount;

        // Status aus Pie-Chart extrahieren
        const pieChart = statusCell.querySelector('.pie-chart');
        let statusPercentage = 0;

        if (pieChart) {
          // Text aus dem SVG extrahieren (z.B. "75%")
          const textElement = pieChart.querySelector('text');
          if (textElement) {
            const percentText = textElement.textContent.trim();
            statusPercentage = parseInt(percentText.replace('%', '')) || 0;
          }
        }

        // Bei 100% ist die Reservierung vollst√§ndig bearbeitet
        if (statusPercentage === 100) {
          processedReservations++;
          checkedInGuests += guestCount;
        } else if (statusPercentage > 0) {
          // Teilweise eingecheckt - anteilig zu den G√§sten hinzuf√ºgen
          const partialGuests = Math.round((statusPercentage / 100) * guestCount);
          checkedInGuests += partialGuests;
        }
      });

      // Progress Bars aktualisieren
      updateProgressBar('guestsProgress', checkedInGuests, totalGuests, '.guests-checkedin');
      updateProgressBar('reservationsProgress', processedReservations, totalReservations, '.reservations-processed');

      // Labels dynamisch anpassen
      const guestsLabel = document.querySelector('.progress-item:first-child .progress-label');
      const reservationsLabel = document.querySelector('.progress-item:last-child .progress-label');

      if (guestsLabel) {
        guestsLabel.textContent = isArrival ? 'G√§ste eingecheckt' : 'G√§ste ausgecheckt';
      }
      if (reservationsLabel) {
        reservationsLabel.textContent = isArrival ? 'Reservierungen eingecheckt' : 'Reservierungen ausgecheckt';
      }

      // Debug-Ausgabe (reduziert)
      if (window.debugProgressUpdates) {
        console.log('Progress Update:', {
          totalReservations,
          processedReservations,
          totalGuests,
          checkedInGuests,
          isArrival
        });
      }

      // ENTFERNT: Automatischer HP-Check nach jedem Progress Update
      // Das verursachte die doppelten Checks - HP-Checks werden jetzt nur durch spezifische Events ausgel√∂st
    }

    // Smarte Progress-Update-Funktion, die wartet bis Tabelle Daten hat
    function waitForTableDataAndUpdate(maxAttempts = 10, delay = 500) {
      let attempts = 0;

      const checkAndUpdate = () => {
        attempts++;
        const tbody = document.querySelector('#resTable tbody');

        if (!tbody) {
          if (attempts < maxAttempts) {
            setTimeout(checkAndUpdate, delay);
          }
          return;
        }

        const rows = tbody.querySelectorAll('tr');
        const hasRealData = rows.length > 0 &&
          !(rows.length === 1 && rows[0].textContent.includes('Keine Eintr√§ge gefunden'));

        if (hasRealData) {
          // Tabelle hat echte Daten - Progress aktualisieren
          console.log(`Progress Update: Found ${rows.length} data rows after ${attempts} attempts`);
          updateProgressIndicators();
        } else if (attempts < maxAttempts) {
          // Noch keine Daten, nochmal versuchen
          setTimeout(checkAndUpdate, delay);
        } else {
          console.log('Progress Update: Max attempts reached, no data found');
        }
      };

      checkAndUpdate();
    }

    // Progress-Indikator-Funktion global verf√ºgbar machen
    window.updateProgressIndicators = updateProgressIndicators;
    window.waitForTableDataAndUpdate = waitForTableDataAndUpdate;

    // Custom Event f√ºr Progress-Updates von anderen Scripts
    document.addEventListener('tableDataLoaded', () => {
      console.log('tableDataLoaded event received');
      waitForTableDataAndUpdate(3, 200);
    });

    // Global verf√ºgbare Funktion zum Triggern von Progress-Updates
    window.triggerProgressUpdate = function (delay = 100) {
      setTimeout(() => waitForTableDataAndUpdate(3, 200), delay);
    };

    // Debounced Sort Group Update-Funktion (fr√ºh definiert) - OPTIMIERT f√ºr schnellere Darstellung
    const debouncedSortGroupUpdate = debounce(() => throttledSortGroupUpdate(), 300); // Reduziert von 2000ms auf 300ms

    // Farbschema basierend auf Anreise/Abreise-Modus umschalten
    function updateColorScheme(isArrival) {
      const body = document.body;

      if (isArrival) {
        body.classList.remove('departure-mode');
        body.classList.add('arrival-mode');
      } else {
        body.classList.remove('arrival-mode');
        body.classList.add('departure-mode');
      }
    }

    function updateProgressBar(textId, current, total, fillSelector) {
      const textElement = document.getElementById(textId);
      const fillElement = document.querySelector(fillSelector);

      if (textElement) {
        textElement.textContent = `${current} / ${total}`;
      }

      if (fillElement) {
        const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
        fillElement.style.width = `${percentage}%`;

        // Mindestbreite f√ºr bessere Sichtbarkeit bei niedrigen Werten
        if (percentage > 0 && percentage < 5) {
          fillElement.style.minWidth = '8px';
        } else {
          fillElement.style.minWidth = '';
        }
      }
    }

    // Progress Indicators aktualisieren wenn Tabelle geladen/gefiltert wird
    function initProgressTracking() {
      // Observer f√ºr Tabellen√§nderungen (weniger sensitiv)
      const tbody = document.querySelector('#resTable tbody');
      if (tbody) {
        let observerTimeout;
        const observer = new MutationObserver(() => {
          // Debounce auch den Observer selbst - OPTIMIERT f√ºr schnellere Reaktion
          clearTimeout(observerTimeout);
          observerTimeout = setTimeout(() => {
            // Tabelle ge√§ndert - Progress Update
            updateProgressIndicators();
            // Sortiergruppen nach Tabellen√§nderungen setzen (debounced)
            debouncedSortGroupUpdate();
          }, 150); // Reduziert von 500ms auf 150ms
        });

        observer.observe(tbody, {
          childList: true,
          subtree: false, // Nur direkte Kinder √ºberwachen, nicht alle Nachkommen
          attributes: false, // Keine Attribut-√Ñnderungen √ºberwachen
        });
      }

      // √úberwachung f√ºr loadData-Funktion falls verf√ºgbar
      if (window.loadData) {
        const originalLoadData = window.loadData;
        window.loadData = function () {
          const result = originalLoadData.apply(this, arguments);
          // Warte bis Daten geladen sind, dann Update
          setTimeout(() => waitForTableDataAndUpdate(5, 300), 500);
          // Sortiergruppen nach loadData setzen (debounced)
          debouncedSortGroupUpdate();
          return result;
        };
      } else {
        // loadData noch nicht verf√ºgbar, sp√§ter nochmal versuchen
        setTimeout(() => {
          if (window.loadData && !window.loadData._wrapped) {
            const originalLoadData = window.loadData;
            window.loadData = function () {
              const result = originalLoadData.apply(this, arguments);
              setTimeout(() => waitForTableDataAndUpdate(5, 300), 500);
              debouncedSortGroupUpdate();
              return result;
            };
            window.loadData._wrapped = true;
          }
        }, 1000);
      }

      // Einmaliger initialer Update (Performance-optimiert) - SCHNELLER
      setTimeout(() => {
        updateProgressIndicators();
        // Sortiergruppen-Update nur wenn Tabelle bereits Daten hat
        const tbody = document.querySelector('#resTable tbody');
        if (tbody && tbody.children.length > 0) {
          debouncedSortGroupUpdate();
        } else {
          // Sortiergruppen-Update √ºbersprungen - keine Daten in Tabelle
        }
      }, 200); // Reduziert von 1000ms auf 200ms

      // Initial color scheme setzen
      setTimeout(() => {
        const mode = localStorage.getItem('filterMode') || 'arrival-today';
        const isArrival = mode.startsWith('arrival');
        updateColorScheme(isArrival);
      }, 100);

      // Update bei Filter-√Ñnderungen
      const filterElements = [
        document.getElementById('toggleType'),
        document.getElementById('filterDate'),
        document.getElementById('toggleStorno'),
        document.getElementById('toggleOpen'),
        document.getElementById('searchInput')
      ];

      filterElements.forEach(element => {
        if (element) {
          // Standard change event - OPTIMIERT f√ºr schnellere Reaktion
          element.addEventListener('change', () => {
            setTimeout(updateProgressIndicators, 50); // Reduziert von 200ms auf 50ms
            debouncedSortGroupUpdate();
          });

          // Click event f√ºr Buttons - OPTIMIERT
          element.addEventListener('click', () => {
            setTimeout(updateProgressIndicators, 50); // Reduziert von 200ms auf 50ms
            debouncedSortGroupUpdate();
          });

          // Input event f√ºr sofortige Reaktion (besonders wichtig f√ºr Date-Picker) - OPTIMIERT
          element.addEventListener('input', () => {
            setTimeout(updateProgressIndicators, 100); // Reduziert von 300ms auf 100ms
            debouncedSortGroupUpdate();
          });

          // Spezielle Behandlung f√ºr das Datumsfeld
          if (element.type === 'date') {
            // Zus√§tzliche Events f√ºr bessere Date-Picker Unterst√ºtzung - OPTIMIERT
            element.addEventListener('blur', () => {
              setTimeout(updateProgressIndicators, 50); // Reduziert von 200ms auf 50ms
              debouncedSortGroupUpdate();
            });

            // Focus-out Event als Fallback - OPTIMIERT
            element.addEventListener('focusout', () => {
              setTimeout(updateProgressIndicators, 50); // Reduziert von 200ms auf 50ms
              debouncedSortGroupUpdate();
            });
          }
        }
      });

      // Reduzierte periodische Updates (nur Progress, HP-Warnungen kontrolliert)
      setInterval(() => {
        updateProgressIndicators();

        // Sortiergruppen nur alle 5 Minuten neu setzen
        const now = Date.now();
        if (now - lastHpUpdate >= HP_UPDATE_INTERVAL) {
          // Sortiergruppen-Daten werden aktualisiert (alle 5 Min)
          throttledSortGroupUpdate(); // Verwende throttled Version (ohne await in setInterval)
          lastHpUpdate = now;
        }
      }, 60000); // Alle 60 Sekunden
    }
    // Progress Tracking initialisieren wenn DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initProgressTracking);
    } else {
      initProgressTracking();
    }

    // Warten bis Tabelle Daten hat, dann Progress aktualisieren
    waitForTableDataAndUpdate();

    // Fallback-Updates f√ºr den Fall, dass die Daten sehr langsam laden
    setTimeout(() => waitForTableDataAndUpdate(5, 1000), 5000);
    setTimeout(() => waitForTableDataAndUpdate(3, 2000), 10000);

    // Debug-Hilfsfunktion f√ºr manuelles Testen (vereinfacht)
    window.testProgress = function () {
      console.log('=== PROGRESS TEST ===');
      const guestsEl = document.getElementById('guestsProgress');
      const reservationsEl = document.getElementById('reservationsProgress');

      console.log('Current values:');
      console.log('Guests:', guestsEl?.textContent);
      console.log('Reservations:', reservationsEl?.textContent);

      updateProgressIndicators();

      console.log('After update:');
      console.log('Guests:', guestsEl?.textContent);
      console.log('Reservations:', reservationsEl?.textContent);

      return 'Progress test completed - check values above';
    };

    // Zus√§tzliche Test-Funktion f√ºr direktes Element-Testing
    window.testElements = function () {
      console.log('=== ELEMENT TEST ===');

      // Direct DOM queries
      const elements = {
        guestsProgress: document.getElementById('guestsProgress'),
        reservationsProgress: document.getElementById('reservationsProgress'),
        guestsCheckedin: document.querySelector('.guests-checkedin'),
        reservationsProcessed: document.querySelector('.reservations-processed'),
        progressIndicator: document.querySelector('.progress-indicator'),
        tbody: document.querySelector('#resTable tbody')
      };

      Object.keys(elements).forEach(key => {
        const el = elements[key];
        console.log(`${key}:`, el);
        if (el) {
          console.log(`  - ID: ${el.id}, Classes: ${el.className}, Text: ${el.textContent?.slice(0, 50)}`);
        }
      });

      // Test manual updates
      if (elements.guestsProgress) {
        elements.guestsProgress.textContent = 'TEST 123 / 456';
        console.log('Manual text update applied to guestsProgress');
      }

      if (elements.guestsCheckedin) {
        elements.guestsCheckedin.style.width = '75%';
        elements.guestsCheckedin.style.backgroundColor = 'red';
        console.log('Manual style update applied to guestsCheckedin');
      }

      return elements;
    };

    window.testSortGroups = async function (testDate = '2025-08-30') {
      // Manueller Test der Sortiergruppen f√ºr Datum

      // Setze Datum
      const dateInput = document.getElementById('filterDate');
      if (dateInput) {
        dateInput.value = testDate;
      }

      // Lade Daten neu
      if (window.loadData) {
        await window.loadData();
      }

      // Force reload der HP-Daten
      window.realHpData.clear();
      await loadRealHpData();

      // Force apply der Sortiergruppen
      await setAllSortGroups();

      // Test abgeschlossen. Pr√ºfe die Tabelle!
    };
  </script>
</body>

</html>
