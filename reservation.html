<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reservierung anzeigen</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="reservation.css">
  <link rel="stylesheet" href="css/navigation.css">
  <link rel="stylesheet" href="css/navigation-integration.css">

  <!-- Guide Row Pulsing Animation -->
  <style>
    /* Guide Row Pulsing Animation - hellgold fade alle 2 Sekunden */
    @keyframes guidePulse {
      0% {
        background-color: transparent;
      }

      50% {
        background-color: rgba(255, 215, 0, 0.3);
        /* Hellgold mit Transparenz */
      }

      100% {
        background-color: transparent;
      }
    }

    /* Guide Row Styling */
    .guide-row {
      animation: guidePulse 2s infinite ease-in-out;
    }

    /* Optional: Verstärkung bei Hover */
    .guide-row:hover {
      animation-duration: 1s;
      /* Schnelleres Pulsieren bei Hover */
    }

    /* Sicherstellen dass die Animation auch bei ausgewählten Zeilen funktioniert */
    .guide-row.selected {
      animation: guidePulseSelected 2s infinite ease-in-out;
    }

    @keyframes guidePulseSelected {
      0% {
        background-color: rgba(74, 144, 226, 0.3);
        /* Normale Selektion */
      }

      50% {
        background-color: rgba(255, 215, 0, 0.5);
        /* Hellgold + Selektion */
      }

      100% {
        background-color: rgba(74, 144, 226, 0.3);
      }
    }

    /* Optional: Smooth Transition für bessere visuelle Qualität */
    .names-list tbody tr {
      transition: background-color 0.3s ease;
    }

    /* AV Icon Styling */
    .av-icon {
      position: absolute;
      top: -30px;
      left: -30px;
      height: 150px;
      width: auto;
      z-index: 1;
      opacity: 0.15;
      transition: opacity 0.3s ease;
    }

    .av-icon:hover {
      opacity: 0.3;
    }

    /* Header positioning für AV Icon */
    .res-header {
      position: relative;
    }

    /* Header content über AV Icon */
    .header-content {
      position: relative;
      z-index: 2;
    }
  </style>
</head>

<body>
  <!-- Navigation wird durch JavaScript eingefügt -->

  <main class="main-content">
    <!-- Reservation Header (grün) -->
    <div id="resHeader" class="res-header">
      <div class="header-content">
        <div class="header-info">
          <!-- Wird durch JavaScript befüllt -->
        </div>
        <div class="header-arrangements" id="headerArrangements">
          <!-- HP Arrangement Details werden hier angezeigt -->
          <div class="header-arr-title">HP Arrangements</div>
          <div class="header-arr-content" id="headerArrContent">
            <div class="loading-arr">Arrangements laden...</div>
          </div>
        </div>
        <div class="header-buttons">
          <button id="editBtn" class="header-btn">Bearbeiten</button>
          <button id="addNamesBtn" class="header-btn">Namen+</button>
          <button id="emailBtn" class="header-btn header-btn-blue">E-Mail</button>
          <button id="stornoBtn" class="header-btn header-btn-orange">Storno</button>
          <button id="deleteReservationBtn" class="header-btn header-btn-danger">Löschen</button>
        </div>
      </div>
    </div>

    <!-- Action Bar -->
    <div id="actionBar" class="action-bar">
      <button id="deleteBtn">Löschen</button>
      <button id="printBtn">Drucken</button>
      <button id="arrangementBtn" class="btn-arrangement">Arrangement…</button>
      <button id="dietBtn" class="btn-diet">Diät…</button>
      <button id="bulkCheckinBtn" class="btn-bulk" disabled>Bulk Check-in</button>
      <button id="bulkCheckoutBtn" class="btn-bulk" disabled>Bulk Check-out</button>
      <button id="backBtn">Zurück zur Liste</button>
    </div>

    <!-- Namen-Tabelle -->
    <div class="table-container">
      <table id="namesTable" class="names-list">
        <thead>
          <tr>
            <th><input type="checkbox" id="selectAll"></th>
            <th>Name</th>
            <th>Details</th>
            <th>Alter</th>
            <th>Bemerkung</th>
            <th>BF</th>
            <th>Arr</th>
            <th>Diät</th>
            <th>No-Show</th>
            <th>Check-in</th>
            <th>Check-out</th>
          </tr>
        </thead>
        <tbody>
          <!-- Wird durch JavaScript befüllt -->
        </tbody>
      </table>
    </div>

    <!-- Arrangement Modal -->
    <div id="arrangementModal" class="modal hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content">
        <span id="closeArrModal" class="modal-close">&times;</span>
        <h2>Arrangement wählen</h2>
        <div id="arrButtonsContainer" class="arr-buttons"></div>
      </div>
    </div>

    <!-- Diet Modal -->
    <div id="dietModal" class="modal hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content">
        <span id="closeDietModal" class="modal-close">&times;</span>
        <h2>Diät wählen</h2>
        <div id="dietButtonsContainer" class="arr-buttons"></div>
      </div>
    </div>

    <!-- Namen hinzufügen Modal -->
    <div id="addNamesModal" class="modal hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content modal-add-names">
        <span class="modal-close" id="addNamesModalClose">&times;</span>
        <h3>Namen hinzufügen</h3>
        <p>Fügen Sie neue Namen zur Reservierung hinzu. Pro Zeile ein Name:</p>

        <div class="import-format-selector">
          <label for="importFormat">Format:</label>
          <select id="importFormat">
            <option value="firstname-lastname">Vorname Nachname</option>
            <option value="lastname-firstname">Nachname Vorname</option>
          </select>
        </div>

        <textarea id="newNamesTextarea" placeholder="pro Zeile ein Eintrag"></textarea>

        <div class="modal-buttons">
          <button id="cleanNamesBtn" class="btn-secondary">Bereinigen</button>
          <button id="importNamesBtn" class="btn-confirm">Namen hinzufügen</button>
          <button id="addNamesCancel" class="btn-cancel">Abbrechen</button>
        </div>
      </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirmModal" class="modal hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content">
        <span class="modal-close" id="confirmModalClose">&times;</span>
        <h3 id="confirmModalTitle">Bestätigung</h3>
        <div id="confirmModalMessage"></div>
        <div id="confirmModalQuestion"></div>
        <div class="modal-buttons">
          <button id="confirmModalYes" class="btn-confirm">Ja</button>
          <button id="confirmModalNo" class="btn-cancel">Nein</button>
        </div>
      </div>
    </div>

    <!-- Name Correction Modal -->
    <div id="nameCorrectionModal" class="modal hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content">
        <span class="modal-close" id="nameCorrectionModalClose">&times;</span>
        <h3>Namen-Korrektur vorgeschlagen</h3>
        <p>Es wurde erkannt, dass in einem Namensfeld mehrere Namen stehen. Möchten Sie diese aufteilen?</p>

        <div id="nameCorrectionOptions" style="margin: 20px 0;">
          <!-- Options will be populated by JavaScript -->
        </div>

        <div style="margin: 15px 0;">
          <label for="customNameSplit" style="display: block; margin-bottom: 5px; font-weight: 600;">Eigene
            Aufteilung:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <div>
              <label for="customVorname" style="font-size: 0.9rem;">VN:</label>
              <input type="text" id="customVorname" placeholder="Vorname"
                style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; width: 120px;">
            </div>
            <div>
              <label for="customNachname" style="font-size: 0.9rem;">NN:</label>
              <input type="text" id="customNachname" placeholder="Nachname"
                style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; width: 120px;">
            </div>
          </div>
        </div>

        <div class="modal-buttons">
          <button id="nameCorrectionApply" class="btn-confirm">Anwenden</button>
          <button id="nameCorrectionSkip" class="btn-cancel">Überspringen</button>
        </div>
      </div>
    </div>

    <!-- Number Pad Modal -->
    <div id="numberPadModal" class="modal hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content number-pad-modal">
        <span class="modal-close" id="numberPadClose">&times;</span>
        <h3>Anzahl eingeben</h3>

        <div class="number-display">
          <input type="text" id="numberDisplay" readonly value="1">
        </div>

        <div class="number-pad">
          <button class="num-btn" data-num="1">1</button>
          <button class="num-btn" data-num="2">2</button>
          <button class="num-btn" data-num="3">3</button>
          <button class="num-btn" data-num="4">4</button>
          <button class="num-btn" data-num="5">5</button>
          <button class="num-btn" data-num="6">6</button>
          <button class="num-btn" data-num="7">7</button>
          <button class="num-btn" data-num="8">8</button>
          <button class="num-btn" data-num="9">9</button>
          <button class="num-btn clear-btn" data-action="clear">C</button>
          <button class="num-btn" data-num="0">0</button>
          <button class="num-btn backspace-btn" data-action="backspace">⌫</button>
        </div>

        <div class="number-pad-actions">
          <button id="numberPadCancel" class="btn-cancel">Abbrechen</button>
          <button id="numberPadOk" class="btn-confirm">OK</button>
        </div>
      </div>
    </div>

    <!-- Tisch-Uebersicht Modal -->
    <div id="tischUebersichtModal" class="modal hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content modal-tisch-uebersicht">
        <span class="modal-close" id="tischUebersichtClose">&times;</span>
        <h3>Tischübersicht - Reservierung</h3>
        <div class="iframe-container">
          <iframe id="tischUebersichtIframe" src="" style="width: 100%; height: 600px; border: none;"></iframe>
        </div>
      </div>
    </div>
  </main>

  <!-- Connection Status -->
  <div class="connection-status" id="connection-indicator">
    <div class="status-dot"></div>
    <span class="status-text">Verbindung prüfen...</span>
  </div>

  <!-- Navigation System -->
  <script src="js/navigation.js"></script>
  <script src="js/email-utils.js"></script>
  <script src="js/http-utils.js"></script>
  <script src="js/loading-overlay.js"></script>
  <script src="auto-barcode-scanner.js"></script>
  <script src="reservation.js"></script>

  <script>
    // Debug-System für Reservierung
    const DEBUG_RESERVATION = false; // Setze auf true für Debug-Modus

    // Smart Debug Logger
    window.debugLog = function (message, ...args) {
      if (DEBUG_RESERVATION) {
        console.log(message, ...args);
      }
    };

    window.debugWarn = function (message, ...args) {
      if (DEBUG_RESERVATION) {
        console.warn(message, ...args);
      }
    };

    window.debugError = function (message, ...args) {
      // Errors immer anzeigen
      console.error(message, ...args);
    };

    // Swipe-Navigation für Touch-Geräte
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let swipeIndicator = null;

    // Touch-Events nur für Touch-Geräte aktivieren
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
      document.addEventListener('touchstart', function (e) {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }, { passive: true });

      document.addEventListener('touchmove', function (e) {
        const currentX = e.changedTouches[0].screenX;
        const currentY = e.changedTouches[0].screenY;
        const deltaX = currentX - touchStartX;
        const deltaY = currentY - touchStartY;

        // Nur bei horizontalem Swipe nach rechts und minimaler vertikaler Bewegung
        if (deltaX > 30 && Math.abs(deltaY) < 50) {

          // Swipe-Indikator erstellen (falls noch nicht vorhanden)
          if (!swipeIndicator) {
            swipeIndicator = document.createElement('div');
            swipeIndicator.style.cssText = `
              position: fixed;
              top: 50%;
              right: 20px;
              transform: translateY(-50%);
              background: rgba(46, 204, 113, 0.9);
              color: white;
              padding: 12px 18px;
              border-radius: 25px;
              font-size: 14px;
              font-weight: bold;
              z-index: 10000;
              pointer-events: none;
              transition: all 0.2s ease;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
              display: flex;
              align-items: center;
              gap: 8px;
            `;
            swipeIndicator.innerHTML = 'Zurück <span style="font-size: 18px;">→</span>';
            document.body.appendChild(swipeIndicator);
          }

          // Opacity und Skalierung basierend auf Swipe-Distanz
          const progress = Math.min(Math.abs(deltaX) / 100, 1);
          const opacity = Math.max(0.3, progress);
          const scale = 0.8 + (progress * 0.2);

          swipeIndicator.style.opacity = opacity;
          swipeIndicator.style.transform = `translateY(-50%) scale(${scale})`;

          // Verhindere Scroll während Swipe
          if (progress > 0.3) {
            e.preventDefault();
          }
        }
      }, { passive: false });

      document.addEventListener('touchend', function (e) {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;

        // Indikator entfernen
        if (swipeIndicator) {
          swipeIndicator.style.opacity = '0';
          swipeIndicator.style.transform = 'translateY(-50%) scale(0.5)';
          setTimeout(() => {
            if (swipeIndicator) {
              swipeIndicator.remove();
              swipeIndicator = null;
            }
          }, 200);
        }

        // Swipe-Geste auswerten
        handleSwipeGesture();
      }, { passive: true });
    }

    function handleSwipeGesture() {
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      const absDeltaX = Math.abs(deltaX);
      const absDeltaY = Math.abs(deltaY);
      const minSwipeDistance = window.screen.width * 0.2; // 20% der Bildschirmbreite

      // Mindest-Swipe-Distanz (20% Bildschirmbreite) und horizontaler Swipe dominiert
      if (absDeltaX > minSwipeDistance && absDeltaX > absDeltaY * 1.5) {

        // Swipe nach rechts = zurück zur vorherigen Seite
        if (deltaX > 0) {
          debugLog('Swipe right detected - navigating back');

          // NavigationSystem verwenden wenn verfügbar
          if (typeof NavigationSystem !== 'undefined' && NavigationSystem.goBack) {
            NavigationSystem.goBack();
          } else {
            // Fallback: Browser-History oder zur Reservierungsliste
            if (document.referrer && document.referrer.includes('/wci/')) {
              window.history.back();
            } else {
              window.location.href = 'reservierungen.html';
            }
          }
        }
      }
    }

    // Navigation und Initialisierung
    document.addEventListener('DOMContentLoaded', function () {
      // Navigation Setup
      if (typeof NavigationSystem !== 'undefined') {
        NavigationSystem.setupNavigation();
        debugLog('✅ Navigation setup completed');
      } else {
        console.warn('⚠️ NavigationSystem not found');
      }

      // Connection Status
      const indicator = document.getElementById('connection-indicator');
      if (indicator && window.connectionMonitor && window.updateConnectionStatus) {
        window.updateConnectionStatus();
      }

      // Prüfe ob reservation.js bereits Daten lädt
      if (window.reservationJsLoading || window.currentReservationData) {
        debugLog('🚫 reservation.js already loading/loaded, skipping HTML initialization');
        return;
      }

      // Globales Flag setzen um doppelte Aufrufe zu verhindern
      window.headerDataLoadInitiated = true;
      window.htmlInitializationActive = true;

      // Warte kurz ab ob reservation.js sich meldet
      setTimeout(() => {
        if (!window.reservationJsLoading && !window.currentReservationData) {
          console.log('✅ HTML startet Header-Load nach Wartezeit');
          refreshHeaderData();
        } else {
          console.log('🚫 reservation.js hat sich gemeldet, HTML überspringt Load');
        }
        window.htmlInitializationActive = false;
      }, 50);

      debugLog('✅ Reservation page initialized');
      debugLog('✅ Swipe navigation enabled for touch devices');
    });

    // Debounce-Variablen für Header-Refresh
    let headerRefreshTimeout = null;
    let isHeaderRefreshing = false;
    let lastFocusTime = 0;
    let wasHidden = false;

    // Optimierte Event Listener - immer bei Fokus-Wechsel aktualisieren
    window.addEventListener('focus', function () {
      const now = Date.now();
      debugLog('🔄 Page focus detected - force refreshing header data...');
      // Forciere Header-Update bei Focus (wichtig nach ReservationDetails Änderungen)
      forceHeaderRefresh();
      lastFocusTime = now;
    });

    // Visibility Change - immer bei Tab-Wechsel aktualisieren
    document.addEventListener('visibilitychange', function () {
      if (document.hidden) {
        wasHidden = true;
      } else if (wasHidden) {
        debugLog('👁️ Page visible (after being hidden) - force refreshing header data...');
        // Forciere Header-Update nach Tab-Wechsel
        forceHeaderRefresh();
        wasHidden = false;
      }
    });

    // PageShow Event - wichtig für Navigation zurück von anderen Seiten
    window.addEventListener('pageshow', function (event) {
      // Besonders wichtig wenn von Browser-Cache geladen (bfcache)
      if (event.persisted) {
        console.log('🔄 Page restored from cache - force refreshing header data...');
        forceHeaderRefresh();
      }
    });

    // Custom Event für Invoice Status Änderungen
    window.addEventListener('invoiceStatusChanged', function (event) {
      console.log('💰 Invoice status changed detected:', event.detail);
      // Forciere sofortiges Header-Update bei Invoice-Änderung
      forceHeaderRefresh();
    });

    // Force Header Refresh - umgeht alle Koordinations- und Debounce-Mechanismen
    function forceHeaderRefresh() {
      debugLog('🚀 FORCE Header Refresh - bypassing all coordination');

      // Reset aller Flags
      isHeaderRefreshing = false;
      window.reservationJsLoading = false;

      // Lösche vorherige Timeouts
      if (headerRefreshTimeout) {
        clearTimeout(headerRefreshTimeout);
      }

      // Direkte Ausführung ohne Debouncing
      performForceHeaderRefresh();
    }

    async function performForceHeaderRefresh() {
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const resId = urlParams.get('id');

        if (!resId) {
          console.warn('⚠️ Keine Reservierungs-ID in URL gefunden');
          return;
        }

        console.log('🚀 FORCE Lade Header-Daten für Reservierung ID:', resId);

        // Direkt reservation.js loadReservationData aufrufen wenn verfügbar
        if (typeof window.loadReservationData === 'function') {
          console.log('✅ FORCE Verwende loadReservationData() aus reservation.js');
          await window.loadReservationData();
          console.log('✅ FORCE Header-Update über loadReservationData abgeschlossen');
        } else {
          console.log('⚠️ loadReservationData nicht verfügbar, verwende Fallback');

          // Fallback: Direkte API-Abfrage mit Force-Flag und Color-Parameter
          const apiUrl = `getReservationDetails.php?id=${resId}&includeColor=true&force=${Date.now()}`;
          const response = window.HttpUtils
            ? await HttpUtils.requestJson(apiUrl, {}, { retries: 2, timeout: 8000 })
            : await fetch(apiUrl).then(r => r.json());

          if (response && response.detail) {
            console.log('✅ FORCE Header-Daten erfolgreich geladen:', response.detail);
            updateHeaderDirectly(response.detail);
          } else {
            console.warn('⚠️ Keine gültigen Daten von getReservationDetails.php erhalten');
          }
        }
      } catch (error) {
        console.error('❌ Fehler beim FORCE Header-Update:', error);
      }
    }

    // Header-Daten neu laden mit Debouncing
    function refreshHeaderData() {
      // Verhindere mehrfache gleichzeitige Aufrufe
      if (isHeaderRefreshing) {
        console.log('🔄 Header-Refresh bereits aktiv, überspringe...');
        return;
      }

      // Vorherige Timeouts löschen
      if (headerRefreshTimeout) {
        clearTimeout(headerRefreshTimeout);
      }

      // Debounced Refresh nach 100ms
      headerRefreshTimeout = setTimeout(() => {
        performHeaderRefresh();
      }, 100);
    }

    async function performHeaderRefresh() {
      if (isHeaderRefreshing) {
        return;
      }

      // Zusätzliche Prüfung auf reservation.js Aktivität
      if (window.reservationJsLoading) {
        console.log('🚫 reservation.js ist bereits am Laden, HTML überspringt');
        return;
      }

      isHeaderRefreshing = true;

      try {
        // Reservierungs-ID aus URL holen
        const urlParams = new URLSearchParams(window.location.search);
        const resId = urlParams.get('id');

        if (!resId) {
          console.warn('⚠️ Keine Reservierungs-ID in URL gefunden');
          return;
        }

        console.log('🔄 Lade Header-Daten für Reservierung ID:', resId);

        // Prüfe ob reservation.js bereits geladen wurde und die Daten lädt
        if (window.headerDataLoadInitiated && typeof window.loadReservationData === 'function') {
          // Prüfe sofort ob reservation.js bereits aktiv ist
          if (window.reservationJsLoading || window.currentReservationData) {
            console.log('✅ reservation.js bereits aktiv, HTML überspringt komplett');
            return;
          }

          // Warte kurz ab ob reservation.js bereits am Laden ist
          let reservationJsTimeout = setTimeout(() => {
            console.log('⏳ reservation.js scheint nicht zu laden, verwende eigene Logik...');
            performActualRefresh(resId);
          }, 150); // Erhöht von 300ms auf 150ms für bessere Reaktion

          // Prüfe alle 25ms ob reservation.js bereits aktiv ist (häufiger)
          let checkInterval = setInterval(() => {
            if (window.reservationJsLoading || window.currentReservationData || document.querySelector('.header-info').textContent.trim()) {
              console.log('✅ reservation.js hat bereits Daten geladen, überspringe eigenen Aufruf');
              clearTimeout(reservationJsTimeout);
              clearInterval(checkInterval);
            }
          }, 25);

          // Cleanup nach 1 Sekunde (reduziert von 2 Sekunden)
          setTimeout(() => {
            clearTimeout(reservationJsTimeout);
            clearInterval(checkInterval);
          }, 1000);

        } else {
          // reservation.js nicht verfügbar, verwende direkte Logik
          performActualRefresh(resId);
        }

      } finally {
        // Nach 1 Sekunde wieder freigeben
        setTimeout(() => {
          isHeaderRefreshing = false;
        }, 1000);
      }
    }

    async function performActualRefresh(resId) {
      // Progressive Retry-Logik für reservation.js Funktionen
      let retryCount = 0;
      const maxRetries = 5;
      const retryDelay = 200;

      const tryLoadReservationData = () => {
        if (typeof window.loadReservationData === 'function') {
          console.log('✅ Verwende loadReservationData() aus reservation.js');
          window.loadReservationData().then(() => {
            console.log('✅ Header-Update über loadReservationData abgeschlossen');
          }).catch(error => {
            console.error('❌ Fehler beim Header-Update:', error);
          });
        } else if (retryCount < maxRetries) {
          retryCount++;
          console.log(`⏳ loadReservationData noch nicht verfügbar (Versuch ${retryCount}/${maxRetries}), wiederhole in ${retryDelay}ms...`);
          setTimeout(tryLoadReservationData, retryDelay);
        } else {
          console.warn('⚠️ loadReservationData nach mehreren Versuchen nicht verfügbar, verwende Fallback');
          loadHeaderDataDirectly(resId);
        }
      };

      tryLoadReservationData();
    }

    // Direkte Header-Daten-Abfrage über reservation.js loadReservationData
    async function loadHeaderDataDirectly(resId) {
      try {
        console.log('📡 Lade Header-Daten über reservation.js loadReservationData...');

        // reservation.js loadReservationData Funktion aufrufen wenn verfügbar
        if (typeof loadReservationData === 'function') {
          console.log('✅ Verwende loadReservationData() aus reservation.js');
          await loadReservationData();
          console.log('✅ Header-Update über loadReservationData abgeschlossen');
        } else {
          console.log('⚠️ loadReservationData nicht gefunden, verwende Fallback');

          // Fallback: Direkte API-Abfrage mit Color-Parameter
          const apiUrl = `getReservationDetails.php?id=${resId}&includeColor=true`;
          const response = window.HttpUtils
            ? await HttpUtils.requestJson(apiUrl, {}, { retries: 2, timeout: 8000 })
            : await fetch(apiUrl).then(r => r.json());

          if (response) {
            console.log('✅ Header-Daten erfolgreich geladen (Fallback):', response);
            updateHeaderDirectly(response);
          } else {
            console.warn('⚠️ Keine Daten von getReservationDetails.php erhalten');
          }
        }
      } catch (error) {
        console.error('❌ Fehler beim Laden der Header-Daten:', error);
      }
    }

    // Direkter DOM-Update falls keine passende Funktion gefunden wird
    function updateHeaderDirectly(data) {
      console.log('🔧 Führe direkten DOM-Update durch...', data);

      const headerElement = document.getElementById('resHeader');
      if (!headerElement) {
        console.warn('⚠️ Header-Element nicht gefunden');
        return;
      }

      // Use server-provided color if available
      if (data.headerColor) {
        console.log('✅ Verwende Server-berechnete Farbe:', data.headerColor, data.headerColorName);

        // Multiple approaches to ensure color update works
        // 1. CSS Variable (primary method)
        document.documentElement.style.setProperty('--res-header-bg', data.headerColor, 'important');

        // 2. Direct style on element (fallback)
        headerElement.style.setProperty('background-color', data.headerColor, 'important');

        // 3. Force re-render by toggling class
        headerElement.classList.remove('invoice-header', 'normal-header');
        setTimeout(() => {
          headerElement.classList.add(data.isInvoice ? 'invoice-header' : 'normal-header');
        }, 10);

        console.log('🎨 FORCE Header-Farbe gesetzt (Server):', {
          invoice: data.invoice,
          isInvoice: data.isInvoice,
          color: data.headerColor,
          colorName: data.headerColorName
        });

      } else if (data.invoice !== undefined) {
        // Fallback: Client-side calculation
        console.log('⚙️ Verwende Client-seitige Farb-Berechnung');

        // Explizite Behandlung aller möglichen Invoice-Werte
        const isInvoice = data.invoice === true || data.invoice === 1 || data.invoice === '1' || data.invoice === 'true';
        const color = isInvoice ? '#B8860B' : '#2d8f4f'; // Dark Gold : Dark Green

        // Multiple approaches to ensure color update works
        // 1. CSS Variable
        document.documentElement.style.setProperty('--res-header-bg', color, 'important');

        // 2. Direct style on element
        headerElement.style.setProperty('background-color', color, 'important');

        // 3. Force re-render by toggling class
        headerElement.classList.remove('invoice-header', 'normal-header');
        setTimeout(() => {
          headerElement.classList.add(isInvoice ? 'invoice-header' : 'normal-header');
        }, 10);

        console.log('🎨 FORCE Header-Farbe gesetzt (Client):', {
          invoice: data.invoice,
          isInvoice: isInvoice,
          color: color,
          result: isInvoice ? 'DARK GOLD' : 'DARK GREEN'
        });

      } else {
        console.warn('⚠️ Keine invoice-Daten in Response gefunden:', data);
      }

      // Header-Text aktualisieren falls vorhanden
      const headerInfo = document.querySelector('.header-info');
      if (headerInfo && data) {
        console.log('📝 Header-Info-Element gefunden - bereit für Updates');
      }

      // AV Icon hinzufügen wenn av_id > 0
      if (data && data.av_id && parseInt(data.av_id) > 0) {
        console.log('🔍 AV ID gefunden:', data.av_id, '- füge AV Icon hinzu');
        addAvIcon();
      } else {
        console.log('⚪ Keine AV ID oder av_id <= 0 - entferne AV Icon falls vorhanden');
        removeAvIcon();
      }
    }

    // Funktion zum Hinzufügen des AV Icons
    function addAvIcon() {
      const headerElement = document.getElementById('resHeader');
      if (!headerElement) return;

      // Prüfen ob AV Icon bereits vorhanden ist
      let avIcon = headerElement.querySelector('.av-icon');
      if (!avIcon) {
        avIcon = document.createElement('img');
        avIcon.className = 'av-icon';
        avIcon.src = 'pic/AV.svg';
        avIcon.alt = 'AV Reservierung';
        avIcon.title = 'AV Reservierung';
        headerElement.appendChild(avIcon);
        console.log('✅ AV Icon hinzugefügt');
      }
    }

    // Funktion zum Entfernen des AV Icons
    function removeAvIcon() {
      const headerElement = document.getElementById('resHeader');
      if (!headerElement) return;

      const avIcon = headerElement.querySelector('.av-icon');
      if (avIcon) {
        avIcon.remove();
        console.log('🗑️ AV Icon entfernt');
      }
    }

    // Make functions globally available
    window.addAvIcon = addAvIcon;
    window.removeAvIcon = removeAvIcon;

    // ===== GUIDE ROW PULSING ANIMATION =====

    // Guide Row Animation - JavaScript Teil für dynamische Anwendung
    let isUpdatingGuideRows = false; // Flag to prevent infinite loops

    function updateGuideRowAnimation() {
      if (isUpdatingGuideRows) {
        console.log('🛡️ Skipping updateGuideRowAnimation - already updating to prevent infinite loop');
        return;
      }

      isUpdatingGuideRows = true;
      debugLog('🔄 Updating Guide Row animations...');

      // Alle Tabellenzeilen durchgehen
      const tableRows = document.querySelectorAll('#namesTable tbody tr');
      debugLog(`📊 Found ${tableRows.length} table rows`); let guidesFound = 0;
      tableRows.forEach((row, index) => {
        // BF-Spalte (6. Spalte) analysieren - keine Checkbox, sondern Text/Symbol
        const bfCell = row.querySelector('td:nth-child(6)');

        if (bfCell) {
          const bfContent = bfCell.textContent.trim();
          const bfInnerHTML = bfCell.innerHTML.trim();

          console.log(`Row ${index}: BF cell content:`, bfContent, 'innerHTML:', bfInnerHTML);

          // Prüfe auf verschiedene Guide-Indikatoren:
          // ✓ Symbol, "true", "1", "ja", oder andere positive Indikatoren
          const isGuide = (
            bfContent === '✓' ||
            bfContent === '✔' ||
            bfContent === '☑' ||
            bfContent.toLowerCase() === 'true' ||
            bfContent === '1' ||
            bfContent.toLowerCase() === 'ja' ||
            bfContent.toLowerCase() === 'yes' ||
            bfInnerHTML.includes('✓') ||
            bfInnerHTML.includes('✔') ||
            bfInnerHTML.includes('☑') ||
            bfCell.classList.contains('guide-active') ||
            bfCell.classList.contains('bf-active')
          );

          console.log(`Row ${index}: Is Guide:`, isGuide);

          if (isGuide) {
            // Guide Flag ist gesetzt - Animation hinzufügen
            row.classList.add('guide-row');
            guidesFound++;
            const nameCell = row.querySelector('td:nth-child(2)');
            console.log('✨ Guide animation added to row:', nameCell?.textContent?.trim());
          } else {
            // Guide Flag nicht gesetzt - Animation entfernen
            row.classList.remove('guide-row');
          }
        } else {
          console.log(`Row ${index}: No BF cell found`);
        }
      });

      console.log(`🎯 Total guides with animation: ${guidesFound}`);
      isUpdatingGuideRows = false; // Reset the flag
    }

    // Event Listener für BF-Zellen-Änderungen (keine Checkboxen)
    function setupGuideAnimationListeners() {
      console.log('🎯 Setting up Guide animation listeners...');

      // Observer für dynamisch hinzugefügte Zellen
      const tableBody = document.querySelector('#namesTable tbody');
      console.log('📊 Table body found:', tableBody);

      if (tableBody) {

        // Event Delegation für BF-Zellen (Spalte 6)
        tableBody.addEventListener('click', function (event) {
          const target = event.target;
          console.log('�️ Click detected:', target);

          // Prüfen ob es eine BF-Zelle ist
          const bfCell = target.closest('td:nth-child(6)');

          if (bfCell) {
            console.log('🔄 BF cell clicked:', bfCell);

            // Nach Click kurz warten und Animation aktualisieren
            setTimeout(updateGuideRowAnimation, 150);
          }
        });

        // Zusätzlicher Change-Listener für falls doch Eingabefelder vorhanden sind
        tableBody.addEventListener('change', function (event) {
          console.log('🔄 Content changed:', event.target);
          setTimeout(updateGuideRowAnimation, 100);
        });

        // Zusätzlicher Input-Listener für Textänderungen
        tableBody.addEventListener('input', function (event) {
          console.log('� Input detected:', event.target);
          setTimeout(updateGuideRowAnimation, 100);
        });

        // Mutation Observer für neue Zeilen und Inhaltsänderungen
        const observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
              console.log('🔄 New table rows detected');
              setTimeout(updateGuideRowAnimation, 300);
            } else if (mutation.type === 'characterData' ||
              (mutation.type === 'attributes' && mutation.attributeName === 'class')) {

              // Skip if we're currently updating guide rows to prevent infinite loops
              if (isUpdatingGuideRows) {
                console.log('🛡️ Skipping mutation observer trigger - guide rows are being updated');
                return;
              }

              // Skip if the class change is just adding/removing guide-row class
              if (mutation.type === 'attributes' && mutation.target.tagName === 'TR') {
                const oldValue = mutation.oldValue || '';
                const newValue = mutation.target.className || '';
                const onlyGuideRowChanged = (
                  oldValue.replace('guide-row', '').trim() ===
                  newValue.replace('guide-row', '').trim()
                );
                if (onlyGuideRowChanged) {
                  console.log('🛡️ Skipping guide-row class change to prevent infinite loop');
                  return;
                }
              }

              console.log('🔄 Cell content or class changed');
              setTimeout(updateGuideRowAnimation, 150);
            }
          });
        });

        observer.observe(tableBody, {
          childList: true,
          subtree: true,
          characterData: true,
          attributes: true,
          attributeFilter: ['class'],
          attributeOldValue: true // Enable to compare old vs new values
        });

        console.log('✅ Guide animation observer active (enhanced for non-checkbox BF)');
      } else {
        console.warn('⚠️ Table body not found for guide animation setup');
      }
    }

    // Optimiertes Setup - wartet auf vollständig geladene Tabelle
    function initializeGuideAnimation() {
      console.log('🚀 Initializing Guide animation (optimized)...');
      setupGuideAnimationListeners();

      // Warte auf Tabelle MIT Daten (nicht nur leere Struktur)
      const checkForTableData = setInterval(() => {
        const tableRows = document.querySelectorAll('#namesTable tbody tr');
        const hasData = tableRows.length > 0 &&
          tableRows[0].querySelector('td:nth-child(6)'); // BF-Spalte vorhanden

        if (hasData) {
          console.log(`📊 Table ready with ${tableRows.length} rows, starting animation...`);
          updateGuideRowAnimation();
          clearInterval(checkForTableData);
          console.log('✅ Guide animation initialized once with data');
        } else {
          console.log('⏳ Waiting for table data...');
        }
      }, 300);

      // Fallback timeout nach 5 Sekunden
      setTimeout(() => {
        clearInterval(checkForTableData);
        console.log('⚠️ Guide animation timeout - initializing anyway');
        updateGuideRowAnimation();
      }, 5000);
    }

    // Warte nur bis DOM bereit ist
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeGuideAnimation);
    } else {
      setTimeout(initializeGuideAnimation, 500);
    }

    // Integration mit bestehender Logik - Hook in Header-Refresh
    const originalPerformForceHeaderRefresh = window.performForceHeaderRefresh;
    if (typeof originalPerformForceHeaderRefresh === 'function') {
      window.performForceHeaderRefresh = async function () {
        await originalPerformForceHeaderRefresh.call(this);

        // Nach Header-Refresh auch Guide-Animationen aktualisieren
        setTimeout(updateGuideRowAnimation, 300);
      };
    }

    // Hook in reservation.js loadReservationData falls verfügbar
    const checkForReservationJSIntegration = setInterval(() => {
      if (typeof window.loadReservationData === 'function' && !window.guideAnimationHooked) {
        const originalLoadReservationData = window.loadReservationData;
        window.loadReservationData = async function () {
          const result = await originalLoadReservationData.call(this);

          // Nach Datenladung Guide-Animationen aktualisieren
          setTimeout(updateGuideRowAnimation, 500);

          return result;
        };

        window.guideAnimationHooked = true;
        clearInterval(checkForReservationJSIntegration);
        console.log('✅ Guide animation integrated with reservation.js');
      }

      // Zusätzlich: Hook für loadNames falls verfügbar
      if (typeof window.loadNames === 'function' && !window.guideAnimationNamesHooked) {
        const originalLoadNames = window.loadNames;
        window.loadNames = async function () {
          const result = await originalLoadNames.call(this);

          // Nach Namen-Ladung Guide-Animationen starten
          setTimeout(() => {
            console.log('🎯 Names loaded, updating guide animations...');
            updateGuideRowAnimation();
          }, 200);

          return result;
        };

        window.guideAnimationNamesHooked = true;
        console.log('✅ Guide animation integrated with loadNames');
      }
    }, 100);

    // Timeout nach 5 Sekunden
    setTimeout(() => {
      clearInterval(checkForReservationJSIntegration);
    }, 5000);

    // Export für external access
    window.updateGuideRowAnimation = updateGuideRowAnimation;
    window.setupGuideAnimationListeners = setupGuideAnimationListeners;

    // Test-Funktionen für Debug
    window.testGuideAnimation = function () {
      console.log('🧪 Testing Guide Animation...');
      const tableRows = document.querySelectorAll('#namesTable tbody tr');
      console.log(`Found ${tableRows.length} rows for testing`);

      // Erste Zeile als Test-Guide markieren
      if (tableRows.length > 0) {
        const testRow = tableRows[0];
        testRow.classList.add('guide-row');
        console.log('✅ Test animation applied to first row');

        // Nach 5 Sekunden wieder entfernen
        setTimeout(() => {
          testRow.classList.remove('guide-row');
          console.log('🔄 Test animation removed');
        }, 5000);
      }
    };

    window.debugGuideRows = function () {
      console.log('🔍 Debugging Guide Rows (Enhanced for BF symbols)...');
      const tableRows = document.querySelectorAll('#namesTable tbody tr');

      tableRows.forEach((row, index) => {
        const cells = row.querySelectorAll('td');
        console.log(`Row ${index}:`);

        cells.forEach((cell, cellIndex) => {
          const content = cell.textContent.trim();
          const innerHTML = cell.innerHTML.trim();

          if (cellIndex === 5) { // BF column (6th column, index 5)
            console.log(`  BF Cell ${cellIndex + 1}: "${content}" (HTML: "${innerHTML}")`);

            // Check for guide indicators
            const isGuide = (
              content === '✓' ||
              content === '✔' ||
              content === '☑' ||
              content.toLowerCase() === 'true' ||
              content === '1' ||
              innerHTML.includes('✓') ||
              innerHTML.includes('✔')
            );

            console.log(`    → Is Guide: ${isGuide}`);
          } else if (content !== '') {
            console.log(`  Cell ${cellIndex + 1}: "${content}"`);
          }
        });
      });
    };

    // Erweiterte Debug-Funktion für BF-Zellen
    window.debugBFCells = function () {
      console.log('🔍 Analyzing BF Cells specifically...');
      const bfCells = document.querySelectorAll('#namesTable tbody tr td:nth-child(6)');

      bfCells.forEach((cell, index) => {
        const content = cell.textContent.trim();
        const innerHTML = cell.innerHTML;
        const classList = cell.className;

        console.log(`BF Cell ${index}:`);
        console.log(`  Content: "${content}"`);
        console.log(`  HTML: ${innerHTML}`);
        console.log(`  Classes: ${classList}`);
        console.log(`  ---`);
      });
    };

    console.log('✅ Guide row pulsing animation initialized (Enhanced for BF symbols)');
    console.log('🧪 Test with: testGuideAnimation(), debugGuideRows(), or debugBFCells()');
  </script>
</body>

</html>